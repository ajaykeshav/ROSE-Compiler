\chapter{Parser Building Blocks}
\label{chap:parserBlocks}
It is often needed to write a small parser to parse customized source code annotations in forms of C/C++ pragmas or Fortran comments.
The parser is responsible for recognizing keywords, variables, expressions in the annotations and storing the recognized information in AST, often
in a form of persistent AstAttribute.
ROSE provides a set of helper functions which can be used to create such a simple parser using recursive descent parsing\footnote{Description of basic recursive descent parsing techniques can be found at \url{http://en.wikipedia.org/wiki/Recursive_descent_parser}}. These functions are collected in the namespace named AstFromString, documented under the Namespace List of ROSE's online Doxygen web references.  

A suggested workflow to build your own pragma (or comment) parser is:
\begin{itemize}
\item  input: define the grammar of your pragma, including keywords, directives and optional clauses. Borrowing grammars of OpenMP is a good idea.
\item  output: define your own AstAttribute in order to store any possible pragma information generated by your parser. The attribute data structure should store the AST subtrees generated by a parser. The Attribute itself should be attached to relevant statement node (pragma declarations or others) in the original AST.
\item  parser: write your recursive descent pragma parser by leveraging the functions defined in  \textit{rose\_sourcetree/src/frontend/SageIII/astFromString/AstFromString.h}.  The parsing results will be used to generate your attribute which should be attached to your pragma declaration statement (or a following statement for a Fortran comment).
\item use of parsing results: in another phase, write your traversal to recognize the attached attribute to do whatever you plan to do with the pragma information.
\end{itemize}

A full example is provided under \textit{rose/projects/pragmaParsing} to demonstrate the entire workflow of using parser building blocks (helper functions within AstFromString) to create a parser to parse user-defined pragmas.  
We will use this example in this tutorial.


\section{Grammar Examples}
The first step of  building a parser is to formally define the grammar of input strings. 
The online Doxygen web reference lists helper functions from the AstFromString namespace, with detailed information about the underneath grammars they try to recognize. 
These grammar can be used as example about how to prepare grammars. 

For example \lstinline{bool afs_match_cast_expression ()} follows the grammar like: \\
\lstinline {cast_expression : '(' type_name ')' cast_expression | unary_expression}, which means a cast expression is either a unary expression or another cast expression prepended with a type name enclosed in a pair of parenthesis. Note that the grammar has a rule with a right recursion here (\lstinline {cast_expression : '(' type_name ')' cast_expression}). 
The grammars should try to avoid left recursion (e.g., \lstinline{result : result something_else} ), which may leads infinite recursive calls in your parser.  
Again, a helper function in AstFromString often implements a grammar. Please take a look at some of them to see how grammars are written to facilitate building recursive descent parsers.  

The pragma in the pragmaParsing project has the following grammar (documented in \textit{rose/projects/pragmaParsing/hcpragma.h}):
\begin{verbatim}
---------- grammar begin -----------
% 'string' means literal string to be matched
% | means alternation
hcc_pragma = '#pragma' hc_simple_part | hc_cuda_part

hc_simple_part = 'hc' 'entry'| 'suspendable' | 'entry suspendable' | 'suspendable entry'

hc_cuda_part = 'CUDA' kernel_part| place_part

kernel_part = 'kernel'

% place could be an expression
% the grammar uses assignment_expression instead of expression to disallow comma expressions
% (list of expressions connected with comma) e.g. exp1, exp2 will be parsed to be (ex1, exp2) 
% otherwise.
% 
place_part = assignment_expression autodim_part | dim_part

% autodim(<dim1>[, <dim2>, <dim3>, <shared_size>])
%  [ ] means optional
% , means  ',' to be simple
% assignment_expression is used to avoid parsing exp1, exp2, exp3 to be one single comma 
% expression ((exp1,exp2),exp3)
autodim_part = 'autodim' '('  assignment_expression [, assignment_expression 
              [, assignment_expression [, assignment_expression ] ] ]  ')'

% dim(blocksPerGrid, threadsPerBlock[, shared_size])
dim_part = 'dim' '('  assignment_expression ,  assignment_expression ,  
            [ , assignment_expression ]  ')'

\end{verbatim}
The example grammar allows a list of expressions inside a pragma. 
A tricky part here is that C allows single comma expression like ((exp1,exp2),exp3).
We use  assignment\_expression  to avoid parsing exp1, exp2, exp3 to be one such single comma  expression. 
The point here is that the terms in the grammar have to be accurately mapped to formal C grammar terms.  
Some familiarity of formal C grammar terms, as shown at \url{http://www.antlr.org/grammar/1153358328744/C.g}, is required since helper functions have names matching the formal terms in C grammar. 
The assignment expressions, not expressions,  are what we care about in this particular simple grammar. 

\section{AstAttribute to Store results}
Once the grammar is defined with terms matching helper functions of AstFromString, a data structure is needed to store the results of parsing. 
It is recommended to create your data structure by inheriting \lstinline{AstAttribute}, which can be attached to any AST nodes with location information.

As in the pragmaParsing project, we define a few classes as the following:

\begin{verbatim}
class HC_PragmaAttribute: public AstAttribute
{
    public:
        SgNode * node;
            enum hcpragma_enum pragma_type;
... };

class HC_CUDA_PragmaAttribute: public  HC_PragmaAttribute
{
  public:
    SgExpression* place_exp;
...
};
class HC_CUDA_autodim_PragmaAttribute: public HC_CUDA_PragmaAttribute
{
  public:
    SgExpression* dim1_exp;
    SgExpression* dim2_exp;
    SgExpression* dim3_exp;
    SgExpression* shared_size_exp;
...
};
            
\end{verbatim}
The point is that the class is inherited from AstAttribute and it contains fields to store all terms defined in the grammar. 

\section{The AstFromString Namespace}
AstFromString has a few namespace scope variables, such as:
\begin{itemize}
\item \lstinline{char * c_char}: this indicates the current position of the input string being parsed.
\item \lstinline{SgNode* c_sgnode}: a SgNode variable storing the current anchor AST node, which servers as a start point to find enclosing scopes for resolving identifiers/symbols discovered by a parser. 
\item \lstinline{SgNode *   c_parsed_node}: a SgNode variable storing the root of an AST subtree generated by the parser.
\end{itemize}

In general, your parser should initialize \lstinline{c_char} with the first position of an input string to be parsed. 
It should also set \lstinline{c_sgnode} to be the pragma statement  when you parse pragma strings,  or the immediate following statement when you parse Fortran comments. 
The results often are stored in \lstinline{c_parsed_node}. Your parser should timely check the results and filling your AstAttribute structure with the AST substrees for identifiers, constants, expressions, etc.

Helper functions within AstFromString include functions to parse identifiers, types, substrings, expressions. AST pieces will be generated automatically as needed. So users can focus on building their grammar and parser without doing repetitive chores of parsing common language constructs. 

Take \lstinline{bool  afs_match_assignment_expression()} as an example, this function will try to match an expression that satisfies a grammar rule like: \\
\lstinline{assignment_expression : lvalue assignment_operator assignment_expression | conditional_expression  }. If a successful match is found, the function returns true.
In the meantime, the function builds an AST subtree to represent the matched expression and stores the subtree into the variable \lstinline{SgNode* c_sgnode}.  

\section{Write your parsers using parser building blocks}
\textit{rose/src/frontend/SageIII/astFromString/AstFromString.cpp} has the implementation of all parser building blocks (helper functions) for a wide range of grammar rules. 
They can serve as examples about how to hand-write additional functions to recognize your own grammars. 
For example, to implement a simple grammar rule like \lstinline{type_qualifier  : 'const'   | 'volatile'}, we have the following helper function:
\begin{verbatim}
 /*
     type_qualifier
     : 'const'
     | 'volatile'
     ;

*/
  bool afs_match_type_qualifier()
  {
    bool result = false;
    const char* old_char = c_char;
    if (afs_match_substr("const"))
    {
      c_parsed_node = buildConstVolatileModifier (SgConstVolatileModifier::e_const);
      result = true;
    }
    else if (afs_match_substr("volatile"))
    {
      c_parsed_node = buildConstVolatileModifier (SgConstVolatileModifier::e_volatile);
      result = true;
    }
    if (result == false)   c_char = old_char;
    return result;
  }
\end{verbatim}
Please note that the function above tries to undo any side effects if the parsing fails. If successful, the parsed result will be stored into \lstinline{c_parsed_node}.

Here is another example with right recursion:
\begin{verbatim}
/* Grammar is
     cast_expression
     : '(' type_name ')' cast_expression
     | unary_expression
     ;

*/
  bool afs_match_cast_expression()
  {
    bool result = false;
    const char* old_char = c_char;

    if (afs_match_unary_expression())
    {
      if (isSgExpression(c_parsed_node))
      result = true;
    }
    else if (afs_match_char('('))
    {
      if (afs_match_type_name())
      {
        SgType* t = isSgType(c_parsed_node);
        assert (t!= NULL);
        if (afs_match_char(')'))
        {
          if (afs_match_cast_expression())
          {
            SgExpression* operand = isSgExpression(c_parsed_node);
            c_parsed_node = buildCastExp(operand, t);
            result = true; // must set this!!
          }
          else
          {
            c_char = old_char;
          }
        }
        else
        {
          c_char = old_char;
        }

      }
      else
      {
        c_char = old_char;
        result = false;
      }
    }

    if (result == false)   c_char = old_char;
    return result;
  }

\end{verbatim}



\textit{sourcetree/projects/pragmaParsing/hcpragma.C} gives a full example of how to use helper functions inside your own parsing functions.

\section{Limitations}
Currently, the parser building blocks support C only. Expressions parsing functions are ready to be used by users. 
Statement parsing is still ongoing work. 



