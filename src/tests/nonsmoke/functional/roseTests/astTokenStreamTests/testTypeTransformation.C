#include "rose.h"

class TypeTransformation : public SgSimpleProcessing
   {
     public:
          void visit ( SgNode* astNode );
   };

void
TypeTransformation::visit ( SgNode* astNode )
   {
     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(astNode);
     if (variableDeclaration != NULL)
        {
#if 0
       // One way to know where you are when your doing a transformation (debugging).
          printf ("Found a variable decaration: \n");
          variableDeclaration->get_file_info()->display("Found a variable decaration");
#endif
          SgInitializedNamePtrList & varList = variableDeclaration->get_variables();
          SgInitializedNamePtrList::iterator i = varList.begin();

          bool transformed = false;

       // Iterate over the SgInitializedName objects.
          while (i != varList.end())
             {
               SgPointerType* pointerType = isSgPointerType((*i)->get_type());
               if (pointerType != NULL)
                  {
                 // Types are shared, so don't modify the types directly, but point to a new type.
                    (*i)->set_type(SageBuilder::buildRestrictType((*i)->get_type()));
#if 1
                    printf ("In TypeTransformation::visit(): Calling setTransformation on SgInitializedName: i = %p = %s \n",*i,(*i)->get_name().str());
#endif
                 // DQ (4/14/2015): Explicitly set this as containing a transformation (we might want 
                 // to alternatively fixup the token-based unparsing frontier tests to triggered based 
                 // on the setting of the isModified flag in each IR node.
                 // (*i)->set_containsTransformation(true);
                 // (*i)->setTransformation();

                    transformed = true;
                  }

               i++;
             }

          if (transformed == true)
             {
#if 0
            // DQ (4/16/2015): That this can be commented out means that we have general support in place to 
            // interpret transformations from status of the isModified flags that are set by all of the 
            // set_* access functions.  This interpretation of the isModified flag status to explicitly
            // mark transformations is handled in the function:
            // SimpleFrontierDetectionForTokenStreamMapping::evaluateInheritedAttribute()
            // in file: simpleFrontierDetection.C

            // DQ (4/14/2015): Mark the SgVariableDeclaration as being a transformation.
               variableDeclaration->setTransformation();

            // Also set to be output in the generated code.
               variableDeclaration->setOutputInCodeGeneration();

            // By definition: for this to be a transformation it cannot also contain a transforamtion.
               ROSE_ASSERT(variableDeclaration->get_containsTransformation() == false);
               ROSE_ASSERT(variableDeclaration->isTransformation() == true);
#endif
             }
        }
   }


int
main ( int argc, char* argv[] )
   {
  // This builds the AST.
     SgProject* project = frontend(argc,argv);
     ROSE_ASSERT (project != NULL);

#if 1
  // Put translators here!
     TypeTransformation treeTraversal;
     treeTraversal.traverseInputFiles ( project, preorder );
#endif

  // SgProject::set_verbose(3);

#if 1
  // AST consistency tests (optional for users, but this enforces more of our AST consistancy tests)
     AstTests::runAllTests(project);
#endif

  // SgProject::set_verbose(0);
  // int status = backend(project);

#if 1
  // DQ (11/20/2013): Test using support for multiple files for Java testing.
  // Output an optional graph of the AST (just the tree, when active)
  // generateDOT ( *project );
     generateDOTforMultipleFile(*project);

  // Output an optional graph of the AST (the whole graph, of bounded complexity, when active)
     const int MAX_NUMBER_OF_IR_NODES_TO_GRAPH_FOR_WHOLE_GRAPH = 10000;
     generateAstGraph(project,MAX_NUMBER_OF_IR_NODES_TO_GRAPH_FOR_WHOLE_GRAPH,"");
#endif

  // This calls the unparse and the backend compiler on the source code generated by the unparser.
     return backend(project);
  // return status;
   }

