

	module support
	contains
	subroutine reduce_max(in1, in2, out, nbytes)
	integer :: nbytes
	double precision :: in1, in2, out
	out = max(in1, in2)
	end subroutine

        subroutine reduce_sum(in1, in2, out, nbytes)
        integer :: nbytes
        double precision :: in1(nbytes/8), in2(nbytes/8), out(nbytes/8)
        out = in1 + in2
        end subroutine

!	use user-defined type 
	subroutine select_max(in1, in2, out, nbytes)
	integer :: nbytes
	double precision :: in1(nbytes/8), in2(nbytes/8), out(nbytes/8)
	if ((nbytes .eq. 8 .and. abs(in1(1)) .lt. abs(in2(1))) .or. &
            (nbytes .eq. 64 .and. (abs(in1(5)) .lt. abs(in2(5)) .or. &
              (abs(in1(5)) .eq. abs(in2(5)) .and. in1(7) .lt. in2(7))))) then
	  out = in2 
	else 
	  out = in1
	end if
	end subroutine


!       compute a local portion of the array from global index i (0 based)
	function localsize(n, i, blksize, nprocs, myproc) result(mypart)
	integer :: n, i, blksize, nprocs, myproc, numblks, locblks, mydist
	integer :: inb, srcproc, inbs, mypart
	inb = i / blksize		
	srcproc = inb - (inb / nprocs) * nprocs
	inbs = blksize - (i - inb * blksize)
	numblks = (n - inbs) / blksize + 1
	locblks = numblks / nprocs

	if (myproc .eq. srcproc) then
	  mypart = n
	  if (n .gt. inbs) then 
	    if (numblks .ne. locblks * nprocs) mypart = inbs + locblks * blksize
	    if (numblks .eq. locblks * nprocs) mypart = n + (locblks - numblks) * blksize
	  end if	   
	else 
	  mypart = 0
	  if (n .gt. inbs) then 
	    mydist = myproc - srcproc
	    if (mydist .lt. 0) mydist = mydist + nprocs 
	    if (numblks .lt. nprocs) then
	      if (mydist .lt. numblks) mypart = blksize
	      if (mydist .eq. numblks) mypart = n - inbs + blksize * (1 - numblks)   
	    else 
	      mydist = mydist - numblks + locblks * nprocs
	      mypart = locblks * blksize
	      if (mydist .lt. 0) mypart = mypart + blksize
	      if (mydist .eq. 0) mypart = mypart + n -inbs - numblks * blksize + blksize
	    end if
	  end if
	end if
	end function localsize

	end module


	module HPLmod
	integer, parameter :: PROBLEMSIZE = 16, NUMPANELS = 2
	integer, parameter :: BLKSIZE = 4, NPCOL = 2, NPROW = 2
	double precision, parameter :: EPSILON = 2.0e-16, THRESHOLD = 16.0
	integer :: nprocs, rowp2, rowlog2, me, mycol, myrow
	team :: rteam, cteam, subcteam
	
	! panelinfo: i, j, iloc, jloc, mloc, nloc, rproc, cproc, permute
	integer, target, allocatable :: panelinfo_1(:)[*]
	integer, target, allocatable :: panelinfo_2(:)[*]
	double precision, target, allocatable :: panelbuff_1(:)[*]
	double precision, target, allocatable :: panelbuff_2(:)[*]
	double precision, target, allocatable :: ab(:,:)[*]
	double precision, allocatable :: x(:)[*]
	integer :: isz1 = 0, isz2 = 0, bsz1 = 0, bsz2 = 0

	contains
	subroutine dump_ab(m,n)
	double precision, pointer :: a(:,:)
	double precision, pointer :: b(:)
	character(len=1) strme
	character(len=18) filename
        a => ab(1:m,1:n)
        b => ab(1:m,n+1)
	write(strme, '(i1)') me
	filename = 'out.ab.aftersol.p' // strme
	open (unit = 8, file = filename)
	write(8,*) "--- a ---"
	do i = 1, m
	  write(8,*) a(i,1:n)
	end do 	
	write(8,*) "--- b ---"
	write(8,*) b(1:m)
	close(unit = 8)
	end subroutine
	
	subroutine dump_x(n)
	character(len=1) strme
	character(len=17) filename
	write(strme, '(i1)') me
	filename = 'out.x.afsol.p' // strme
	open (unit = 8, file = filename)
	write(8,*) "--- x ---"
	write(8,*) x(1:n)
	close(unit = 8)
	end subroutine

	subroutine dump_panel(p)
	integer :: p, mloc, nloc
	character(len=1) strme
	character(len=21) filename
	integer, pointer :: panelinfo(:)
	double precision, pointer, DIMENSION(:) :: panelbuff, l, c, piv, u
	if (p .eq. 1) then
	  panelinfo => panelinfo_1(1:isz1)
	  panelbuff => panelbuff_1(1:bsz1)
	else 
	  panelinfo => panelinfo_2(1:isz2)
	  panelbuff => panelbuff_2(1:bsz2)
	end if
	mloc = panelinfo(5)
	nloc = panelinfo(6)
	l => panelbuff(1:mloc*BLKSIZE)
	c => panelbuff(mloc*BLKSIZE+1:(mloc+BLKSIZE)*BLKSIZE)
	piv => panelbuff((mloc+BLKSIZE)*BLKSIZE+1:(mloc+BLKSIZE+1)*BLKSIZE)
	u => panelbuff((mloc+BLKSIZE+1)*BLKSIZE+1:(mloc+nloc+BLKSIZE+1)*BLKSIZE)
	write(strme, '(i1)') me
	filename = 'out.panel.afterlup.p' // strme  
	open (unit = 8, file = filename)

	write(8,*) "--- l ---"
	do i = 1, mloc
	  write(8,*) l(i::mloc)
	end do

	write(8,*) "--- c ---"
	do i = 1, BLKSIZE
	  write(8,*) c(i::BLKSIZE)
	end do

	write(8,*) "-- piv --"
	write(8,*) piv

	write(8,*) "-- u --"
	do i = 1, BLKSIZE
	  write(8,*) u(i::BLKSIZE)
	end do

	close(unit = 8)
	end subroutine

	end module HPLmod

!       use currpanel to update numcol columns of the trailing matrix of a
	subroutine update(m, n, coldiff, numcol, p)
	use HPLmod
	use support
	implicit none
	integer :: m, n, coldiff, numcol, lb, ub, pos, ierr, k, jlb, mykey, iu, ipiv, nn, lb_p
	double precision, pointer :: panelbuff(:)
	double precision, pointer, DIMENSION(:,:) :: a
	double precision, pointer, DIMENSION(:) :: c, piv, l, u
	integer, pointer, DIMENSION(:) :: pairs, aloc,uloc,len1,len2, permute, panelinfo
	integer, pointer :: flag, numpairs
	double precision, allocatable :: w(:,:)[*]
	integer, allocatable :: wptr(:)[*]
	integer :: p, mloc, nloc, iloc, jloc, mloc_p
	integer :: i, j, ii, src, dst, fnds, fndd, rproc, srcprow, dstprow 
	integer :: srcloc, dstloc, wrows, wlb, numrows, mydist, partner, lessip2
	if (p .eq. 1) then
	  panelinfo => panelinfo_1(1:isz1)
	  panelbuff => panelbuff_1(1:bsz1)
	else
	  panelinfo => panelinfo_2(1:isz2)
	  panelbuff => panelbuff_2(1:bsz2)
	end if
	iloc = panelinfo(3)
	jloc = panelinfo(4)
	mloc = panelinfo(5)
	nloc = panelinfo(6)
	rproc = panelinfo(7)
	a => ab(1:m,1:n)
	l => panelbuff(1:mloc*BLKSIZE)
	c => panelbuff(mloc*BLKSIZE+1:(mloc+BLKSIZE)*BLKSIZE)
	piv => panelbuff((mloc+BLKSIZE)*BLKSIZE+1:(mloc+BLKSIZE+1)*BLKSIZE)
	u => panelbuff((mloc+BLKSIZE+1)*BLKSIZE+1:(mloc+nloc+BLKSIZE+1)*BLKSIZE)
	permute => panelinfo(9:8*BLKSIZE+2*NPROW+10)
	nn = min(numcol, PROBLEMSIZE - panelinfo(2))
	allocate(w(nn+1, BLKSIZE)[@cteam])
	allocate(wptr(1)[@cteam])
	flag => permute(1)
	numpairs => permute(2) 
	pairs => permute(3:4*BLKSIZE+2)
	aloc => permute(4*BLKSIZE+3:6*BLKSIZE+2)
	uloc => permute(6*BLKSIZE+3:8*BLKSIZE+2)
	len1 => permute(8*BLKSIZE+3:8*BLKSIZE+NPROW+2)
	len2 => permute(8*BLKSIZE+NPROW+3:8*BLKSIZE+2*NPROW+2)
	
!       compute row permutation from pivot information
	if (flag .eq. 0) then
	  ipiv = piv(1)
	  pairs(1:2) = (/ipiv, panelinfo(1)/)
	  numpairs = 1
	  if (ipiv .ne. panelinfo(1)) then
	    pairs(3:4) = (/panelinfo(1), ipiv/)
	    numpairs = 2
	  end if
	  do i = 2, BLKSIZE
	    src = panelinfo(1) + i - 1
	    dst = piv(i)
	    fnds = 0
	    fndd = 0
	    do j = 1, numpairs 
	      if (fnds .eq. 0 .or. src .ne. dst .and. fndd .eq. 0) then
	        if (src .eq. pairs((j-1)*2+2)) fnds = j
	        if (src .ne. dst .and. dst .eq. pairs((j-1)*2+2)) fndd = j
	      end if
	    end do
	  
	    if (fnds .eq. 0) then 
	      pairs(numpairs*2+1:numpairs*2+2) = (/src, dst/)
	      numpairs = numpairs + 1
	      pos = numpairs
	    else
	      pairs((fnds-1)*2+2) = dst
	      pos = fnds
	    end if
	  
	    if (src .ne. dst) then
	      if (fndd .eq. 0) then
	        pairs(numpairs*2+1:numpairs*2+2) = (/dst, src/)
	        numpairs = numpairs + 1
	        pos = numpairs
	      else
	        pairs((fndd-1)*2+2) = src
	        pos = fndd
	      end if
	    end if
	    if (i .ne. pos) then
	      src = pairs((i-1)*2+1)
	      dst = pairs((i-1)*2+2)
	      pairs((i-1)*2+1:(i-1)*2+2) = pairs((pos-1)*2+1:(pos-1)*2+2)
	      pairs((pos-1)*2+1:(pos-1)*2+2) = (/src, dst/)
	    end if
	  end do
	
!         compute the locations in a and u where rows should be placed
	  ii = 1
	  len2 = 0
	  do i = 1, numpairs
	    src = pairs((i-1)*2+1)
	    srcprow = (src - 1) / BLKSIZE
	    srcprow = mod(srcprow, NPROW)
	    len2(srcprow+1) = len2(srcprow+1) + 1    !   1-based, procid also 1-based
	    if (myrow .eq. srcprow) then
	      srcloc = localsize(src, 0, BLKSIZE, NPROW, myrow)
	      aloc(ii) = srcloc - iloc
	      dst = pairs((i-1)*2+2)
	      if (myrow .eq. rproc) then
	        dstprow = (dst - 1) / BLKSIZE
	        dstprow = mod(dstprow, NPROW)
	        if (dstprow .eq. rproc) then
		  uloc(ii) = dst - panelinfo(1)
		  if (dst - panelinfo(1) .ge. BLKSIZE) then
		    dstloc = localsize(dst, 0, BLKSIZE, NPROW, myrow)
		    uloc(ii) = iloc - dstloc
		  end if
	        else
		  fndd = 0
		  do j = 1, numpairs
		    if (fndd .eq. 0 .and. dst .eq. pairs((j-1)*2+1)) fndd = j
		  end do
		  uloc(ii) = pairs((fndd-1)*2+2) - panelinfo(1)
	        end if
	      else 
	        uloc(ii) = dst - panelinfo(1)
	      end if
	      ii = ii + 1
	    end if
	  end do
	  flag = 1
	end if
	
!       permute rows and broadcast u
	w = 0
	numrows = len2(myrow+1)
	len1(:) = len2(:)
	if (myrow .eq. rproc) then
	  do i = 1, numrows
	    if (uloc(i) .ge. 0) then
	      u(uloc(i)+1:uloc(i)+(nn-1)*BLKSIZE+1:BLKSIZE) = a(aloc(i)+iloc,jloc+coldiff:jloc+coldiff+nn-1)
	    end if
	    if (uloc(i) .lt. 0) then
	      a((-uloc(i))+iloc,jloc+coldiff:jloc+coldiff+nn-1) = a(aloc(i)+iloc,jloc+coldiff:jloc+coldiff+nn-1)
	    end if
	  end do
	else 
	  w(1,1:numrows) = uloc(1:numrows)
	  do i = 1, numrows
	    w(2:,i) = a(aloc(i)+iloc, jloc+coldiff:jloc+coldiff+nn-1)
	  end do
	end if
	if (myrow .eq. rproc) then
	   len1(myrow+1) = 0
	   numrows = 0
	end if

	wptr(1) = numrows
	mydist = myrow - rproc
	if (mydist < 0) mydist = mydist + NPROW
	partner = ieor(mydist, rowp2)
	call barrier(cteam)
	if (NPROW - rowp2 .ne. 0 .and. partner .lt. NPROW) then
	  partner = mod(partner + rproc, NPROW)
	  if (mydist .eq. 0) then 
	    lb = (mloc+BLKSIZE+1)*BLKSIZE+1
	    ub = (mloc+nloc+BLKSIZE+1)*BLKSIZE
	    if (p .eq. 1) then
	      mloc_p = panelinfo_1(5)[partner@cteam]
	      lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1 
	      panelbuff_1(lb_p : lb_p+ub-lb)[partner@cteam] = panelbuff_1(lb : ub)
	    else
	      mloc_p = panelinfo_2(5)[partner@cteam]
	      lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1 
	      panelbuff_2(lb_p : lb_p+ub-lb)[partner@cteam] = panelbuff_2(lb : ub)
	    end if
	  else if (mydist .eq. rowp2) then
	    w(:, 1 : len1(myrow+1))[partner@cteam] = w(:, 1 : len1(myrow+1))
	  else if (iand(mydist, rowp2) .ne. 0) then
	    wlb = wptr(1)[partner@cteam]
	    w(:, wlb+1 : wlb+len1(myrow+1))[partner@cteam] = w(:, 1 : len1(myrow+1))
	  else if (len1(partner+1) .gt. 0) then
	    wptr(1) = wptr(1) + len1(partner+1)
	  end if
	end if

	call barrier(cteam)

	partner = ieor(mydist, rowp2)
	if (NPROW - rowp2 .ne. 0 .and. partner .lt. NPROW) then
	  partner = mod(partner + rproc, NPROW)
	  if (mydist .eq. 0 .and. len1(partner+1) .gt. 0) then
	    do i = 1, len1(partner+1)
	       iu = w(1,i) + 1  ! w(1,i) is 0-based
	       u(iu:iu+(nn-1)*BLKSIZE:BLKSIZE) = w(2:nn+1,i)
	    end do
	  end if
	end if

	do i = 1, NPROW-rowp2-1
	  lessip2 = mod(rproc+i, NPROW)
	  len1(lessip2+1) = len1(lessip2+1) + len1(mod(lessip2+rowp2, NPROW)+1)
	end do
	
	mykey = 0
	wrows = wptr(1)
	if (mydist .lt. rowp2) mykey = 1
	if (mydist .ge. rowp2 .and. NPROW - rowp2 .ne. 0) mykey = 2
	call team_split(cteam, mykey, myrow, subcteam, mykey, ierr)

	if (mydist .lt. rowp2) then
	  do i = 1, rowlog2
	    partner = ieor(mydist, ibset(0, i-1))
	    partner = mod(rproc + partner, NPROW)
	    if (mydist .lt. ibset(0, i) .and. mydist .lt. ibset(0, i-1)) then
	      lb = (mloc+BLKSIZE+1)*BLKSIZE+1
	      ub = (mloc+nloc+BLKSIZE+1)*BLKSIZE
	      if (p .eq. 1) then
	        mloc_p = panelinfo_1(5)[partner@subcteam]
	        lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1
	        panelbuff_1(lb_p : lb_p+ub-lb)[partner@subcteam] = panelbuff_1(lb : ub)
	      else
	        mloc_p = panelinfo_2(5)[partner@subcteam]
	        lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1
	        panelbuff_2(lb_p : lb_p+ub-lb)[partner@subcteam] = panelbuff_2(lb : ub)
	      end if
	      w(:,wrows+1:wrows+len1(partner+1)) = w(:,1:len1(partner+1))[partner@subcteam]
	    else if (mydist .ge. ibset(0, i)) then
	      w(:,wrows+1:wrows+len1(partner+1)) = w(:,1:len1(partner+1))[partner@subcteam]
	    end if
	    call barrier(subcteam) 
	    if (mydist .lt. ibset(0, i) .and. mydist .lt. ibset(0, i-1)) then
	       do j = 1, len1(partner+1)
		  iu = w(1,wrows+j) + 1  ! w(1,i) is 0-based
		  u(iu::BLKSIZE) = w(2:,wrows+j)
	       end do
	    end if
	    if (mydist .lt. ibset(0, i) .and. mydist .ge. ibset(0, i-1)) then
	       do j = 1, numrows
		  a(aloc(j)+iloc, jloc+coldiff:jloc+coldiff+nn-1) = u(uloc(j)+1:uloc(j)+1+(nn-1)*BLKSIZE:BLKSIZE)
		  u(uloc(j)+1:uloc(j)+1+(nn-1)*BLKSIZE:BLKSIZE) = w(2:, j)
	       end do
	       do j = numrows + 1, len1(myrow+1) 
	          iu = w(1,j) + 1
		  u(iu:iu+(nn-1)*BLKSIZE:BLKSIZE) = w(2:, j)
	       end do
	    end if
	    if (mydist .ge. ibset(0, i) .or. mydist .lt. ibset(0, i-1)) then
	       wrows = wrows + len1(partner+1)
	    end if
	    do j = 0, rowp2 - 1
	       partner = ieor(j,ibset(0,i-1))
	       if (partner .gt. j) then
		  partner = mod(rproc + partner, NPROW)
		  len1(mod(rproc+j,NPROW)+1) = len1(mod(rproc+j,NPROW)+1) + len1(partner+1)
		  len1(partner+1) = len1(mod(rproc+j,NPROW)+1)
	       end if
	    end do
	  end do
	else if (NPROW - rowp2 .gt. 1) then
	  call team_broadcast(u, 0, subcteam)
	  do i = 1, numrows
	    a(aloc(i)+iloc,jloc+coldiff:) = u(uloc(i)+1::BLKSIZE)
	  end do
	end if
	if (NPROW - rowp2 .ne. 0 .and. ieor(mydist, rowp2) .lt. NPROW) then
	  partner = mod(rproc + ieor(mydist, rowp2), NPROW)
	  if (iand(mydist, rowp2) .eq. 0) then
	    lb = (mloc+BLKSIZE+1)*BLKSIZE+1
	    ub = (mloc+nloc+BLKSIZE+1)*BLKSIZE
	    if (p .eq. 1) then
	      mloc_p = panelinfo_1(5)[partner@cteam]
	      lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1
	      panelbuff_1(lb_p : lb_p+ub-lb)[partner@cteam] = panelbuff_1(lb : ub)
	    else 
	      mloc_p = panelinfo_2(5)[partner@cteam]
	      lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1
	      panelbuff_2(lb_p : lb_p+ub-lb)[partner@cteam] = panelbuff_2(lb : ub)
	    end if
	  end if
	end if
	deallocate(wptr)
	deallocate(w)
	
!       update the trailing matrix by matrix multiplication
	do i = 1, nn
	  do j = 1, BLKSIZE
	      u((i-1)*BLKSIZE+j+1:i*BLKSIZE) = u((i-1)*BLKSIZE+j+1:i*BLKSIZE) &
	                - u((i-1)*BLKSIZE+j) * c((j-1)*BLKSIZE+j+1:j*BLKSIZE)
	  end do
	end do
	if (myrow .eq. rproc) then
	  do k = 1, BLKSIZE
	    do j = jloc, jloc + nn - 1
	       do i = iloc+BLKSIZE, iloc + mloc - 1
	         a(i, j+coldiff) = a(i, j+coldiff) - l((k-1)*mloc+i-iloc+1) * u((j-jloc)*BLKSIZE+k)
	       end do
	    end do
	  end do
	  jlb = jloc
	  do j = jlb, jloc + nn - 1
	    a(iloc:iloc+BLKSIZE-1,j+coldiff) = u((j-jlb)*BLKSIZE+1:(j-jlb+1)*BLKSIZE)
	  end do
	else 
	  do k = 1, BLKSIZE
	    do j = jloc, jloc + nn - 1
	      do i = iloc, iloc + mloc - 1 
	         a(i, j+coldiff) = a(i, j+coldiff) - l((k-1)*mloc+i-iloc+1) * u((j-jloc)*BLKSIZE+k)
	      end do
	    end do
	  end do
	end if
	
	end subroutine update
	program HPL
	use support
	use HPLmod

	integer :: m, n, i, k
	integer, allocatable :: seed(:)
	double precision :: start_time, end_time, cputime, gflops	
	double precision :: normA, normx, resid, norm_r, norm_c
	double precision, allocatable :: normb(:)[*]
	double precision, pointer :: a(:,:)
	double precision, pointer :: b(:)

!       compute my location in a 2D processor grid
	nprocs = team_size(team_world)
	me = team_rank(team_world)	
	mycol = me / NPROW       
	myrow = me - mycol * NPROW
	if (me .eq. 0) then
	  if (nprocs .ne. NPCOL * NPROW) then
	    print *, 'execution needs ', NPCOL * NPROW, 'processors'
	  end if
	end if
	
	i = NPROW
	rowp2 = 1
	rowlog2 = 0
	do while (i .gt. 1)
	   i = i / 2
	   rowp2 = rowp2 * 2
	   rowlog2 = rowlog2 + 1
	end do

!       compute my part of the matrix and allocate
	m = localsize(PROBLEMSIZE, 0, BLKSIZE, NPROW, myrow)
	n = localsize(PROBLEMSIZE, 0, BLKSIZE, NPCOL, mycol)

	allocate(ab(m,n+1)[@team_world])
	a => ab(1:m,1:n)
	b => ab(1:m,n+1)	
	allocate(x(n)[@team_world])

	call team_split(team_world, myrow, mycol, rteam, myrow, ierr)
	call team_split(team_world, mycol, myrow, cteam, mycol, ierr)

	call random_seed(size = k)
	allocate(seed(k))
	call random_seed(get = seed)
	call init(m, n)
	
!       collect time for the main body of work
	call cpu_time(start_time)
	call lup(m, n)
	call backsolve(m, n)
	call barrier(team_world)
	call cpu_time(end_time)
	cputime = end_time - start_time

	gflops = (2.0/3.0*PROBLEMSIZE + 1.5) * (PROBLEMSIZE/1.0e9) * (PROBLEMSIZE/cputime) 
	if (me .eq. 0) then
	  print *,'size,nprocs,time,gflops:',PROBLEMSIZE,',',nprocs,',',cputime,',',gflops
	end if

!       verify results
	call random_seed(put = seed)
	call init(m,n)
	normA = norm_r(a,m,n)
	normx = norm_c(x,n)
	allocate(normb(1)[@team_world])
	if (mycol .eq. mod(PROBLEMSIZE/BLKSIZE, NPCOL)) then
	  normb(1) = maxval(abs(b)) 
	  call team_reduce(normb, normb, 0, REDUCE_MAX, cteam)
	  b = b - matmul(a,x)
	else
	  b = - matmul(a,x)
	end if
	call team_broadcast(normb, 0, team_world)
	call team_reduce(b(1:m), b(1:m), 0, REDUCE_SUM, rteam)
	resid = norm_r(b,m,1)
	resid = resid / (epsilon * (normA * normx + normb(1)) * PROBLEMSIZE)
	if (me .eq. 0 .and. resid .lt. THRESHOLD) print *, "result VALID. scaled residual: ", resid
	if (me .eq. 0 .and. resid .ge. THRESHOLD) print *, "result INVALID. scaled residual: ", resid
	
	deallocate(ab,x,seed,normb)
	end program HPL

	function norm_r(a,s,t) result(r)
	use support
	use HPLmod
	integer :: s,t
	double precision :: r, a(s,t)
	double precision, allocatable :: w(:)[*], nval(:)[*]
	allocate (w(s)[@team_world], nval(1)[@team_world])
	w = sum(abs(a),dim=2)
	if (t .gt. 1) call team_reduce(w(1:s), w(1:s), 0, REDUCE_SUM, rteam)
	if (mycol .eq. 0) then
	  nval(1) = maxval(w)
	  call team_select(nval, nval, 0, SELECT_MAX, cteam)
	end if
	call team_broadcast(nval, 0, team_world)
	r = nval(1)
	deallocate(w, nval)
	end function norm_r

	function norm_c(v,n) result(r)
	use support
	use HPLmod
	double precision :: r
	double precision :: v(n), w(n)
	double precision, allocatable :: nval(:)[*]
	allocate (nval(1)[@team_world])
	w = abs(v)
	nval(1) = maxval(w)
	call team_select(nval, nval, 0, SELECT_MAX, rteam)	
	call team_broadcast(nval, 0, team_world)
	r = nval(1)
	deallocate(nval)
	end function norm_c
!       perform factorization of a panel 
	subroutine fact(m, n, p)
	use support
	use HPLmod
	integer :: m, n, pivltmp(1)
	integer, pointer :: panelinfo(:)
	double precision, pointer :: panelbuff(:)
	double precision, pointer, DIMENSION(:,:) :: a
	double precision, pointer, DIMENSION(:) :: b, c, piv, l
	integer :: p, clb, rlb, rub, rproc, pivl, pivg, pivproc, mloc
	double precision, allocatable :: w(:)[*]
	allocate(w(2*BLKSIZE+4)[@cteam])

	if (p .eq. 1) then
	  panelinfo => panelinfo_1(1:isz1)
	  panelbuff => panelbuff_1(1:bsz1)
	else
	  panelinfo => panelinfo_2(1:isz2)
	  panelbuff => panelbuff_2(1:bsz2)
	end if
	mloc = panelinfo(5)
	a => ab(1:m,1:n)
	b => ab(1:m,n+1)	
	l => panelbuff(1:mloc*BLKSIZE)
	c => panelbuff(mloc*BLKSIZE+1:(mloc+BLKSIZE)*BLKSIZE)
	piv => panelbuff((mloc+BLKSIZE)*BLKSIZE+1:(mloc+BLKSIZE+1)*BLKSIZE) 
	clb = panelinfo(4)
	rlb = panelinfo(3)
	rub = rlb + mloc - 1
	rproc = panelinfo(7)
	do i = 1, BLKSIZE
!         compute pivots, switch rows, and update the panel
	  w(1:BLKSIZE+3) = 0.0
	  w(BLKSIZE+4) = nprow
	  if (rub .ge. rlb) then
	    pivltmp = maxloc(abs(a(rlb:rub,clb+i-1)))
	    pivl = pivltmp(1)                    !  1-based
	    pivg = pivl + rlb - 2                !  0-based
	    pivg = pivg + BLKSIZE * ((NPROW - 1) * (pivg / BLKSIZE) + myrow) + 1   !  1-based
	    w(BLKSIZE+1) = a(rlb+pivl-1,clb+i-1)
	    w(BLKSIZE+2:BLKSIZE+4) = (/pivl, pivg, myrow/)
	    w(1:BLKSIZE) = a(rlb+pivl-1, clb:clb+BLKSIZE-1)
	  end if
	  call team_allselect(w(1:BLKSIZE+4), w(1:BLKSIZE+4), SELECT_MAX, cteam)
	  piv(i) = w(BLKSIZE+3)
	  
	  pivl = w(BLKSIZE+2)
	  pivproc = w(BLKSIZE+4)
	  if (myrow .eq. rproc .and. myrow .ne. pivproc) then
	    w(BLKSIZE+5:2*BLKSIZE+4)[pivproc@cteam] = a(rlb,clb:clb+BLKSIZE-1)
	  end if 
	  call barrier(cteam)
	  
	  c(i::BLKSIZE) = w(1:BLKSIZE)
	  if (myrow .eq. rproc) then
	    if (myrow .ne. pivproc) then
	      a(rlb, clb:clb+BLKSIZE-1) = w(1:BLKSIZE)
	    else if (myrow .eq. pivproc .and. pivl .ne. 1) then
	      a(pivl+rlb-1, clb:clb+BLKSIZE-1) = a(rlb,clb:clb+BLKSIZE-1)
	      a(rlb, clb:clb+BLKSIZE-1) = w(1:BLKSIZE)
	    end if
	  else if (myrow .eq. pivproc) then
	    a(pivl+rlb-1, clb:clb+BLKSIZE-1) = w(BLKSIZE+5:2*BLKSIZE+4)
	  end if

	  if (myrow .eq. rproc) rlb = rlb + 1
	  a(rlb:rub,clb+i-1) = a(rlb:rub,clb+i-1) / w(BLKSIZE+1)

	  if (i < BLKSIZE) then
	    do j = rlb, rub
	      a(j,clb+i:clb+BLKSIZE-1) = a(j,clb+i:clb+BLKSIZE-1) - a(j,clb+i-1) * w(i+1:BLKSIZE)
	    end do
	  end if

	end do

	rlb = panelinfo(3)
	do i = clb, clb + BLKSIZE - 1
	   l((i-clb)*mloc+1:(i-clb+1)*mloc) = a(rlb:rlb+mloc-1,i)
	end do

	deallocate(w)
	end subroutine fact
	module HPLmod
	integer, parameter :: PROBLEMSIZE = 16, NUMPANELS = 2
	integer, parameter :: BLKSIZE = 4, NPCOL = 2, NPROW = 2
	double precision, parameter :: EPSILON = 2.0e-16, THRESHOLD = 16.0
	integer :: nprocs, rowp2, rowlog2, me, mycol, myrow
	team :: rteam, cteam, subcteam
	
	! panelinfo: i, j, iloc, jloc, mloc, nloc, rproc, cproc, permute
	integer, target, allocatable :: panelinfo_1(:)[*]
	integer, target, allocatable :: panelinfo_2(:)[*]
	double precision, target, allocatable :: panelbuff_1(:)[*]
	double precision, target, allocatable :: panelbuff_2(:)[*]
	double precision, target, allocatable :: ab(:,:)[*]
	double precision, allocatable :: x(:)[*]
	integer :: isz1 = 0, isz2 = 0, bsz1 = 0, bsz2 = 0

	contains
	subroutine dump_ab(m,n)
	double precision, pointer :: a(:,:)
	double precision, pointer :: b(:)
	character(len=1) strme
	character(len=18) filename
        a => ab(1:m,1:n)
        b => ab(1:m,n+1)
	write(strme, '(i1)') me
	filename = 'out.ab.aftersol.p' // strme
	open (unit = 8, file = filename)
	write(8,*) "--- a ---"
	do i = 1, m
	  write(8,*) a(i,1:n)
	end do 	
	write(8,*) "--- b ---"
	write(8,*) b(1:m)
	close(unit = 8)
	end subroutine
	
	subroutine dump_x(n)
	character(len=1) strme
	character(len=17) filename
	write(strme, '(i1)') me
	filename = 'out.x.afsol.p' // strme
	open (unit = 8, file = filename)
	write(8,*) "--- x ---"
	write(8,*) x(1:n)
	close(unit = 8)
	end subroutine

	subroutine dump_panel(p)
	integer :: p, mloc, nloc
	character(len=1) strme
	character(len=21) filename
	integer, pointer :: panelinfo(:)
	double precision, pointer, DIMENSION(:) :: panelbuff, l, c, piv, u
	if (p .eq. 1) then
	  panelinfo => panelinfo_1(1:isz1)
	  panelbuff => panelbuff_1(1:bsz1)
	else 
	  panelinfo => panelinfo_2(1:isz2)
	  panelbuff => panelbuff_2(1:bsz2)
	end if
	mloc = panelinfo(5)
	nloc = panelinfo(6)
	l => panelbuff(1:mloc*BLKSIZE)
	c => panelbuff(mloc*BLKSIZE+1:(mloc+BLKSIZE)*BLKSIZE)
	piv => panelbuff((mloc+BLKSIZE)*BLKSIZE+1:(mloc+BLKSIZE+1)*BLKSIZE)
	u => panelbuff((mloc+BLKSIZE+1)*BLKSIZE+1:(mloc+nloc+BLKSIZE+1)*BLKSIZE)
	write(strme, '(i1)') me
	filename = 'out.panel.afterlup.p' // strme  
	open (unit = 8, file = filename)

	write(8,*) "--- l ---"
	do i = 1, mloc
	  write(8,*) l(i::mloc)
	end do

	write(8,*) "--- c ---"
	do i = 1, BLKSIZE
	  write(8,*) c(i::BLKSIZE)
	end do

	write(8,*) "-- piv --"
	write(8,*) piv

	write(8,*) "-- u --"
	do i = 1, BLKSIZE
	  write(8,*) u(i::BLKSIZE)
	end do

	close(unit = 8)
	end subroutine

	end module HPLmod
	subroutine init(m, n)
	use HPLmod
	integer :: m, n
	do i = 0, 3 - me
	  call random_number(ab)
	end do
	ab = ab * 2.0 - 1.0
	end subroutine init

	subroutine lup(m, n)
	use HPLmod
	use support
	integer :: m, n, nn, p, pp = 0, cp, pproc, cproc, ub, colstart
	nn = localsize(PROBLEMSIZE+1, 0, BLKSIZE, NPCOL, mycol)

!       build panels to fill the panel buffer, factorize and update them
	do p = 1, 2
	  call initpanel(p, pp)
	  if (p .ne. 2) pp = pp + BLKSIZE
	  if (p .eq. 1 .and. mycol .eq. panelinfo_1(8)) nn = nn - BLKSIZE
	end do

	if (mycol .eq. panelinfo_1(8)) call fact(m, n, 1)
	
	mloc = panelinfo_1(5)
	pproc = panelinfo_1(8)
	call team_broadcast(panelbuff_1(1:(mloc+BLKSIZE+1)*BLKSIZE),panelinfo_1(8),rteam)
	
!       factorize rest panels and finish all updates
	cproc = panelinfo_2(8)
        
	do j = pp, PROBLEMSIZE - 1, BLKSIZE

	  cp = j / BLKSIZE + 1
	  cp = mod(cp - 1, 2) + 1
	  if (cp .eq. 1) then
	    deallocate(panelinfo_1, panelbuff_1)
	  else 
	    deallocate(panelinfo_2, panelbuff_2)
	  end if
	  call initpanel(cp, j)
	  numcol = 0
	  colstart = 0

	  if (mycol .eq. cproc) then
	    numcol = localsize(BLKSIZE, j, BLKSIZE, NPCOL, mycol)
	    call update(m, n, 0, numcol, 3 - cp)
	    call fact(m, n, cp)
	    colstart = colstart + BLKSIZE
	  end if 	
	  if (mycol .eq. pproc) then
	    colstart = colstart + BLKSIZE
	  end if
	  call barrier(team_world) 
	  if (cp .eq. 1) then 
	    ub = (panelinfo_1(5)+BLKSIZE+1)*BLKSIZE
	    call team_broadcast(panelbuff_1(1:ub), panelinfo_1(8), rteam)
	  else 
	    ub = (panelinfo_2(5)+BLKSIZE+1)*BLKSIZE
	    call team_broadcast(panelbuff_2(1:ub), panelinfo_2(8), rteam)
	  end if

	  call update(m,n, colstart, nn-numcol, 3 - cp)

	  if (mycol .eq. cproc) nn = nn - BLKSIZE
	  pproc = cproc
	  cproc = mod(cproc+1, NPCOL)

	end do
	
	numcol = localsize(1, PROBLEMSIZE + 1, BLKSIZE, NPCOL, mycol)
	call update(m, n, 0, numcol, cp)
	
	deallocate(panelinfo_1, panelinfo_2, panelbuff_1, panelbuff_2)

	end subroutine lup

!       initialize a panel starting at global index (pp, pp)
	subroutine initpanel(p, pp)
	  use HPLmod
	  use support
	  integer :: p, pp, blk, rproc, cproc, mloc, nloc, iloc, jloc    ! pp is 0-based
	  integer, pointer :: info(:)
	  blk = pp / BLKSIZE
	  rproc = blk - blk / NPROW * NPROW
	  cproc = blk - blk / NPCOL * NPCOL
	  mloc = localsize(PROBLEMSIZE - pp, pp, BLKSIZE, NPROW, myrow)
	  nloc = localsize(PROBLEMSIZE + 1 - pp, pp, BLKSIZE, NPCOL, mycol)
	  if (p .eq. 1) then
	    isz1 = 8 * BLKSIZE + 2 * NPROW + 10
	    bsz1 = (mloc + nloc + BLKSIZE + 1) * BLKSIZE
	    allocate(panelinfo_1(isz1)[@team_world])
	    allocate(panelbuff_1(bsz1)[@team_world])
	    info => panelinfo_1
	  else 
	    isz2 = 8 * BLKSIZE + 2 * NPROW + 10
	    bsz2 = (mloc + nloc + BLKSIZE + 1) * BLKSIZE
	    allocate(panelinfo_2(isz2)[@team_world])
	    allocate(panelbuff_2(bsz2)[@team_world])
	    info => panelinfo_2
	  end if 
	  iloc = localsize(pp, 0, BLKSIZE, NPROW, myrow)
	  jloc = localsize(pp, 0, BLKSIZE, NPCOL, mycol)
	  info(1:9) = (/pp+1, pp+1, iloc+1, jloc+1, mloc, nloc, rproc, cproc, 0/)  ! 0 to 1-based
	end subroutine initpanel
!       solve the upper triangle matrix
	subroutine backsolve(m, n)
	use HPLmod
	use support
	integer :: i, j, m, n, numblks, pcoln, prown, pcolb, bnxt, bblk, m1, n1, blk, l, pcolp, prowp
	double precision, pointer, DIMENSION(:,:) :: a
	double precision, pointer, DIMENSION(:) :: b
	double precision, allocatable :: work(:)[*]
	a => ab(1:m, 1:n)
	b => ab(1:m, n+1)
	numblks = (PROBLEMSIZE - 1) / BLKSIZE 
	pcoln = mod(numblks, NPCOL)		! processors own the last column block of A
	prown = mod(numblks, NPROW)		! processors own the last row block of A
	pcolb = mod(PROBLEMSIZE / BLKSIZE, NPCOL)
	blk = PROBLEMSIZE - numblks * BLKSIZE
	l = PROBLEMSIZE - blk

	if (pcoln .ne. pcolb .and. mycol .eq. pcolb) ab(1:m,n+1)[pcoln@rteam] = ab(1:m,n+1)
	call barrier(rteam)

	if (mycol .ne. pcoln) b = 0

	m1 = m 
	n1 = n
	if (myrow .eq. prown .and. mycol .eq. pcoln) then 
	  do i = m, m-blk+1, -1
	    b(i) = b(i) / a(i,i)
	    b(m-blk+1:i-1) = b(m-blk+1:i-1) - b(i) * a(m-blk+1:i-1,i)
	  end do
	  x(n-blk+1:n) = b(m-blk+1:m)
	end if

	if (myrow .eq. prown) m1 = m - blk
	if (mycol .eq. pcoln) n1 = n - blk
	allocate(work(min((NPCOL-1)*BLKSIZE,m))[@team_world])	

	do j = 1, numblks 
	  pcolp = pcoln - 1 
	  prowp = prown - 1
	  if (pcolp .lt. 0) pcolp = pcolp + NPCOL
	  if (prowp .lt. 0) prowp = prowp + NPROW

	  bnxt = min(l, (NPCOL-1)*BLKSIZE)  
	  bblk = localsize(bnxt, max(l-bnxt,0), BLKSIZE, NPROW, myrow)

	  if (mycol .eq. pcoln) then
	    call team_broadcast(x(n1+1:n1+blk), prown, cteam)
	    if (bblk .gt. 0) then
	      b(m1-bblk+1:m1)= b(m1-bblk+1:m1)-matmul(a(m1-bblk+1:m1,n1+1:n1+blk),x(n1+1:n1+blk))
	      work(1:bblk)[pcolp@rteam] = b(m1-bblk+1:m1)
	    end if
	  end if

	  call barrier(rteam)
	  if (mycol .eq. pcolp .and. bblk .gt. 0) then
	    b(m1-bblk+1:m1) = b(m1-bblk+1:m1) + work(1:bblk)
	  end if

	  if (myrow .eq. prowp .and. mycol .eq. pcolp) then
	    do i = m1, m1-BLKSIZE+1, -1
	      b(i) = b(i) / a(i,i)
	      b(m1-BLKSIZE+1:i-1) = b(m1-BLKSIZE+1:i-1) - b(i) * a(m1-BLKSIZE+1:i-1,i)
	    end do
	    x(n1-BLKSIZE+1:n1) = b(m1-BLKSIZE+1:m1)
	  end if

	  if (mycol .eq. pcoln .and. m1-bblk .ge. 1) then
	    b(1:m1-bblk) = b(1:m1-bblk) - matmul(a(1:m1-bblk,n1+1:n1+blk),x(n1+1:n1+blk))  
	  end if
	  l = l - BLKSIZE
	  pcoln = pcolp
	  prown = prowp
	  blk = BLKSIZE
	  if (myrow .eq. prown) m1 = m1 - blk
	  if (mycol .eq. pcoln) n1 = n1 - blk
	end do

	if (mycol .eq. pcolp) call team_broadcast(x(1:BLKSIZE), prowp, cteam)
	deallocate(work)	

	end subroutine backsolve

	module support
	contains
	subroutine reduce_max(in1, in2, out, nbytes)
	integer :: nbytes
	double precision :: in1, in2, out
	out = max(in1, in2)
	end subroutine

        subroutine reduce_sum(in1, in2, out, nbytes)
        integer :: nbytes
        double precision :: in1(nbytes/8), in2(nbytes/8), out(nbytes/8)
        out = in1 + in2
        end subroutine

!	use user-defined type 
	subroutine select_max(in1, in2, out, nbytes)
	integer :: nbytes
	double precision :: in1(nbytes/8), in2(nbytes/8), out(nbytes/8)
	if ((nbytes .eq. 8 .and. abs(in1(1)) .lt. abs(in2(1))) .or. &
            (nbytes .eq. 64 .and. (abs(in1(5)) .lt. abs(in2(5)) .or. &
              (abs(in1(5)) .eq. abs(in2(5)) .and. in1(7) .lt. in2(7))))) then
	  out = in2 
	else 
	  out = in1
	end if
	end subroutine


!       compute a local portion of the array from global index i (0 based)
	function localsize(n, i, blksize, nprocs, myproc) result(mypart)
	integer :: n, i, blksize, nprocs, myproc, numblks, locblks, mydist
	integer :: inb, srcproc, inbs, mypart
	inb = i / blksize		
	srcproc = inb - (inb / nprocs) * nprocs
	inbs = blksize - (i - inb * blksize)
	numblks = (n - inbs) / blksize + 1
	locblks = numblks / nprocs

	if (myproc .eq. srcproc) then
	  mypart = n
	  if (n .gt. inbs) then 
	    if (numblks .ne. locblks * nprocs) mypart = inbs + locblks * blksize
	    if (numblks .eq. locblks * nprocs) mypart = n + (locblks - numblks) * blksize
	  end if	   
	else 
	  mypart = 0
	  if (n .gt. inbs) then 
	    mydist = myproc - srcproc
	    if (mydist .lt. 0) mydist = mydist + nprocs 
	    if (numblks .lt. nprocs) then
	      if (mydist .lt. numblks) mypart = blksize
	      if (mydist .eq. numblks) mypart = n - inbs + blksize * (1 - numblks)   
	    else 
	      mydist = mydist - numblks + locblks * nprocs
	      mypart = locblks * blksize
	      if (mydist .lt. 0) mypart = mypart + blksize
	      if (mydist .eq. 0) mypart = mypart + n -inbs - numblks * blksize + blksize
	    end if
	  end if
	end if
	end function localsize

	end module

	program HPL
	use support
	use HPLmod

	integer :: m, n, i, k
	integer, allocatable :: seed(:)
	double precision :: start_time, end_time, cputime, gflops	
	double precision :: normA, normx, resid, norm_r, norm_c
	double precision, allocatable :: normb(:)[*]
	double precision, pointer :: a(:,:)
	double precision, pointer :: b(:)

!       compute my location in a 2D processor grid
	nprocs = team_size(team_world)
	me = team_rank(team_world)	
	mycol = me / NPROW       
	myrow = me - mycol * NPROW
	if (me .eq. 0) then
	  if (nprocs .ne. NPCOL * NPROW) then
	    print *, 'execution needs ', NPCOL * NPROW, 'processors'
	  end if
	end if
	
	i = NPROW
	rowp2 = 1
	rowlog2 = 0
	do while (i .gt. 1)
	   i = i / 2
	   rowp2 = rowp2 * 2
	   rowlog2 = rowlog2 + 1
	end do

!       compute my part of the matrix and allocate
	m = localsize(PROBLEMSIZE, 0, BLKSIZE, NPROW, myrow)
	n = localsize(PROBLEMSIZE, 0, BLKSIZE, NPCOL, mycol)

	allocate(ab(m,n+1)[@team_world])
	a => ab(1:m,1:n)
	b => ab(1:m,n+1)	
	allocate(x(n)[@team_world])

	call team_split(team_world, myrow, mycol, rteam, myrow, ierr)
	call team_split(team_world, mycol, myrow, cteam, mycol, ierr)

	call random_seed(size = k)
	allocate(seed(k))
	call random_seed(get = seed)
	call init(m, n)
	
!       collect time for the main body of work
	call cpu_time(start_time)
	call lup(m, n)
	call backsolve(m, n)
	call barrier(team_world)
	call cpu_time(end_time)
	cputime = end_time - start_time

	gflops = (2.0/3.0*PROBLEMSIZE + 1.5) * (PROBLEMSIZE/1.0e9) * (PROBLEMSIZE/cputime) 
	if (me .eq. 0) then
	  print *,'size,nprocs,time,gflops:',PROBLEMSIZE,',',nprocs,',',cputime,',',gflops
	end if

!       verify results
	call random_seed(put = seed)
	call init(m,n)
	normA = norm_r(a,m,n)
	normx = norm_c(x,n)
	allocate(normb(1)[@team_world])
	if (mycol .eq. mod(PROBLEMSIZE/BLKSIZE, NPCOL)) then
	  normb(1) = maxval(abs(b)) 
	  call team_reduce(normb, normb, 0, REDUCE_MAX, cteam)
	  b = b - matmul(a,x)
	else
	  b = - matmul(a,x)
	end if
	call team_broadcast(normb, 0, team_world)
	call team_reduce(b(1:m), b(1:m), 0, REDUCE_SUM, rteam)
	resid = norm_r(b,m,1)
	resid = resid / (epsilon * (normA * normx + normb(1)) * PROBLEMSIZE)
	if (me .eq. 0 .and. resid .lt. THRESHOLD) print *, "result VALID. scaled residual: ", resid
	if (me .eq. 0 .and. resid .ge. THRESHOLD) print *, "result INVALID. scaled residual: ", resid
	
	deallocate(ab,x,seed,normb)
	end program HPL

	function norm_r(a,s,t) result(r)
	use support
	use HPLmod
	integer :: s,t
	double precision :: r, a(s,t)
	double precision, allocatable :: w(:)[*], nval(:)[*]
	allocate (w(s)[@team_world], nval(1)[@team_world])
	w = sum(abs(a),dim=2)
	if (t .gt. 1) call team_reduce(w(1:s), w(1:s), 0, REDUCE_SUM, rteam)
	if (mycol .eq. 0) then
	  nval(1) = maxval(w)
	  call team_select(nval, nval, 0, SELECT_MAX, cteam)
	end if
	call team_broadcast(nval, 0, team_world)
	r = nval(1)
	deallocate(w, nval)
	end function norm_r

	function norm_c(v,n) result(r)
	use support
	use HPLmod
	double precision :: r
	double precision :: v(n), w(n)
	double precision, allocatable :: nval(:)[*]
	allocate (nval(1)[@team_world])
	w = abs(v)
	nval(1) = maxval(w)
	call team_select(nval, nval, 0, SELECT_MAX, rteam)	
	call team_broadcast(nval, 0, team_world)
	r = nval(1)
	deallocate(nval)
	end function norm_c
!       perform factorization of a panel 
	subroutine fact(m, n, p)
	use support
	use HPLmod
	integer :: m, n, pivltmp(1)
	integer, pointer :: panelinfo(:)
	double precision, pointer :: panelbuff(:)
	double precision, pointer, DIMENSION(:,:) :: a
	double precision, pointer, DIMENSION(:) :: b, c, piv, l
	integer :: p, clb, rlb, rub, rproc, pivl, pivg, pivproc, mloc
	double precision, allocatable :: w(:)[*]
	allocate(w(2*BLKSIZE+4)[@cteam])

	if (p .eq. 1) then
	  panelinfo => panelinfo_1(1:isz1)
	  panelbuff => panelbuff_1(1:bsz1)
	else
	  panelinfo => panelinfo_2(1:isz2)
	  panelbuff => panelbuff_2(1:bsz2)
	end if
	mloc = panelinfo(5)
	a => ab(1:m,1:n)
	b => ab(1:m,n+1)	
	l => panelbuff(1:mloc*BLKSIZE)
	c => panelbuff(mloc*BLKSIZE+1:(mloc+BLKSIZE)*BLKSIZE)
	piv => panelbuff((mloc+BLKSIZE)*BLKSIZE+1:(mloc+BLKSIZE+1)*BLKSIZE) 
	clb = panelinfo(4)
	rlb = panelinfo(3)
	rub = rlb + mloc - 1
	rproc = panelinfo(7)
	do i = 1, BLKSIZE
!         compute pivots, switch rows, and update the panel
	  w(1:BLKSIZE+3) = 0.0
	  w(BLKSIZE+4) = nprow
	  if (rub .ge. rlb) then
	    pivltmp = maxloc(abs(a(rlb:rub,clb+i-1)))
	    pivl = pivltmp(1)                    !  1-based
	    pivg = pivl + rlb - 2                !  0-based
	    pivg = pivg + BLKSIZE * ((NPROW - 1) * (pivg / BLKSIZE) + myrow) + 1   !  1-based
	    w(BLKSIZE+1) = a(rlb+pivl-1,clb+i-1)
	    w(BLKSIZE+2:BLKSIZE+4) = (/pivl, pivg, myrow/)
	    w(1:BLKSIZE) = a(rlb+pivl-1, clb:clb+BLKSIZE-1)
	  end if
	  call team_allselect(w(1:BLKSIZE+4), w(1:BLKSIZE+4), SELECT_MAX, cteam)
	  piv(i) = w(BLKSIZE+3)
	  
	  pivl = w(BLKSIZE+2)
	  pivproc = w(BLKSIZE+4)
	  if (myrow .eq. rproc .and. myrow .ne. pivproc) then
	    w(BLKSIZE+5:2*BLKSIZE+4)[pivproc@cteam] = a(rlb,clb:clb+BLKSIZE-1)
	  end if 
	  call barrier(cteam)
	  
	  c(i::BLKSIZE) = w(1:BLKSIZE)
	  if (myrow .eq. rproc) then
	    if (myrow .ne. pivproc) then
	      a(rlb, clb:clb+BLKSIZE-1) = w(1:BLKSIZE)
	    else if (myrow .eq. pivproc .and. pivl .ne. 1) then
	      a(pivl+rlb-1, clb:clb+BLKSIZE-1) = a(rlb,clb:clb+BLKSIZE-1)
	      a(rlb, clb:clb+BLKSIZE-1) = w(1:BLKSIZE)
	    end if
	  else if (myrow .eq. pivproc) then
	    a(pivl+rlb-1, clb:clb+BLKSIZE-1) = w(BLKSIZE+5:2*BLKSIZE+4)
	  end if

	  if (myrow .eq. rproc) rlb = rlb + 1
	  a(rlb:rub,clb+i-1) = a(rlb:rub,clb+i-1) / w(BLKSIZE+1)

	  if (i < BLKSIZE) then
	    do j = rlb, rub
	      a(j,clb+i:clb+BLKSIZE-1) = a(j,clb+i:clb+BLKSIZE-1) - a(j,clb+i-1) * w(i+1:BLKSIZE)
	    end do
	  end if

	end do

	rlb = panelinfo(3)
	do i = clb, clb + BLKSIZE - 1
	   l((i-clb)*mloc+1:(i-clb+1)*mloc) = a(rlb:rlb+mloc-1,i)
	end do

	deallocate(w)
	end subroutine fact
	subroutine init(m, n)
	use HPLmod
	integer :: m, n
	do i = 0, 3 - me
	  call random_number(ab)
	end do
	ab = ab * 2.0 - 1.0
	end subroutine init

	subroutine lup(m, n)
	use HPLmod
	use support
	integer :: m, n, nn, p, pp = 0, cp, pproc, cproc, ub, colstart
	nn = localsize(PROBLEMSIZE+1, 0, BLKSIZE, NPCOL, mycol)

!       build panels to fill the panel buffer, factorize and update them
	do p = 1, 2
	  call initpanel(p, pp)
	  if (p .ne. 2) pp = pp + BLKSIZE
	  if (p .eq. 1 .and. mycol .eq. panelinfo_1(8)) nn = nn - BLKSIZE
	end do

	if (mycol .eq. panelinfo_1(8)) call fact(m, n, 1)
	
	mloc = panelinfo_1(5)
	pproc = panelinfo_1(8)
	call team_broadcast(panelbuff_1(1:(mloc+BLKSIZE+1)*BLKSIZE),panelinfo_1(8),rteam)
	
!       factorize rest panels and finish all updates
	cproc = panelinfo_2(8)
        
	do j = pp, PROBLEMSIZE - 1, BLKSIZE

	  cp = j / BLKSIZE + 1
	  cp = mod(cp - 1, 2) + 1
	  if (cp .eq. 1) then
	    deallocate(panelinfo_1, panelbuff_1)
	  else 
	    deallocate(panelinfo_2, panelbuff_2)
	  end if
	  call initpanel(cp, j)
	  numcol = 0
	  colstart = 0

	  if (mycol .eq. cproc) then
	    numcol = localsize(BLKSIZE, j, BLKSIZE, NPCOL, mycol)
	    call update(m, n, 0, numcol, 3 - cp)
	    call fact(m, n, cp)
	    colstart = colstart + BLKSIZE
	  end if 	
	  if (mycol .eq. pproc) then
	    colstart = colstart + BLKSIZE
	  end if
	  call barrier(team_world) 
	  if (cp .eq. 1) then 
	    ub = (panelinfo_1(5)+BLKSIZE+1)*BLKSIZE
	    call team_broadcast(panelbuff_1(1:ub), panelinfo_1(8), rteam)
	  else 
	    ub = (panelinfo_2(5)+BLKSIZE+1)*BLKSIZE
	    call team_broadcast(panelbuff_2(1:ub), panelinfo_2(8), rteam)
	  end if

	  call update(m,n, colstart, nn-numcol, 3 - cp)

	  if (mycol .eq. cproc) nn = nn - BLKSIZE
	  pproc = cproc
	  cproc = mod(cproc+1, NPCOL)

	end do
	
	numcol = localsize(1, PROBLEMSIZE + 1, BLKSIZE, NPCOL, mycol)
	call update(m, n, 0, numcol, cp)
	
	deallocate(panelinfo_1, panelinfo_2, panelbuff_1, panelbuff_2)

	end subroutine lup

!       initialize a panel starting at global index (pp, pp)
	subroutine initpanel(p, pp)
	  use HPLmod
	  use support
	  integer :: p, pp, blk, rproc, cproc, mloc, nloc, iloc, jloc    ! pp is 0-based
	  integer, pointer :: info(:)
	  blk = pp / BLKSIZE
	  rproc = blk - blk / NPROW * NPROW
	  cproc = blk - blk / NPCOL * NPCOL
	  mloc = localsize(PROBLEMSIZE - pp, pp, BLKSIZE, NPROW, myrow)
	  nloc = localsize(PROBLEMSIZE + 1 - pp, pp, BLKSIZE, NPCOL, mycol)
	  if (p .eq. 1) then
	    isz1 = 8 * BLKSIZE + 2 * NPROW + 10
	    bsz1 = (mloc + nloc + BLKSIZE + 1) * BLKSIZE
	    allocate(panelinfo_1(isz1)[@team_world])
	    allocate(panelbuff_1(bsz1)[@team_world])
	    info => panelinfo_1
	  else 
	    isz2 = 8 * BLKSIZE + 2 * NPROW + 10
	    bsz2 = (mloc + nloc + BLKSIZE + 1) * BLKSIZE
	    allocate(panelinfo_2(isz2)[@team_world])
	    allocate(panelbuff_2(bsz2)[@team_world])
	    info => panelinfo_2
	  end if 
	  iloc = localsize(pp, 0, BLKSIZE, NPROW, myrow)
	  jloc = localsize(pp, 0, BLKSIZE, NPCOL, mycol)
	  info(1:9) = (/pp+1, pp+1, iloc+1, jloc+1, mloc, nloc, rproc, cproc, 0/)  ! 0 to 1-based
	end subroutine initpanel
!       solve the upper triangle matrix
	subroutine backsolve(m, n)
	use HPLmod
	use support
	integer :: i, j, m, n, numblks, pcoln, prown, pcolb, bnxt, bblk, m1, n1, blk, l, pcolp, prowp
	double precision, pointer, DIMENSION(:,:) :: a
	double precision, pointer, DIMENSION(:) :: b
	double precision, allocatable :: work(:)[*]
	a => ab(1:m, 1:n)
	b => ab(1:m, n+1)
	numblks = (PROBLEMSIZE - 1) / BLKSIZE 
	pcoln = mod(numblks, NPCOL)		! processors own the last column block of A
	prown = mod(numblks, NPROW)		! processors own the last row block of A
	pcolb = mod(PROBLEMSIZE / BLKSIZE, NPCOL)
	blk = PROBLEMSIZE - numblks * BLKSIZE
	l = PROBLEMSIZE - blk

	if (pcoln .ne. pcolb .and. mycol .eq. pcolb) ab(1:m,n+1)[pcoln@rteam] = ab(1:m,n+1)
	call barrier(rteam)

	if (mycol .ne. pcoln) b = 0

	m1 = m 
	n1 = n
	if (myrow .eq. prown .and. mycol .eq. pcoln) then 
	  do i = m, m-blk+1, -1
	    b(i) = b(i) / a(i,i)
	    b(m-blk+1:i-1) = b(m-blk+1:i-1) - b(i) * a(m-blk+1:i-1,i)
	  end do
	  x(n-blk+1:n) = b(m-blk+1:m)
	end if

	if (myrow .eq. prown) m1 = m - blk
	if (mycol .eq. pcoln) n1 = n - blk
	allocate(work(min((NPCOL-1)*BLKSIZE,m))[@team_world])	

	do j = 1, numblks 
	  pcolp = pcoln - 1 
	  prowp = prown - 1
	  if (pcolp .lt. 0) pcolp = pcolp + NPCOL
	  if (prowp .lt. 0) prowp = prowp + NPROW

	  bnxt = min(l, (NPCOL-1)*BLKSIZE)  
	  bblk = localsize(bnxt, max(l-bnxt,0), BLKSIZE, NPROW, myrow)

	  if (mycol .eq. pcoln) then
	    call team_broadcast(x(n1+1:n1+blk), prown, cteam)
	    if (bblk .gt. 0) then
	      b(m1-bblk+1:m1)= b(m1-bblk+1:m1)-matmul(a(m1-bblk+1:m1,n1+1:n1+blk),x(n1+1:n1+blk))
	      work(1:bblk)[pcolp@rteam] = b(m1-bblk+1:m1)
	    end if
	  end if

	  call barrier(rteam)
	  if (mycol .eq. pcolp .and. bblk .gt. 0) then
	    b(m1-bblk+1:m1) = b(m1-bblk+1:m1) + work(1:bblk)
	  end if

	  if (myrow .eq. prowp .and. mycol .eq. pcolp) then
	    do i = m1, m1-BLKSIZE+1, -1
	      b(i) = b(i) / a(i,i)
	      b(m1-BLKSIZE+1:i-1) = b(m1-BLKSIZE+1:i-1) - b(i) * a(m1-BLKSIZE+1:i-1,i)
	    end do
	    x(n1-BLKSIZE+1:n1) = b(m1-BLKSIZE+1:m1)
	  end if

	  if (mycol .eq. pcoln .and. m1-bblk .ge. 1) then
	    b(1:m1-bblk) = b(1:m1-bblk) - matmul(a(1:m1-bblk,n1+1:n1+blk),x(n1+1:n1+blk))  
	  end if
	  l = l - BLKSIZE
	  pcoln = pcolp
	  prown = prowp
	  blk = BLKSIZE
	  if (myrow .eq. prown) m1 = m1 - blk
	  if (mycol .eq. pcoln) n1 = n1 - blk
	end do

	if (mycol .eq. pcolp) call team_broadcast(x(1:BLKSIZE), prowp, cteam)
	deallocate(work)	

	end subroutine backsolve
!       use currpanel to update numcol columns of the trailing matrix of a
	subroutine update(m, n, coldiff, numcol, p)
	use HPLmod
	use support
	implicit none
	integer :: m, n, coldiff, numcol, lb, ub, pos, ierr, k, jlb, mykey, iu, ipiv, nn, lb_p
	double precision, pointer :: panelbuff(:)
	double precision, pointer, DIMENSION(:,:) :: a
	double precision, pointer, DIMENSION(:) :: c, piv, l, u
	integer, pointer, DIMENSION(:) :: pairs, aloc,uloc,len1,len2, permute, panelinfo
	integer, pointer :: flag, numpairs
	double precision, allocatable :: w(:,:)[*]
	integer, allocatable :: wptr(:)[*]
	integer :: p, mloc, nloc, iloc, jloc, mloc_p
	integer :: i, j, ii, src, dst, fnds, fndd, rproc, srcprow, dstprow 
	integer :: srcloc, dstloc, wrows, wlb, numrows, mydist, partner, lessip2
	if (p .eq. 1) then
	  panelinfo => panelinfo_1(1:isz1)
	  panelbuff => panelbuff_1(1:bsz1)
	else
	  panelinfo => panelinfo_2(1:isz2)
	  panelbuff => panelbuff_2(1:bsz2)
	end if
	iloc = panelinfo(3)
	jloc = panelinfo(4)
	mloc = panelinfo(5)
	nloc = panelinfo(6)
	rproc = panelinfo(7)
	a => ab(1:m,1:n)
	l => panelbuff(1:mloc*BLKSIZE)
	c => panelbuff(mloc*BLKSIZE+1:(mloc+BLKSIZE)*BLKSIZE)
	piv => panelbuff((mloc+BLKSIZE)*BLKSIZE+1:(mloc+BLKSIZE+1)*BLKSIZE)
	u => panelbuff((mloc+BLKSIZE+1)*BLKSIZE+1:(mloc+nloc+BLKSIZE+1)*BLKSIZE)
	permute => panelinfo(9:8*BLKSIZE+2*NPROW+10)
	nn = min(numcol, PROBLEMSIZE - panelinfo(2))
	allocate(w(nn+1, BLKSIZE)[@cteam])
	allocate(wptr(1)[@cteam])
	flag => permute(1)
	numpairs => permute(2) 
	pairs => permute(3:4*BLKSIZE+2)
	aloc => permute(4*BLKSIZE+3:6*BLKSIZE+2)
	uloc => permute(6*BLKSIZE+3:8*BLKSIZE+2)
	len1 => permute(8*BLKSIZE+3:8*BLKSIZE+NPROW+2)
	len2 => permute(8*BLKSIZE+NPROW+3:8*BLKSIZE+2*NPROW+2)
	
!       compute row permutation from pivot information
	if (flag .eq. 0) then
	  ipiv = piv(1)
	  pairs(1:2) = (/ipiv, panelinfo(1)/)
	  numpairs = 1
	  if (ipiv .ne. panelinfo(1)) then
	    pairs(3:4) = (/panelinfo(1), ipiv/)
	    numpairs = 2
	  end if
	  do i = 2, BLKSIZE
	    src = panelinfo(1) + i - 1
	    dst = piv(i)
	    fnds = 0
	    fndd = 0
	    do j = 1, numpairs 
	      if (fnds .eq. 0 .or. src .ne. dst .and. fndd .eq. 0) then
	        if (src .eq. pairs((j-1)*2+2)) fnds = j
	        if (src .ne. dst .and. dst .eq. pairs((j-1)*2+2)) fndd = j
	      end if
	    end do
	  
	    if (fnds .eq. 0) then 
	      pairs(numpairs*2+1:numpairs*2+2) = (/src, dst/)
	      numpairs = numpairs + 1
	      pos = numpairs
	    else
	      pairs((fnds-1)*2+2) = dst
	      pos = fnds
	    end if
	  
	    if (src .ne. dst) then
	      if (fndd .eq. 0) then
	        pairs(numpairs*2+1:numpairs*2+2) = (/dst, src/)
	        numpairs = numpairs + 1
	        pos = numpairs
	      else
	        pairs((fndd-1)*2+2) = src
	        pos = fndd
	      end if
	    end if
	    if (i .ne. pos) then
	      src = pairs((i-1)*2+1)
	      dst = pairs((i-1)*2+2)
	      pairs((i-1)*2+1:(i-1)*2+2) = pairs((pos-1)*2+1:(pos-1)*2+2)
	      pairs((pos-1)*2+1:(pos-1)*2+2) = (/src, dst/)
	    end if
	  end do
	
!         compute the locations in a and u where rows should be placed
	  ii = 1
	  len2 = 0
	  do i = 1, numpairs
	    src = pairs((i-1)*2+1)
	    srcprow = (src - 1) / BLKSIZE
	    srcprow = mod(srcprow, NPROW)
	    len2(srcprow+1) = len2(srcprow+1) + 1    !   1-based, procid also 1-based
	    if (myrow .eq. srcprow) then
	      srcloc = localsize(src, 0, BLKSIZE, NPROW, myrow)
	      aloc(ii) = srcloc - iloc
	      dst = pairs((i-1)*2+2)
	      if (myrow .eq. rproc) then
	        dstprow = (dst - 1) / BLKSIZE
	        dstprow = mod(dstprow, NPROW)
	        if (dstprow .eq. rproc) then
		  uloc(ii) = dst - panelinfo(1)
		  if (dst - panelinfo(1) .ge. BLKSIZE) then
		    dstloc = localsize(dst, 0, BLKSIZE, NPROW, myrow)
		    uloc(ii) = iloc - dstloc
		  end if
	        else
		  fndd = 0
		  do j = 1, numpairs
		    if (fndd .eq. 0 .and. dst .eq. pairs((j-1)*2+1)) fndd = j
		  end do
		  uloc(ii) = pairs((fndd-1)*2+2) - panelinfo(1)
	        end if
	      else 
	        uloc(ii) = dst - panelinfo(1)
	      end if
	      ii = ii + 1
	    end if
	  end do
	  flag = 1
	end if
	
!       permute rows and broadcast u
	w = 0
	numrows = len2(myrow+1)
	len1(:) = len2(:)
	if (myrow .eq. rproc) then
	  do i = 1, numrows
	    if (uloc(i) .ge. 0) then
	      u(uloc(i)+1:uloc(i)+(nn-1)*BLKSIZE+1:BLKSIZE) = a(aloc(i)+iloc,jloc+coldiff:jloc+coldiff+nn-1)
	    end if
	    if (uloc(i) .lt. 0) then
	      a((-uloc(i))+iloc,jloc+coldiff:jloc+coldiff+nn-1) = a(aloc(i)+iloc,jloc+coldiff:jloc+coldiff+nn-1)
	    end if
	  end do
	else 
	  w(1,1:numrows) = uloc(1:numrows)
	  do i = 1, numrows
	    w(2:,i) = a(aloc(i)+iloc, jloc+coldiff:jloc+coldiff+nn-1)
	  end do
	end if
	if (myrow .eq. rproc) then
	   len1(myrow+1) = 0
	   numrows = 0
	end if

	wptr(1) = numrows
	mydist = myrow - rproc
	if (mydist < 0) mydist = mydist + NPROW
	partner = ieor(mydist, rowp2)
	call barrier(cteam)
	if (NPROW - rowp2 .ne. 0 .and. partner .lt. NPROW) then
	  partner = mod(partner + rproc, NPROW)
	  if (mydist .eq. 0) then 
	    lb = (mloc+BLKSIZE+1)*BLKSIZE+1
	    ub = (mloc+nloc+BLKSIZE+1)*BLKSIZE
	    if (p .eq. 1) then
	      mloc_p = panelinfo_1(5)[partner@cteam]
	      lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1 
	      panelbuff_1(lb_p : lb_p+ub-lb)[partner@cteam] = panelbuff_1(lb : ub)
	    else
	      mloc_p = panelinfo_2(5)[partner@cteam]
	      lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1 
	      panelbuff_2(lb_p : lb_p+ub-lb)[partner@cteam] = panelbuff_2(lb : ub)
	    end if
	  else if (mydist .eq. rowp2) then
	    w(:, 1 : len1(myrow+1))[partner@cteam] = w(:, 1 : len1(myrow+1))
	  else if (iand(mydist, rowp2) .ne. 0) then
	    wlb = wptr(1)[partner@cteam]
	    w(:, wlb+1 : wlb+len1(myrow+1))[partner@cteam] = w(:, 1 : len1(myrow+1))
	  else if (len1(partner+1) .gt. 0) then
	    wptr(1) = wptr(1) + len1(partner+1)
	  end if
	end if

	call barrier(cteam)

	partner = ieor(mydist, rowp2)
	if (NPROW - rowp2 .ne. 0 .and. partner .lt. NPROW) then
	  partner = mod(partner + rproc, NPROW)
	  if (mydist .eq. 0 .and. len1(partner+1) .gt. 0) then
	    do i = 1, len1(partner+1)
	       iu = w(1,i) + 1  ! w(1,i) is 0-based
	       u(iu:iu+(nn-1)*BLKSIZE:BLKSIZE) = w(2:nn+1,i)
	    end do
	  end if
	end if

	do i = 1, NPROW-rowp2-1
	  lessip2 = mod(rproc+i, NPROW)
	  len1(lessip2+1) = len1(lessip2+1) + len1(mod(lessip2+rowp2, NPROW)+1)
	end do
	
	mykey = 0
	wrows = wptr(1)
	if (mydist .lt. rowp2) mykey = 1
	if (mydist .ge. rowp2 .and. NPROW - rowp2 .ne. 0) mykey = 2
	call team_split(cteam, mykey, myrow, subcteam, mykey, ierr)

	if (mydist .lt. rowp2) then
	  do i = 1, rowlog2
	    partner = ieor(mydist, ibset(0, i-1))
	    partner = mod(rproc + partner, NPROW)
	    if (mydist .lt. ibset(0, i) .and. mydist .lt. ibset(0, i-1)) then
	      lb = (mloc+BLKSIZE+1)*BLKSIZE+1
	      ub = (mloc+nloc+BLKSIZE+1)*BLKSIZE
	      if (p .eq. 1) then
	        mloc_p = panelinfo_1(5)[partner@subcteam]
	        lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1
	        panelbuff_1(lb_p : lb_p+ub-lb)[partner@subcteam] = panelbuff_1(lb : ub)
	      else
	        mloc_p = panelinfo_2(5)[partner@subcteam]
	        lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1
	        panelbuff_2(lb_p : lb_p+ub-lb)[partner@subcteam] = panelbuff_2(lb : ub)
	      end if
	      w(:,wrows+1:wrows+len1(partner+1)) = w(:,1:len1(partner+1))[partner@subcteam]
	    else if (mydist .ge. ibset(0, i)) then
	      w(:,wrows+1:wrows+len1(partner+1)) = w(:,1:len1(partner+1))[partner@subcteam]
	    end if
	    call barrier(subcteam) 
	    if (mydist .lt. ibset(0, i) .and. mydist .lt. ibset(0, i-1)) then
	       do j = 1, len1(partner+1)
		  iu = w(1,wrows+j) + 1  ! w(1,i) is 0-based
		  u(iu::BLKSIZE) = w(2:,wrows+j)
	       end do
	    end if
	    if (mydist .lt. ibset(0, i) .and. mydist .ge. ibset(0, i-1)) then
	       do j = 1, numrows
		  a(aloc(j)+iloc, jloc+coldiff:jloc+coldiff+nn-1) = u(uloc(j)+1:uloc(j)+1+(nn-1)*BLKSIZE:BLKSIZE)
		  u(uloc(j)+1:uloc(j)+1+(nn-1)*BLKSIZE:BLKSIZE) = w(2:, j)
	       end do
	       do j = numrows + 1, len1(myrow+1) 
	          iu = w(1,j) + 1
		  u(iu:iu+(nn-1)*BLKSIZE:BLKSIZE) = w(2:, j)
	       end do
	    end if
	    if (mydist .ge. ibset(0, i) .or. mydist .lt. ibset(0, i-1)) then
	       wrows = wrows + len1(partner+1)
	    end if
	    do j = 0, rowp2 - 1
	       partner = ieor(j,ibset(0,i-1))
	       if (partner .gt. j) then
		  partner = mod(rproc + partner, NPROW)
		  len1(mod(rproc+j,NPROW)+1) = len1(mod(rproc+j,NPROW)+1) + len1(partner+1)
		  len1(partner+1) = len1(mod(rproc+j,NPROW)+1)
	       end if
	    end do
	  end do
	else if (NPROW - rowp2 .gt. 1) then
	  call team_broadcast(u, 0, subcteam)
	  do i = 1, numrows
	    a(aloc(i)+iloc,jloc+coldiff:) = u(uloc(i)+1::BLKSIZE)
	  end do
	end if
	if (NPROW - rowp2 .ne. 0 .and. ieor(mydist, rowp2) .lt. NPROW) then
	  partner = mod(rproc + ieor(mydist, rowp2), NPROW)
	  if (iand(mydist, rowp2) .eq. 0) then
	    lb = (mloc+BLKSIZE+1)*BLKSIZE+1
	    ub = (mloc+nloc+BLKSIZE+1)*BLKSIZE
	    if (p .eq. 1) then
	      mloc_p = panelinfo_1(5)[partner@cteam]
	      lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1
	      panelbuff_1(lb_p : lb_p+ub-lb)[partner@cteam] = panelbuff_1(lb : ub)
	    else 
	      mloc_p = panelinfo_2(5)[partner@cteam]
	      lb_p = (mloc_p+BLKSIZE+1)*BLKSIZE+1
	      panelbuff_2(lb_p : lb_p+ub-lb)[partner@cteam] = panelbuff_2(lb : ub)
	    end if
	  end if
	end if
	deallocate(wptr)
	deallocate(w)
	
!       update the trailing matrix by matrix multiplication
	do i = 1, nn
	  do j = 1, BLKSIZE
	      u((i-1)*BLKSIZE+j+1:i*BLKSIZE) = u((i-1)*BLKSIZE+j+1:i*BLKSIZE) &
	                - u((i-1)*BLKSIZE+j) * c((j-1)*BLKSIZE+j+1:j*BLKSIZE)
	  end do
	end do
	if (myrow .eq. rproc) then
	  do k = 1, BLKSIZE
	    do j = jloc, jloc + nn - 1
	       do i = iloc+BLKSIZE, iloc + mloc - 1
	         a(i, j+coldiff) = a(i, j+coldiff) - l((k-1)*mloc+i-iloc+1) * u((j-jloc)*BLKSIZE+k)
	       end do
	    end do
	  end do
	  jlb = jloc
	  do j = jlb, jloc + nn - 1
	    a(iloc:iloc+BLKSIZE-1,j+coldiff) = u((j-jlb)*BLKSIZE+1:(j-jlb+1)*BLKSIZE)
	  end do
	else 
	  do k = 1, BLKSIZE
	    do j = jloc, jloc + nn - 1
	      do i = iloc, iloc + mloc - 1 
	         a(i, j+coldiff) = a(i, j+coldiff) - l((k-1)*mloc+i-iloc+1) * u((j-jloc)*BLKSIZE+k)
	      end do
	    end do
	  end do
	end if
	
	end subroutine update
PROGRAM hpl
USE support
USE HPLmod
INTEGER :: m,n,i,k
INTEGER, DIMENSION(:), ALLOCATABLE :: seed
DOUBLE PRECISION :: start_time,end_time,cputime,gflops
DOUBLE PRECISION :: norma,normx,resid,norm_r,norm_c
DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: normb
DOUBLE PRECISION, DIMENSION(:,:), POINTER :: a
DOUBLE PRECISION, DIMENSION(:), POINTER :: b
!       compute my location in a 2D processor grid
nprocs = team_size(team_world)
me = team_rank(team_world)
mycol = me / nprow
myrow = me - mycol * nprow
IF (me == 0) THEN
IF (nprocs /= npcol * nprow) THEN
PRINT *, 'execution needs ',npcol * nprow,'processors'
END IF
END IF
i = nprow
rowp2 = 1
rowlog2 = 0
DO WHILE (i > 1)
i = i / 2
rowp2 = rowp2 * 2
rowlog2 = rowlog2 + 1
END DO
!       compute my part of the matrix and allocate
m = localsize(problemsize,0,blksize,nprow,myrow)
n = localsize(problemsize,0,blksize,npcol,mycol)
allocate( ab(m,n + 1)[@team_world] )
a => ab(1:m,1:n)
b => ab(1:m,n + 1)
allocate( x(n)[@team_world] )
CALL team_split(team_world,myrow,mycol,rteam,myrow,ierr)
CALL team_split(team_world,mycol,myrow,cteam,mycol,ierr)
CALL random_seed(size=k)
allocate( seed(k) )
CALL random_seed(get=seed)
CALL init(m,n)
!       collect time for the main body of work
CALL cpu_time(start_time)
CALL lup(m,n)
CALL backsolve(m,n)
CALL barrier(team_world)
CALL cpu_time(end_time)
cputime = end_time - start_time
gflops = (2.0 / 3.0 * problemsize + 1.5) * (problemsize / 1.0e9) * (&
problemsize / cputime)
IF (me == 0) THEN
PRINT *, 'size,nprocs,time,gflops:',problemsize,',',nprocs,',',cputime,&
',',gflops
END IF
!       verify results
CALL random_seed(put=seed)
CALL init(m,n)
norma = norm_r(a,m,n)
normx = norm_c(x,n)
allocate( normb(1)[@team_world] )
IF (mycol == mod(problemsize / blksize,npcol)) THEN
normb(1) = maxval(abs(b))
CALL team_reduce(normb,normb,0,reduce_max,cteam)
b = b - matmul(a,x)
ELSE
b = -matmul(a,x)
END IF
CALL team_broadcast(normb,0,team_world)
CALL team_reduce(b(1:m),b(1:m),0,reduce_sum,rteam)
resid = norm_r(b,m,1)
resid = resid / (epsilon * (norma * normx + normb(1)) * problemsize)
IF (me == 0 .AND. resid < threshold) PRINT *, &
"result VALID. scaled residual: ",resid
IF (me == 0 .AND. resid >= threshold) PRINT *, &
"result INVALID. scaled residual: ",resid
deallocate( ab,x,seed,normb )
END PROGRAM hpl

 FUNCTION norm_r(a,s,t) result(r)
USE support
USE HPLmod
INTEGER :: s,t
DOUBLE PRECISION :: r,a(s,t)
DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: w,nval
allocate( w(s)[@team_world],nval(1)[@team_world] )
w = sum(abs(a),dim=2)
IF (t > 1) CALL team_reduce(w(1:s),w(1:s),0,reduce_sum,rteam)
IF (mycol == 0) THEN
nval(1) = maxval(w)
CALL team_select(nval,nval,0,select_max,cteam)
END IF
CALL team_broadcast(nval,0,team_world)
r = nval(1)
deallocate( w,nval )
END  FUNCTION norm_r

 FUNCTION norm_c(v,n) result(r)
USE support
USE HPLmod
DOUBLE PRECISION :: r
DOUBLE PRECISION, DIMENSION(n) :: v,w
DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: nval
allocate( nval(1)[@team_world] )
w = abs(v)
nval(1) = maxval(w)
CALL team_select(nval,nval,0,select_max,rteam)
CALL team_broadcast(nval,0,team_world)
r = nval(1)
deallocate( nval )
END  FUNCTION norm_c

!       perform factorization of a panel 
SUBROUTINE fact(m,n,p)
USE support
USE HPLmod
INTEGER :: m,n,pivltmp(1)
INTEGER, DIMENSION(:), POINTER :: panelinfo
DOUBLE PRECISION, DIMENSION(:), POINTER :: panelbuff
DOUBLE PRECISION, DIMENSION(:,:), POINTER :: a
DOUBLE PRECISION, DIMENSION(:), POINTER :: b,c,piv,l
INTEGER :: p,clb,rlb,rub,rproc,pivl,pivg,pivproc,mloc
DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: w
allocate( w(2 * blksize + 4)[@cteam] )
IF (p == 1) THEN
panelinfo => panelinfo_1(1:isz1)
panelbuff => panelbuff_1(1:bsz1)
ELSE
panelinfo => panelinfo_2(1:isz2)
panelbuff => panelbuff_2(1:bsz2)
END IF
mloc = panelinfo(5)
a => ab(1:m,1:n)
b => ab(1:m,n + 1)
l => panelbuff(1:(mloc * blksize))
c => panelbuff((mloc * blksize + 1):((mloc + blksize) * blksize))
piv => panelbuff(((mloc + blksize) * blksize + 1):((mloc + blksize + 1)&
 * blksize))
clb = panelinfo(4)
rlb = panelinfo(3)
rub = rlb + mloc - 1
rproc = panelinfo(7)
DO i = 1, blksize
!         compute pivots, switch rows, and update the panel
w(1:(blksize + 3)) = 0.0
w(blksize + 4) = nprow
IF (rub >= rlb) THEN
pivltmp = maxloc(abs(a(rlb:rub,clb + i - 1)))
pivl = pivltmp(1)
pivg = pivl + rlb - 2
pivg = pivg + blksize * ((nprow - 1) * (pivg / blksize) + myrow) + 1
w(blksize + 1) = a(rlb + pivl - 1,clb + i - 1)
w((blksize + 2):(blksize + 4)) = (/pivl,pivg,myrow/)
w(1:blksize) = a(rlb + pivl - 1,clb:(clb + blksize - 1))
END IF
CALL team_allselect(w(1:(blksize + 4)),w(1:(blksize + 4)),select_max,&
cteam)
piv(i) = w(blksize + 3)
pivl = w(blksize + 2)
pivproc = w(blksize + 4)
IF (myrow == rproc .AND. myrow /= pivproc) THEN
w((blksize + 5):(2 * blksize + 4))[pivproc@cteam] = a(rlb,clb:(clb + &
blksize - 1))
END IF
CALL barrier(cteam)
c(i::blksize) = w(1:blksize)
IF (myrow == rproc) THEN
IF (myrow /= pivproc) THEN
a(rlb,clb:(clb + blksize - 1)) = w(1:blksize)
ELSE IF (myrow == pivproc .AND. pivl /= 1) THEN
a(pivl + rlb - 1,clb:(clb + blksize - 1)) = a(rlb,clb:(clb + blksize - 1&
))
a(rlb,clb:(clb + blksize - 1)) = w(1:blksize)
END IF
ELSE IF (myrow == pivproc) THEN
a(pivl + rlb - 1,clb:(clb + blksize - 1)) = w((blksize + 5):(2 * blksize&
 + 4))
END IF
IF (myrow == rproc) rlb = rlb + 1
a(rlb:rub,clb + i - 1) = a(rlb:rub,clb + i - 1) / w(blksize + 1)
IF (i < blksize) THEN
DO j = rlb, rub
a(j,(clb + i):(clb + blksize - 1)) = a(j,(clb + i):(clb + blksize - 1))&
 - a(j,clb + i - 1) * w((i + 1):blksize)
END DO
END IF
END DO
rlb = panelinfo(3)
DO i = clb, clb + blksize - 1
l(((i - clb) * mloc + 1):((i - clb + 1) * mloc)) = a(rlb:(rlb + mloc - 1&
),i)
END DO
deallocate( w )
END SUBROUTINE fact

MODULE hplmod
INTEGER, PARAMETER :: problemsize = 16,numpanels = 2
INTEGER, PARAMETER :: blksize = 4,npcol = 2,nprow = 2
DOUBLE PRECISION, PARAMETER :: epsilon = 2.0e-16,threshold = 16.0
INTEGER :: nprocs,rowp2,rowlog2,me,mycol,myrow
TEAM :: rteam,cteam,subcteam
INTEGER, DIMENSION(:), ALLOCATABLE, TARGET :: panelinfo_1
INTEGER, DIMENSION(:), ALLOCATABLE, TARGET :: panelinfo_2
DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, TARGET :: panelbuff_1
DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, TARGET :: panelbuff_2
DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE, TARGET :: ab
DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: x
INTEGER :: isz1 = 0,isz2 = 0,bsz1 = 0,bsz2 = 0
CONTAINS
SUBROUTINE dump_ab(m,n)
DOUBLE PRECISION, DIMENSION(:,:), POINTER :: a
DOUBLE PRECISION, DIMENSION(:), POINTER :: b
CHARACTER(len=1) :: strme
CHARACTER(len=18) :: filename
a => ab(1:m,1:n)
b => ab(1:m,n + 1)
WRITE (UNIT=strme, FMT='(i1)') me
filename = 'out.ab.aftersol.p' // strme
OPEN (UNIT=8, FILE=filename) 
WRITE (UNIT=8, FMT=*) "--- a ---"
DO i = 1, m
WRITE (UNIT=8, FMT=*) a(i,1:n)
END DO
WRITE (UNIT=8, FMT=*) "--- b ---"
WRITE (UNIT=8, FMT=*) b(1:m)
CLOSE (UNIT=8) 
END SUBROUTINE 

SUBROUTINE dump_x(n)
CHARACTER(len=1) :: strme
CHARACTER(len=17) :: filename
WRITE (UNIT=strme, FMT='(i1)') me
filename = 'out.x.afsol.p' // strme
OPEN (UNIT=8, FILE=filename) 
WRITE (UNIT=8, FMT=*) "--- x ---"
WRITE (UNIT=8, FMT=*) x(1:n)
CLOSE (UNIT=8) 
END SUBROUTINE 

SUBROUTINE dump_panel(p)
INTEGER :: p,mloc,nloc
CHARACTER(len=1) :: strme
CHARACTER(len=21) :: filename
INTEGER, DIMENSION(:), POINTER :: panelinfo
DOUBLE PRECISION, DIMENSION(:), POINTER :: panelbuff,l,c,piv,u
IF (p == 1) THEN
panelinfo => panelinfo_1(1:isz1)
panelbuff => panelbuff_1(1:bsz1)
ELSE
panelinfo => panelinfo_2(1:isz2)
panelbuff => panelbuff_2(1:bsz2)
END IF
mloc = panelinfo(5)
nloc = panelinfo(6)
l => panelbuff(1:(mloc * blksize))
c => panelbuff((mloc * blksize + 1):((mloc + blksize) * blksize))
piv => panelbuff(((mloc + blksize) * blksize + 1):((mloc + blksize + 1)&
 * blksize))
u => panelbuff(((mloc + blksize + 1) * blksize + 1):((mloc + nloc + &
blksize + 1) * blksize))
WRITE (UNIT=strme, FMT='(i1)') me
filename = 'out.panel.afterlup.p' // strme
OPEN (UNIT=8, FILE=filename) 
WRITE (UNIT=8, FMT=*) "--- l ---"
DO i = 1, mloc
WRITE (UNIT=8, FMT=*) l(i::mloc)
END DO
WRITE (UNIT=8, FMT=*) "--- c ---"
DO i = 1, blksize
WRITE (UNIT=8, FMT=*) c(i::blksize)
END DO
WRITE (UNIT=8, FMT=*) "-- piv --"
WRITE (UNIT=8, FMT=*) piv
WRITE (UNIT=8, FMT=*) "-- u --"
DO i = 1, blksize
WRITE (UNIT=8, FMT=*) u(i::blksize)
END DO
CLOSE (UNIT=8) 
END SUBROUTINE 


END MODULE hplmod

SUBROUTINE init(m,n)
USE HPLmod
INTEGER :: m,n
DO i = 0, 3 - me
CALL random_number(ab)
END DO
ab = ab * 2.0 - 1.0
END SUBROUTINE init

SUBROUTINE lup(m,n)
USE HPLmod
USE support
INTEGER :: m,n,nn,p,pp = 0,cp,pproc,cproc,ub,colstart
nn = localsize(problemsize + 1,0,blksize,npcol,mycol)
!       build panels to fill the panel buffer, factorize and update them
DO p = 1, 2
CALL initpanel(p,pp)
IF (p /= 2) pp = pp + blksize
IF (p == 1 .AND. mycol == panelinfo_1(8)) nn = nn - blksize
END DO
IF (mycol == panelinfo_1(8)) CALL fact(m,n,1)
mloc = panelinfo_1(5)
pproc = panelinfo_1(8)
CALL team_broadcast(panelbuff_1(1:((mloc + blksize + 1) * blksize)),&
panelinfo_1(8),rteam)
!       factorize rest panels and finish all updates
cproc = panelinfo_2(8)
DO j = pp, problemsize - 1, blksize
cp = j / blksize + 1
cp = mod(cp - 1,2) + 1
IF (cp == 1) THEN
deallocate( panelinfo_1,panelbuff_1 )
ELSE
deallocate( panelinfo_2,panelbuff_2 )
END IF
CALL initpanel(cp,j)
numcol = 0
colstart = 0
IF (mycol == cproc) THEN
numcol = localsize(blksize,j,blksize,npcol,mycol)
CALL update(m,n,0,numcol,3 - cp)
CALL fact(m,n,cp)
colstart = colstart + blksize
END IF
IF (mycol == pproc) THEN
colstart = colstart + blksize
END IF
CALL barrier(team_world)
IF (cp == 1) THEN
ub = (panelinfo_1(5) + blksize + 1) * blksize
CALL team_broadcast(panelbuff_1(1:ub),panelinfo_1(8),rteam)
ELSE
ub = (panelinfo_2(5) + blksize + 1) * blksize
CALL team_broadcast(panelbuff_2(1:ub),panelinfo_2(8),rteam)
END IF
CALL update(m,n,colstart,nn - numcol,3 - cp)
IF (mycol == cproc) nn = nn - blksize
pproc = cproc
cproc = mod(cproc + 1,npcol)
END DO
numcol = localsize(1,problemsize + 1,blksize,npcol,mycol)
CALL update(m,n,0,numcol,cp)
deallocate( panelinfo_1,panelinfo_2,panelbuff_1,panelbuff_2 )
END SUBROUTINE lup

!       initialize a panel starting at global index (pp, pp)
SUBROUTINE initpanel(p,pp)
USE HPLmod
USE support
INTEGER :: p,pp,blk,rproc,cproc,mloc,nloc,iloc,jloc
INTEGER, DIMENSION(:), POINTER :: info
blk = pp / blksize
rproc = blk - blk / nprow * nprow
cproc = blk - blk / npcol * npcol
mloc = localsize(problemsize - pp,pp,blksize,nprow,myrow)
nloc = localsize(problemsize + 1 - pp,pp,blksize,npcol,mycol)
IF (p == 1) THEN
isz1 = 8 * blksize + 2 * nprow + 10
bsz1 = (mloc + nloc + blksize + 1) * blksize
allocate( panelinfo_1(isz1)[@team_world] )
allocate( panelbuff_1(bsz1)[@team_world] )
info => panelinfo_1
ELSE
isz2 = 8 * blksize + 2 * nprow + 10
bsz2 = (mloc + nloc + blksize + 1) * blksize
allocate( panelinfo_2(isz2)[@team_world] )
allocate( panelbuff_2(bsz2)[@team_world] )
info => panelinfo_2
END IF
iloc = localsize(pp,0,blksize,nprow,myrow)
jloc = localsize(pp,0,blksize,npcol,mycol)
info(1:9) = (/pp + 1,pp + 1,iloc + 1,jloc + 1,mloc,nloc,rproc,cproc,0/)
END SUBROUTINE initpanel

!       solve the upper triangle matrix
SUBROUTINE backsolve(m,n)
USE HPLmod
USE support
INTEGER :: i,j,m,n,numblks,pcoln,prown,pcolb,bnxt,bblk,m1,n1,blk,l,pcolp&
,prowp
DOUBLE PRECISION, DIMENSION(:,:), POINTER :: a
DOUBLE PRECISION, DIMENSION(:), POINTER :: b
DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: work
a => ab(1:m,1:n)
b => ab(1:m,n + 1)
numblks = (problemsize - 1) / blksize
pcoln = mod(numblks,npcol)
prown = mod(numblks,nprow)
pcolb = mod(problemsize / blksize,npcol)
blk = problemsize - numblks * blksize
l = problemsize - blk
IF (pcoln /= pcolb .AND. mycol == pcolb) ab(1:m,n + 1)[pcoln@rteam] = ab&
(1:m,n + 1)
CALL barrier(rteam)
IF (mycol /= pcoln) b = 0
m1 = m
n1 = n
IF (myrow == prown .AND. mycol == pcoln) THEN
DO i = m, m - blk + 1, -1
b(i) = b(i) / a(i,i)
b((m - blk + 1):(i - 1)) = b((m - blk + 1):(i - 1)) - b(i) * a((m - blk&
 + 1):(i - 1),i)
END DO
x((n - blk + 1):n) = b((m - blk + 1):m)
END IF
IF (myrow == prown) m1 = m - blk
IF (mycol == pcoln) n1 = n - blk
allocate( work(min((npcol - 1) * blksize,m))[@team_world] )
DO j = 1, numblks
pcolp = pcoln - 1
prowp = prown - 1
IF (pcolp < 0) pcolp = pcolp + npcol
IF (prowp < 0) prowp = prowp + nprow
bnxt = min(l,(npcol - 1) * blksize)
bblk = localsize(bnxt,max(l - bnxt,0),blksize,nprow,myrow)
IF (mycol == pcoln) THEN
CALL team_broadcast(x((n1 + 1):(n1 + blk)),prown,cteam)
IF (bblk > 0) THEN
b((m1 - bblk + 1):m1) = b((m1 - bblk + 1):m1) - matmul(a((m1 - bblk + 1)&
:m1,(n1 + 1):(n1 + blk)),x((n1 + 1):(n1 + blk)))
work(1:bblk)[pcolp@rteam] = b((m1 - bblk + 1):m1)
END IF
END IF
CALL barrier(rteam)
IF (mycol == pcolp .AND. bblk > 0) THEN
b((m1 - bblk + 1):m1) = b((m1 - bblk + 1):m1) + work(1:bblk)
END IF
IF (myrow == prowp .AND. mycol == pcolp) THEN
DO i = m1, m1 - blksize + 1, -1
b(i) = b(i) / a(i,i)
b((m1 - blksize + 1):(i - 1)) = b((m1 - blksize + 1):(i - 1)) - b(i) * a&
((m1 - blksize + 1):(i - 1),i)
END DO
x((n1 - blksize + 1):n1) = b((m1 - blksize + 1):m1)
END IF
IF (mycol == pcoln .AND. m1 - bblk >= 1) THEN
b(1:(m1 - bblk)) = b(1:(m1 - bblk)) - matmul(a(1:(m1 - bblk),(n1 + 1):(&
n1 + blk)),x((n1 + 1):(n1 + blk)))
END IF
l = l - blksize
pcoln = pcolp
prown = prowp
blk = blksize
IF (myrow == prown) m1 = m1 - blk
IF (mycol == pcoln) n1 = n1 - blk
END DO
IF (mycol == pcolp) CALL team_broadcast(x(1:blksize),prowp,cteam)
deallocate( work )
END SUBROUTINE backsolve

MODULE support
CONTAINS
SUBROUTINE reduce_max(in1,in2,out,nbytes)
INTEGER :: nbytes
DOUBLE PRECISION :: in1,in2,out
out = max(in1,in2)
END SUBROUTINE 

SUBROUTINE reduce_sum(in1,in2,out,nbytes)
INTEGER :: nbytes
DOUBLE PRECISION, DIMENSION(nbytes / 8) :: in1,in2,out
out = in1 + in2
END SUBROUTINE 

!	use user-defined type 
SUBROUTINE select_max(in1,in2,out,nbytes)
INTEGER :: nbytes
DOUBLE PRECISION, DIMENSION(nbytes / 8) :: in1,in2,out
IF (nbytes == 8 .AND. abs(in1(1)) < abs(in2(1)) .OR. nbytes == 64 .AND. &
(abs(in1(5)) < abs(in2(5)) .OR. abs(in1(5)) == abs(in2(5)) .AND. in1(7)&
 < in2(7))) THEN
out = in2
ELSE
out = in1
END IF
END SUBROUTINE 

!       compute a local portion of the array from global index i (0 based)
 FUNCTION localsize(n,i,blksize,nprocs,myproc) result(mypart)
INTEGER :: n,i,blksize,nprocs,myproc,numblks,locblks,mydist
INTEGER :: inb,srcproc,inbs,mypart
inb = i / blksize
srcproc = inb - inb / nprocs * nprocs
inbs = blksize - (i - inb * blksize)
numblks = (n - inbs) / blksize + 1
locblks = numblks / nprocs
IF (myproc == srcproc) THEN
mypart = n
IF (n > inbs) THEN
IF (numblks /= locblks * nprocs) mypart = inbs + locblks * blksize
IF (numblks == locblks * nprocs) mypart = n + (locblks - numblks) * &
blksize
END IF
ELSE
mypart = 0
IF (n > inbs) THEN
mydist = myproc - srcproc
IF (mydist < 0) mydist = mydist + nprocs
IF (numblks < nprocs) THEN
IF (mydist < numblks) mypart = blksize
IF (mydist == numblks) mypart = n - inbs + blksize * (1 - numblks)
ELSE
mydist = mydist - numblks + locblks * nprocs
mypart = locblks * blksize
IF (mydist < 0) THEN
mypart = mypart + blksize
IF (mydist == 0) THEN
mypart = mypart + n - inbs - numblks * blksize + blksize
END IF
END IF
END IF
END  FUNCTION localsize


END MODULE support

!       use currpanel to update numcol columns of the trailing matrix of a
SUBROUTINE update(m,n,coldiff,numcol,p)
USE HPLmod
USE support
IMPLICIT NONE
INTEGER :: m,n,coldiff,numcol,lb,ub,pos,ierr,k,jlb,mykey,iu,ipiv,nn,lb_p
DOUBLE PRECISION, DIMENSION(:), POINTER :: panelbuff
DOUBLE PRECISION, DIMENSION(:,:), POINTER :: a
DOUBLE PRECISION, DIMENSION(:), POINTER :: c,piv,l,u
INTEGER, DIMENSION(:), POINTER :: pairs,aloc,uloc,len1,len2,permute,&
panelinfo
INTEGER, POINTER :: flag,numpairs
DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: w
INTEGER, DIMENSION(:), ALLOCATABLE :: wptr
INTEGER :: p,mloc,nloc,iloc,jloc,mloc_p
INTEGER :: i,j,ii,src,dst,fnds,fndd,rproc,srcprow,dstprow
INTEGER :: srcloc,dstloc,wrows,wlb,numrows,mydist,partner,lessip2
IF (p == 1) THEN
panelinfo => panelinfo_1(1:isz1)
panelbuff => panelbuff_1(1:bsz1)
ELSE
panelinfo => panelinfo_2(1:isz2)
panelbuff => panelbuff_2(1:bsz2)
END IF
iloc = panelinfo(3)
jloc = panelinfo(4)
mloc = panelinfo(5)
nloc = panelinfo(6)
rproc = panelinfo(7)
a => ab(1:m,1:n)
l => panelbuff(1:(mloc * blksize))
c => panelbuff((mloc * blksize + 1):((mloc + blksize) * blksize))
piv => panelbuff(((mloc + blksize) * blksize + 1):((mloc + blksize + 1)&
 * blksize))
u => panelbuff(((mloc + blksize + 1) * blksize + 1):((mloc + nloc + &
blksize + 1) * blksize))
permute => panelinfo(9:(8 * blksize + 2 * nprow + 10))
nn = min(numcol,problemsize - panelinfo(2))
allocate( w(nn + 1,blksize)[@cteam] )
allocate( wptr(1)[@cteam] )
flag => permute(1)
numpairs => permute(2)
pairs => permute(3:(4 * blksize + 2))
aloc => permute((4 * blksize + 3):(6 * blksize + 2))
uloc => permute((6 * blksize + 3):(8 * blksize + 2))
len1 => permute((8 * blksize + 3):(8 * blksize + nprow + 2))
len2 => permute((8 * blksize + nprow + 3):(8 * blksize + 2 * nprow + 2))
!       compute row permutation from pivot information
IF (flag == 0) THEN
ipiv = piv(1)
pairs(1:2) = (/ipiv,panelinfo(1)/)
numpairs = 1
IF (ipiv /= panelinfo(1)) THEN
pairs(3:4) = (/panelinfo(1),ipiv/)
numpairs = 2
END IF
DO i = 2, blksize
src = panelinfo(1) + i - 1
dst = piv(i)
fnds = 0
fndd = 0
DO j = 1, numpairs
IF (fnds == 0 .OR. src /= dst .AND. fndd == 0) THEN
IF (src == pairs((j - 1) * 2 + 2)) fnds = j
IF (src /= dst .AND. dst == pairs((j - 1) * 2 + 2)) fndd = j
END IF
END DO
IF (fnds == 0) THEN
pairs((numpairs * 2 + 1):(numpairs * 2 + 2)) = (/src,dst/)
numpairs = numpairs + 1
pos = numpairs
ELSE
pairs((fnds - 1) * 2 + 2) = dst
pos = fnds
END IF
IF (src /= dst) THEN
IF (fndd == 0) THEN
pairs((numpairs * 2 + 1):(numpairs * 2 + 2)) = (/dst,src/)
numpairs = numpairs + 1
pos = numpairs
ELSE
pairs((fndd - 1) * 2 + 2) = src
pos = fndd
END IF
END IF
IF (i /= pos) THEN
src = pairs((i - 1) * 2 + 1)
dst = pairs((i - 1) * 2 + 2)
pairs(((i - 1) * 2 + 1):((i - 1) * 2 + 2)) = pairs(((pos - 1) * 2 + 1):(&
(pos - 1) * 2 + 2))
pairs(((pos - 1) * 2 + 1):((pos - 1) * 2 + 2)) = (/src,dst/)
END IF
END DO
!         compute the locations in a and u where rows should be placed
ii = 1
len2 = 0
DO i = 1, numpairs
src = pairs((i - 1) * 2 + 1)
srcprow = (src - 1) / blksize
srcprow = mod(srcprow,nprow)
len2(srcprow + 1) = len2(srcprow + 1) + 1
IF (myrow == srcprow) THEN
srcloc = localsize(src,0,blksize,nprow,myrow)
aloc(ii) = srcloc - iloc
dst = pairs((i - 1) * 2 + 2)
IF (myrow == rproc) THEN
dstprow = (dst - 1) / blksize
dstprow = mod(dstprow,nprow)
IF (dstprow == rproc) THEN
uloc(ii) = dst - panelinfo(1)
IF (dst - panelinfo(1) >= blksize) THEN
dstloc = localsize(dst,0,blksize,nprow,myrow)
uloc(ii) = iloc - dstloc
END IF
ELSE
fndd = 0
DO j = 1, numpairs
IF (fndd == 0 .AND. dst == pairs((j - 1) * 2 + 1)) fndd = j
END DO
uloc(ii) = pairs((fndd - 1) * 2 + 2) - panelinfo(1)
END IF
ELSE
uloc(ii) = dst - panelinfo(1)
END IF
ii = ii + 1
END IF
END DO
flag = 1
END IF
!       permute rows and broadcast u
w = 0
numrows = len2(myrow + 1)
len1(:) = len2(:)
IF (myrow == rproc) THEN
DO i = 1, numrows
IF (uloc(i) >= 0) THEN
u((uloc(i) + 1):(uloc(i) + (nn - 1) * blksize + 1):blksize) = a(aloc(i)&
 + iloc,(jloc + coldiff):(jloc + coldiff + nn - 1))
END IF
IF (uloc(i) < 0) THEN
a(-uloc(i) + iloc,(jloc + coldiff):(jloc + coldiff + nn - 1)) = a(aloc(i&
) + iloc,(jloc + coldiff):(jloc + coldiff + nn - 1))
END IF
END DO
ELSE
w(1,1:numrows) = uloc(1:numrows)
DO i = 1, numrows
w(2:,i) = a(aloc(i) + iloc,(jloc + coldiff):(jloc + coldiff + nn - 1))
END DO
END IF
IF (myrow == rproc) THEN
len1(myrow + 1) = 0
numrows = 0
END IF
wptr(1) = numrows
mydist = myrow - rproc
IF (mydist < 0) mydist = mydist + nprow
partner = ieor(mydist,rowp2)
CALL barrier(cteam)
IF (nprow - rowp2 /= 0 .AND. partner < nprow) THEN
partner = mod(partner + rproc,nprow)
IF (mydist == 0) THEN
lb = (mloc + blksize + 1) * blksize + 1
ub = (mloc + nloc + blksize + 1) * blksize
IF (p == 1) THEN
mloc_p = panelinfo_1(5)[partner@cteam]
lb_p = (mloc_p + blksize + 1) * blksize + 1
panelbuff_1(lb_p:(lb_p + ub - lb))[partner@cteam] = panelbuff_1(lb:ub)
ELSE
mloc_p = panelinfo_2(5)[partner@cteam]
lb_p = (mloc_p + blksize + 1) * blksize + 1
panelbuff_2(lb_p:(lb_p + ub - lb))[partner@cteam] = panelbuff_2(lb:ub)
END IF
ELSE IF (mydist == rowp2) THEN
w(:,1:(len1(myrow + 1)))[partner@cteam] = w(:,1:(len1(myrow + 1)))
ELSE IF (iand(mydist,rowp2) /= 0) THEN
wlb = wptr(1)[partner@cteam]
w(:,(wlb + 1):(wlb + len1(myrow + 1)))[partner@cteam] = w(:,1:(len1(&
myrow + 1)))
ELSE IF (len1(partner + 1) > 0) THEN
wptr(1) = wptr(1) + len1(partner + 1)
END IF
END IF
CALL barrier(cteam)
partner = ieor(mydist,rowp2)
IF (nprow - rowp2 /= 0 .AND. partner < nprow) THEN
partner = mod(partner + rproc,nprow)
IF (mydist == 0 .AND. len1(partner + 1) > 0) THEN
DO i = 1, len1(partner + 1)
iu = w(1,i) + 1
u(iu:(iu + (nn - 1) * blksize):blksize) = w(2:(nn + 1),i)
END DO
END IF
END IF
DO i = 1, nprow - rowp2 - 1
lessip2 = mod(rproc + i,nprow)
len1(lessip2 + 1) = len1(lessip2 + 1) + len1(mod(lessip2 + rowp2,nprow)&
 + 1)
END DO
mykey = 0
wrows = wptr(1)
IF (mydist < rowp2) mykey = 1
IF (mydist >= rowp2 .AND. nprow - rowp2 /= 0) mykey = 2
CALL team_split(cteam,mykey,myrow,subcteam,mykey,ierr)
IF (mydist < rowp2) THEN
DO i = 1, rowlog2
partner = ieor(mydist,ibset(0,i - 1))
partner = mod(rproc + partner,nprow)
IF (mydist < ibset(0,i) .AND. mydist < ibset(0,i - 1)) THEN
lb = (mloc + blksize + 1) * blksize + 1
ub = (mloc + nloc + blksize + 1) * blksize
IF (p == 1) THEN
mloc_p = panelinfo_1(5)[partner@subcteam]
lb_p = (mloc_p + blksize + 1) * blksize + 1
panelbuff_1(lb_p:(lb_p + ub - lb))[partner@subcteam] = panelbuff_1(lb:ub&
)
ELSE
mloc_p = panelinfo_2(5)[partner@subcteam]
lb_p = (mloc_p + blksize + 1) * blksize + 1
panelbuff_2(lb_p:(lb_p + ub - lb))[partner@subcteam] = panelbuff_2(lb:ub&
)
END IF
w(:,(wrows + 1):(wrows + len1(partner + 1))) = w(:,1:(len1(partner + 1))&
)[partner@subcteam]
ELSE IF (mydist >= ibset(0,i)) THEN
w(:,(wrows + 1):(wrows + len1(partner + 1))) = w(:,1:(len1(partner + 1))&
)[partner@subcteam]
END IF
CALL barrier(subcteam)
IF (mydist < ibset(0,i) .AND. mydist < ibset(0,i - 1)) THEN
DO j = 1, len1(partner + 1)
iu = w(1,wrows + j) + 1
u(iu::blksize) = w(2:,wrows + j)
END DO
END IF
IF (mydist < ibset(0,i) .AND. mydist >= ibset(0,i - 1)) THEN
DO j = 1, numrows
a(aloc(j) + iloc,(jloc + coldiff):(jloc + coldiff + nn - 1)) = u((uloc(j&
) + 1):(uloc(j) + 1 + (nn - 1) * blksize):blksize)
u((uloc(j) + 1):(uloc(j) + 1 + (nn - 1) * blksize):blksize) = w(2:,j)
END DO
DO j = numrows + 1, len1(myrow + 1)
iu = w(1,j) + 1
u(iu:(iu + (nn - 1) * blksize):blksize) = w(2:,j)
END DO
END IF
IF (mydist >= ibset(0,i) .OR. mydist < ibset(0,i - 1)) THEN
wrows = wrows + len1(partner + 1)
END IF
DO j = 0, rowp2 - 1
partner = ieor(j,ibset(0,i - 1))
IF (partner > j) THEN
partner = mod(rproc + partner,nprow)
len1(mod(rproc + j,nprow) + 1) = len1(mod(rproc + j,nprow) + 1) + len1(&
partner + 1)
len1(partner + 1) = len1(mod(rproc + j,nprow) + 1)
END IF
END DO
END DO
ELSE IF (nprow - rowp2 > 1) THEN
CALL team_broadcast(u,0,subcteam)
DO i = 1, numrows
a(aloc(i) + iloc,(jloc + coldiff):) = u((uloc(i) + 1)::blksize)
END DO
END IF
IF (nprow - rowp2 /= 0 .AND. ieor(mydist,rowp2) < nprow) THEN
partner = mod(rproc + ieor(mydist,rowp2),nprow)
IF (iand(mydist,rowp2) == 0) THEN
lb = (mloc + blksize + 1) * blksize + 1
ub = (mloc + nloc + blksize + 1) * blksize
IF (p == 1) THEN
mloc_p = panelinfo_1(5)[partner@cteam]
lb_p = (mloc_p + blksize + 1) * blksize + 1
panelbuff_1(lb_p:(lb_p + ub - lb))[partner@cteam] = panelbuff_1(lb:ub)
ELSE
mloc_p = panelinfo_2(5)[partner@cteam]
lb_p = (mloc_p + blksize + 1) * blksize + 1
panelbuff_2(lb_p:(lb_p + ub - lb))[partner@cteam] = panelbuff_2(lb:ub)
END IF
END IF
END IF
deallocate( wptr )
deallocate( w )
!       update the trailing matrix by matrix multiplication
DO i = 1, nn
DO j = 1, blksize
u(((i - 1) * blksize + j + 1):(i * blksize)) = u(((i - 1) * blksize + j&
 + 1):(i * blksize)) - u((i - 1) * blksize + j) * c(((j - 1) * blksize&
 + j + 1):(j * blksize))
END DO
END DO
IF (myrow == rproc) THEN
DO k = 1, blksize
DO j = jloc, jloc + nn - 1
DO i = iloc + blksize, iloc + mloc - 1
a(i,j + coldiff) = a(i,j + coldiff) - l((k - 1) * mloc + i - iloc + 1)&
 * u((j - jloc) * blksize + k)
END DO
END DO
END DO
jlb = jloc
DO j = jlb, jloc + nn - 1
a(iloc:(iloc + blksize - 1),j + coldiff) = u(((j - jlb) * blksize + 1):(&
(j - jlb + 1) * blksize))
END DO
ELSE
DO k = 1, blksize
DO j = jloc, jloc + nn - 1
DO i = iloc, iloc + mloc - 1
a(i,j + coldiff) = a(i,j + coldiff) - l((k - 1) * mloc + i - iloc + 1)&
 * u((j - jloc) * blksize + k)
END DO
END DO
END DO
END IF
END SUBROUTINE update

