// # 1 "builtin.c"
// # 1 "<built-in>"
// # 1 "<command-line>"
// # 1 "builtin.c"
// # 33 "builtin.c"
// # 1 "zsh.mdh" 1
// # 16 "zsh.mdh"
// # 1 "../config.h" 1
// # 17 "zsh.mdh" 2
// # 1 "zsh_system.h" 1
// # 123 "zsh_system.h"
// # 1 "/usr/include/sys/types.h" 1 3 4
// # 27 "/usr/include/sys/types.h" 3 4
// # 1 "/usr/include/features.h" 1 3 4
// # 329 "/usr/include/features.h" 3 4
// # 1 "/usr/include/sys/cdefs.h" 1 3 4
// # 313 "/usr/include/sys/cdefs.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 314 "/usr/include/sys/cdefs.h" 2 3 4
// # 330 "/usr/include/features.h" 2 3 4
// # 352 "/usr/include/features.h" 3 4
// # 1 "/usr/include/gnu/stubs.h" 1 3 4



// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 5 "/usr/include/gnu/stubs.h" 2 3 4




// # 1 "/usr/include/gnu/stubs-64.h" 1 3 4
// # 10 "/usr/include/gnu/stubs.h" 2 3 4
// # 353 "/usr/include/features.h" 2 3 4
// # 28 "/usr/include/sys/types.h" 2 3 4



// # 1 "/usr/include/bits/types.h" 1 3 4
// # 28 "/usr/include/bits/types.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 29 "/usr/include/bits/types.h" 2 3 4


// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 214 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 3 4
typedef long unsigned int size_t;
// # 32 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
// # 134 "/usr/include/bits/types.h" 3 4
// # 1 "/usr/include/bits/typesizes.h" 1 3 4
// # 135 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
// # 32 "/usr/include/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;




typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
// # 133 "/usr/include/sys/types.h" 3 4
// # 1 "/usr/include/time.h" 1 3 4
// # 59 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



// # 75 "/usr/include/time.h" 3 4


typedef __time_t time_t;



// # 93 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
// # 105 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
// # 134 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
// # 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
// # 217 "/usr/include/sys/types.h" 3 4
// # 1 "/usr/include/endian.h" 1 3 4
// # 37 "/usr/include/endian.h" 3 4
// # 1 "/usr/include/bits/endian.h" 1 3 4
// # 38 "/usr/include/endian.h" 2 3 4
// # 218 "/usr/include/sys/types.h" 2 3 4


// # 1 "/usr/include/sys/select.h" 1 3 4
// # 31 "/usr/include/sys/select.h" 3 4
// # 1 "/usr/include/bits/select.h" 1 3 4
// # 32 "/usr/include/sys/select.h" 2 3 4


// # 1 "/usr/include/bits/sigset.h" 1 3 4
// # 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
// # 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





// # 1 "/usr/include/time.h" 1 3 4
// # 121 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
// # 45 "/usr/include/sys/select.h" 2 3 4

// # 1 "/usr/include/bits/time.h" 1 3 4
// # 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
// # 47 "/usr/include/sys/select.h" 2 3 4
// # 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
// # 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
// # 99 "/usr/include/sys/select.h" 3 4

// # 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
// # 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);



// # 221 "/usr/include/sys/types.h" 2 3 4


// # 1 "/usr/include/sys/sysmacros.h" 1 3 4
// # 29 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern __inline unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern __inline unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern __inline unsigned long long int gnu_dev_makedev (unsigned int __major,
       unsigned int __minor)
     __attribute__ ((__nothrow__));


__extension__ extern __inline unsigned int
__attribute__ ((__nothrow__)) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline unsigned int
__attribute__ ((__nothrow__)) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline unsigned long long int
__attribute__ ((__nothrow__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
// # 224 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
// # 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





// # 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
// # 23 "/usr/include/bits/pthreadtypes.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
// # 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
// # 76 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
// # 101 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;
  } __data;
// # 187 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
// # 271 "/usr/include/sys/types.h" 2 3 4



// # 124 "zsh_system.h" 2



// # 1 "/usr/include/unistd.h" 1 3 4
// # 28 "/usr/include/unistd.h" 3 4

// # 173 "/usr/include/unistd.h" 3 4
// # 1 "/usr/include/bits/posix_opt.h" 1 3 4
// # 174 "/usr/include/unistd.h" 2 3 4



// # 1 "/usr/include/bits/environments.h" 1 3 4
// # 23 "/usr/include/bits/environments.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 24 "/usr/include/bits/environments.h" 2 3 4
// # 178 "/usr/include/unistd.h" 2 3 4
// # 197 "/usr/include/unistd.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 198 "/usr/include/unistd.h" 2 3 4
// # 238 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
// # 258 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;
// # 301 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__));
// # 312 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
// # 343 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) ;
// # 371 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__)) ;
// # 393 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__));
// # 405 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__));






extern int usleep (__useconds_t __useconds);
// # 429 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__)) ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__)) ;
// # 471 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__));






extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__));


extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     __attribute__ ((__nothrow__));




extern int execv (__const char *__path, char *__const __argv[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execle (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execl (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execvp (__const char *__file, char *__const __argv[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int nice (int __inc) __attribute__ ((__nothrow__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





// # 1 "/usr/include/bits/confname.h" 1 3 4
// # 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,


    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

  };
// # 555 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__));




extern __pid_t getpgrp (void) __attribute__ ((__nothrow__));
// # 591 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__));
// # 617 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__));
// # 634 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) __attribute__ ((__nothrow__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__));




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__));




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__));






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__));




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__));




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__));





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__));



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__));






extern __pid_t fork (void) __attribute__ ((__nothrow__));






extern __pid_t vfork (void) __attribute__ ((__nothrow__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__));





extern int ttyslot (void) __attribute__ ((__nothrow__));




extern int link (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
// # 837 "/usr/include/unistd.h" 3 4
// # 1 "/usr/include/getopt.h" 1 3 4
// # 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
// # 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
// # 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__));
// # 838 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__));


extern int revoke (__const char *__file) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) __attribute__ ((__nothrow__));



extern char *getusershell (void) __attribute__ ((__nothrow__));
extern void endusershell (void) __attribute__ ((__nothrow__));
extern void setusershell (void) __attribute__ ((__nothrow__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__)) ;






extern int chroot (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
// # 923 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__));




extern int getpagesize (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__));




extern int truncate (__const char *__file, __off_t __length)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
// # 960 "/usr/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
// # 970 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__)) ;
// # 980 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__)) ;
// # 990 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__));
// # 1011 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__));
// # 1034 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
// # 1044 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
// # 1065 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) __attribute__ ((__nothrow__));
// # 1103 "/usr/include/unistd.h" 3 4

// # 128 "zsh_system.h" 2
// # 137 "zsh_system.h"
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 152 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 3 4
typedef long int ptrdiff_t;
// # 326 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 3 4
typedef int wchar_t;
// # 138 "zsh_system.h" 2


// # 1 "/usr/include/stdio.h" 1 3 4
// # 30 "/usr/include/stdio.h" 3 4




// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 35 "/usr/include/stdio.h" 2 3 4
// # 44 "/usr/include/stdio.h" 3 4


typedef struct _IO_FILE FILE;





// # 62 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
// # 72 "/usr/include/stdio.h" 3 4
// # 1 "/usr/include/libio.h" 1 3 4
// # 32 "/usr/include/libio.h" 3 4
// # 1 "/usr/include/_G_config.h" 1 3 4
// # 14 "/usr/include/_G_config.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 355 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 3 4
typedef unsigned int wint_t;
// # 15 "/usr/include/_G_config.h" 2 3 4
// # 24 "/usr/include/_G_config.h" 3 4
// # 1 "/usr/include/wchar.h" 1 3 4
// # 48 "/usr/include/wchar.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 49 "/usr/include/wchar.h" 2 3 4

// # 1 "/usr/include/bits/wchar.h" 1 3 4
// # 51 "/usr/include/wchar.h" 2 3 4
// # 76 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
// # 25 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
// # 44 "/usr/include/_G_config.h" 3 4
// # 1 "/usr/include/gconv.h" 1 3 4
// # 28 "/usr/include/gconv.h" 3 4
// # 1 "/usr/include/wchar.h" 1 3 4
// # 48 "/usr/include/wchar.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 49 "/usr/include/wchar.h" 2 3 4
// # 29 "/usr/include/gconv.h" 2 3 4


// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 32 "/usr/include/gconv.h" 2 3 4





enum
{
  __GCONV_OK = 0,
  __GCONV_NOCONV,
  __GCONV_NODB,
  __GCONV_NOMEM,

  __GCONV_EMPTY_INPUT,
  __GCONV_FULL_OUTPUT,
  __GCONV_ILLEGAL_INPUT,
  __GCONV_INCOMPLETE_INPUT,

  __GCONV_ILLEGAL_DESCRIPTOR,
  __GCONV_INTERNAL_ERROR
};



enum
{
  __GCONV_IS_LAST = 0x0001,
  __GCONV_IGNORE_ERRORS = 0x0002
};



struct __gconv_step;
struct __gconv_step_data;
struct __gconv_loaded_object;
struct __gconv_trans_data;



typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
       __const unsigned char **, __const unsigned char *,
       unsigned char **, size_t *, int, int);


typedef wint_t (*__gconv_btowc_fct) (struct __gconv_step *, unsigned char);


typedef int (*__gconv_init_fct) (struct __gconv_step *);
typedef void (*__gconv_end_fct) (struct __gconv_step *);



typedef int (*__gconv_trans_fct) (struct __gconv_step *,
      struct __gconv_step_data *, void *,
      __const unsigned char *,
      __const unsigned char **,
      __const unsigned char *, unsigned char **,
      size_t *);


typedef int (*__gconv_trans_context_fct) (void *, __const unsigned char *,
       __const unsigned char *,
       unsigned char *, unsigned char *);


typedef int (*__gconv_trans_query_fct) (__const char *, __const char ***,
     size_t *);


typedef int (*__gconv_trans_init_fct) (void **, const char *);
typedef void (*__gconv_trans_end_fct) (void *);

struct __gconv_trans_data
{

  __gconv_trans_fct __trans_fct;
  __gconv_trans_context_fct __trans_context_fct;
  __gconv_trans_end_fct __trans_end_fct;
  void *__data;
  struct __gconv_trans_data *__next;
};



struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  __const char *__modname;

  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;



  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;


  int __stateful;

  void *__data;
};



struct __gconv_step_data
{
  unsigned char *__outbuf;
  unsigned char *__outbufend;



  int __flags;



  int __invocation_counter;



  int __internal_use;

  __mbstate_t *__statep;
  __mbstate_t __state;



  struct __gconv_trans_data *__trans;
};



typedef struct __gconv_info
{
  size_t __nsteps;
  struct __gconv_step *__steps;
  __extension__ struct __gconv_step_data __data [];
} *__gconv_t;
// # 45 "/usr/include/_G_config.h" 2 3 4
typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;

typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
// # 33 "/usr/include/libio.h" 2 3 4
// # 53 "/usr/include/libio.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stdarg.h" 1 3 4
// # 43 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
// # 54 "/usr/include/libio.h" 2 3 4
// # 167 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
// # 177 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
// # 200 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
// # 268 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
// # 316 "/usr/include/libio.h" 3 4
  __off64_t _offset;
// # 325 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
// # 361 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
extern wint_t __wunderflow (_IO_FILE *);
extern wint_t __wuflow (_IO_FILE *);
extern wint_t __woverflow (_IO_FILE *, wint_t);
// # 451 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__));
// # 481 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__));
// # 73 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
// # 86 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
// # 138 "/usr/include/stdio.h" 3 4
// # 1 "/usr/include/bits/stdio_lim.h" 1 3 4
// # 139 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;









extern int remove (__const char *__filename) __attribute__ ((__nothrow__));

extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__));




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) __attribute__ ((__nothrow__));








extern FILE *tmpfile (void);
// # 181 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void);



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__));





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__));
// # 203 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

// # 228 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
// # 238 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes);




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream);
// # 269 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes);
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream);




extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__));





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__));


extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes) __attribute__ ((__nothrow__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__));






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__));








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));







extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__scanf__, 2, 0)));









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

// # 460 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
// # 471 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

// # 504 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

// # 550 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
// # 566 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;

// # 627 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
// # 638 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

// # 674 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
// # 693 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
// # 716 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;








extern void perror (__const char *__s);






// # 1 "/usr/include/bits/sys_errlist.h" 1 3 4
// # 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
// # 755 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
// # 774 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__));
// # 844 "/usr/include/stdio.h" 3 4

// # 141 "zsh_system.h" 2
// # 1 "/usr/include/ctype.h" 1 3 4
// # 30 "/usr/include/ctype.h" 3 4

// # 48 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
// # 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__const));
// # 96 "/usr/include/ctype.h" 3 4






extern int isalnum (int) __attribute__ ((__nothrow__));
extern int isalpha (int) __attribute__ ((__nothrow__));
extern int iscntrl (int) __attribute__ ((__nothrow__));
extern int isdigit (int) __attribute__ ((__nothrow__));
extern int islower (int) __attribute__ ((__nothrow__));
extern int isgraph (int) __attribute__ ((__nothrow__));
extern int isprint (int) __attribute__ ((__nothrow__));
extern int ispunct (int) __attribute__ ((__nothrow__));
extern int isspace (int) __attribute__ ((__nothrow__));
extern int isupper (int) __attribute__ ((__nothrow__));
extern int isxdigit (int) __attribute__ ((__nothrow__));



extern int tolower (int __c) __attribute__ ((__nothrow__));


extern int toupper (int __c) __attribute__ ((__nothrow__));








extern int isblank (int) __attribute__ ((__nothrow__));






extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__));






extern int isascii (int __c) __attribute__ ((__nothrow__));



extern int toascii (int __c) __attribute__ ((__nothrow__));



extern int _toupper (int) __attribute__ ((__nothrow__));
extern int _tolower (int) __attribute__ ((__nothrow__));
// # 233 "/usr/include/ctype.h" 3 4
// # 1 "/usr/include/xlocale.h" 1 3 4
// # 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;
// # 234 "/usr/include/ctype.h" 2 3 4
// # 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
// # 323 "/usr/include/ctype.h" 3 4

// # 142 "zsh_system.h" 2
// # 1 "/usr/include/sys/stat.h" 1 3 4
// # 37 "/usr/include/sys/stat.h" 3 4
// # 1 "/usr/include/time.h" 1 3 4
// # 38 "/usr/include/sys/stat.h" 2 3 4
// # 103 "/usr/include/sys/stat.h" 3 4


// # 1 "/usr/include/bits/stat.h" 1 3 4
// # 43 "/usr/include/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
// # 88 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
// # 103 "/usr/include/bits/stat.h" 3 4
    long int __unused[3];
// # 112 "/usr/include/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
// # 164 "/usr/include/bits/stat.h" 3 4
    long int __unused[3];



  };
// # 106 "/usr/include/sys/stat.h" 2 3 4
// # 207 "/usr/include/sys/stat.h" 3 4
extern int stat (__const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
// # 226 "/usr/include/sys/stat.h" 3 4
extern int stat64 (__const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, __const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
// # 250 "/usr/include/sys/stat.h" 3 4
extern int fstatat64 (int __fd, __const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));






extern int lstat (__const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
// # 272 "/usr/include/sys/stat.h" 3 4
extern int lstat64 (__const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (__const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (__const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__));





extern int fchmodat (int __fd, __const char *__file, __mode_t mode, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__));



extern int mkdir (__const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, __const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int mknodat (int __fd, __const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern int mkfifo (__const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, __const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
// # 380 "/usr/include/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, __const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, __const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, __const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4)));
// # 413 "/usr/include/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, __const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, __const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, __const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, __const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, __const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 5)));




extern __inline__ int
__attribute__ ((__nothrow__)) stat (__const char *__path, struct stat *__statbuf)
{
  return __xstat (1, __path, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) lstat (__const char *__path, struct stat *__statbuf)
{
  return __lxstat (1, __path, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) fstat (int __fd, struct stat *__statbuf)
{
  return __fxstat (1, __fd, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) fstatat (int __fd, __const char *__filename, struct stat *__statbuf, int __flag)

{
  return __fxstatat (1, __fd, __filename, __statbuf, __flag);
}



extern __inline__ int
__attribute__ ((__nothrow__)) mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
{
  return __xmknod (0, __path, __mode, &__dev);
}



extern __inline__ int
__attribute__ ((__nothrow__)) mknodat (int __fd, __const char *__path, __mode_t __mode, __dev_t __dev)

{
  return __xmknodat (0, __fd, __path, __mode, &__dev);
}





extern __inline__ int
__attribute__ ((__nothrow__)) stat64 (__const char *__path, struct stat64 *__statbuf)
{
  return __xstat64 (1, __path, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) lstat64 (__const char *__path, struct stat64 *__statbuf)
{
  return __lxstat64 (1, __path, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) fstat64 (int __fd, struct stat64 *__statbuf)
{
  return __fxstat64 (1, __fd, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) fstatat64 (int __fd, __const char *__filename, struct stat64 *__statbuf, int __flag)

{
  return __fxstatat64 (1, __fd, __filename, __statbuf, __flag);
}







// # 143 "zsh_system.h" 2
// # 1 "/usr/include/signal.h" 1 3 4
// # 31 "/usr/include/signal.h" 3 4


// # 1 "/usr/include/bits/sigset.h" 1 3 4
// # 103 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
// # 34 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;

// # 58 "/usr/include/signal.h" 3 4
// # 1 "/usr/include/bits/signum.h" 1 3 4
// # 59 "/usr/include/signal.h" 2 3 4
// # 75 "/usr/include/signal.h" 3 4
typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));







extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
// # 104 "/usr/include/signal.h" 3 4





extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));






extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__));




extern int raise (int __sig) __attribute__ ((__nothrow__));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__));




extern void psignal (int __sig, __const char *__s);
// # 153 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
// # 162 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
// # 181 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));
// # 196 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;







// # 1 "/usr/include/time.h" 1 3 4
// # 210 "/usr/include/signal.h" 2 3 4


// # 1 "/usr/include/bits/siginfo.h" 1 3 4
// # 25 "/usr/include/bits/siginfo.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 26 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
// # 51 "/usr/include/bits/siginfo.h" 3 4
typedef struct siginfo
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;
      } _sifields;
  } siginfo_t;
// # 129 "/usr/include/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
// # 273 "/usr/include/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     void *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
// # 213 "/usr/include/signal.h" 2 3 4



extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (__const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (__const sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, __const sigset_t *__left,
        __const sigset_t *__right) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, __const sigset_t *__left,
       __const sigset_t *__right) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3)));




// # 1 "/usr/include/bits/sigaction.h" 1 3 4
// # 25 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
// # 247 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__));






extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (__const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (__const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    __const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     __attribute__ ((__nothrow__));
// # 304 "/usr/include/signal.h" 3 4
extern __const char *__const _sys_siglist[65];
extern __const char *__const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
// # 328 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, __const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__));



// # 1 "/usr/include/bits/sigcontext.h" 1 3 4
// # 26 "/usr/include/bits/sigcontext.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 27 "/usr/include/bits/sigcontext.h" 2 3 4

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
// # 109 "/usr/include/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  unsigned long r8;
  unsigned long r9;
  unsigned long r10;
  unsigned long r11;
  unsigned long r12;
  unsigned long r13;
  unsigned long r14;
  unsigned long r15;
  unsigned long rdi;
  unsigned long rsi;
  unsigned long rbp;
  unsigned long rbx;
  unsigned long rdx;
  unsigned long rax;
  unsigned long rcx;
  unsigned long rsp;
  unsigned long rip;
  unsigned long eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  unsigned long err;
  unsigned long trapno;
  unsigned long oldmask;
  unsigned long cr2;
  struct _fpstate * fpstate;
  unsigned long __reserved1 [8];
};
// # 334 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__));
// # 346 "/usr/include/signal.h" 3 4
extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__));

// # 1 "/usr/include/bits/sigstack.h" 1 3 4
// # 26 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
// # 50 "/usr/include/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
// # 349 "/usr/include/signal.h" 2 3 4


// # 1 "/usr/include/sys/ucontext.h" 1 3 4
// # 23 "/usr/include/sys/ucontext.h" 3 4
// # 1 "/usr/include/signal.h" 1 3 4
// # 24 "/usr/include/sys/ucontext.h" 2 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 25 "/usr/include/sys/ucontext.h" 2 3 4
// # 33 "/usr/include/sys/ucontext.h" 3 4
typedef long int greg_t;





typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t padding[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    unsigned long __reserved1 [8];
} mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
// # 352 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));



extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__));







extern int sighold (int __sig) __attribute__ ((__nothrow__));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__));


extern int sigignore (int __sig) __attribute__ ((__nothrow__));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__));






// # 1 "/usr/include/bits/sigthread.h" 1 3 4
// # 31 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       __const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__));
// # 388 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__));




// # 144 "zsh_system.h" 2
// # 1 "/usr/include/setjmp.h" 1 3 4
// # 28 "/usr/include/setjmp.h" 3 4


// # 1 "/usr/include/bits/setjmp.h" 1 3 4
// # 27 "/usr/include/bits/setjmp.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 28 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
// # 31 "/usr/include/setjmp.h" 2 3 4
// # 1 "/usr/include/bits/sigset.h" 1 3 4
// # 32 "/usr/include/setjmp.h" 2 3 4




typedef struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  } jmp_buf[1];




extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));







extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));




extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
// # 76 "/usr/include/setjmp.h" 3 4




extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
// # 108 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



// # 145 "zsh_system.h" 2


// # 1 "/usr/include/pwd.h" 1 3 4
// # 28 "/usr/include/pwd.h" 3 4





// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 34 "/usr/include/pwd.h" 2 3 4
// # 50 "/usr/include/pwd.h" 3 4
struct passwd
{
  char *pw_name;
  char *pw_passwd;
  __uid_t pw_uid;
  __gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};
// # 73 "/usr/include/pwd.h" 3 4
extern void setpwent (void);





extern void endpwent (void);





extern struct passwd *getpwent (void);
// # 95 "/usr/include/pwd.h" 3 4
extern struct passwd *fgetpwent (FILE *__stream);







extern int putpwent (__const struct passwd *__restrict __p,
       FILE *__restrict __f);






extern struct passwd *getpwuid (__uid_t __uid);





extern struct passwd *getpwnam (__const char *__name);
// # 140 "/usr/include/pwd.h" 3 4
extern int getpwent_r (struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);


extern int getpwuid_r (__uid_t __uid,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);

extern int getpwnam_r (__const char *__restrict __name,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);
// # 164 "/usr/include/pwd.h" 3 4
extern int fgetpwent_r (FILE *__restrict __stream,
   struct passwd *__restrict __resultbuf,
   char *__restrict __buffer, size_t __buflen,
   struct passwd **__restrict __result);
// # 181 "/usr/include/pwd.h" 3 4
extern int getpw (__uid_t __uid, char *__buffer);



// # 148 "zsh_system.h" 2



// # 1 "/usr/include/grp.h" 1 3 4
// # 28 "/usr/include/grp.h" 3 4





// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 34 "/usr/include/grp.h" 2 3 4
// # 43 "/usr/include/grp.h" 3 4
struct group
  {
    char *gr_name;
    char *gr_passwd;
    __gid_t gr_gid;
    char **gr_mem;
  };
// # 63 "/usr/include/grp.h" 3 4
extern void setgrent (void);





extern void endgrent (void);





extern struct group *getgrent (void);
// # 85 "/usr/include/grp.h" 3 4
extern struct group *fgetgrent (FILE *__stream);
// # 95 "/usr/include/grp.h" 3 4
extern int putgrent (__const struct group *__restrict __p,
       FILE *__restrict __f);






extern struct group *getgrgid (__gid_t __gid);





extern struct group *getgrnam (__const char *__name);
// # 133 "/usr/include/grp.h" 3 4
extern int getgrent_r (struct group *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct group **__restrict __result);






extern int getgrgid_r (__gid_t __gid, struct group *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct group **__restrict __result);





extern int getgrnam_r (__const char *__restrict __name,
         struct group *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct group **__restrict __result);
// # 163 "/usr/include/grp.h" 3 4
extern int fgetgrent_r (FILE *__restrict __stream,
   struct group *__restrict __resultbuf,
   char *__restrict __buffer, size_t __buflen,
   struct group **__restrict __result);
// # 175 "/usr/include/grp.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 176 "/usr/include/grp.h" 2 3 4


extern int setgroups (size_t __n, __const __gid_t *__groups) __attribute__ ((__nothrow__));
// # 188 "/usr/include/grp.h" 3 4
extern int getgrouplist (__const char *__user, __gid_t __group,
    __gid_t *__groups, int *__ngroups);
// # 199 "/usr/include/grp.h" 3 4
extern int initgroups (__const char *__user, __gid_t __group);




// # 152 "zsh_system.h" 2



// # 1 "/usr/include/dirent.h" 1 3 4
// # 28 "/usr/include/dirent.h" 3 4

// # 62 "/usr/include/dirent.h" 3 4
// # 1 "/usr/include/bits/dirent.h" 1 3 4
// # 23 "/usr/include/bits/dirent.h" 3 4
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };


struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
// # 63 "/usr/include/dirent.h" 2 3 4
// # 98 "/usr/include/dirent.h" 3 4
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };
// # 128 "/usr/include/dirent.h" 3 4
typedef struct __dirstream DIR;






extern DIR *opendir (__const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
// # 163 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
// # 174 "/usr/include/dirent.h" 3 4
extern struct dirent64 *readdir64 (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
// # 184 "/usr/include/dirent.h" 3 4
extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));
// # 201 "/usr/include/dirent.h" 3 4
extern int readdir64_r (DIR *__restrict __dirp,
   struct dirent64 *__restrict __entry,
   struct dirent64 **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







// # 1 "/usr/include/bits/posix1_lim.h" 1 3 4
// # 153 "/usr/include/bits/posix1_lim.h" 3 4
// # 1 "/usr/include/bits/local_lim.h" 1 3 4
// # 36 "/usr/include/bits/local_lim.h" 3 4
// # 1 "/usr/include/linux/limits.h" 1 3 4
// # 37 "/usr/include/bits/local_lim.h" 2 3 4
// # 154 "/usr/include/bits/posix1_lim.h" 2 3 4
// # 233 "/usr/include/dirent.h" 2 3 4
// # 243 "/usr/include/dirent.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 244 "/usr/include/dirent.h" 2 3 4






extern int scandir (__const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (__const struct dirent *),
      int (*__cmp) (__const void *, __const void *))
     __attribute__ ((__nonnull__ (1, 2)));
// # 271 "/usr/include/dirent.h" 3 4
extern int scandir64 (__const char *__restrict __dir,
        struct dirent64 ***__restrict __namelist,
        int (*__selector) (__const struct dirent64 *),
        int (*__cmp) (__const void *, __const void *))
     __attribute__ ((__nonnull__ (1, 2)));




extern int alphasort (__const void *__e1, __const void *__e2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
// # 293 "/usr/include/dirent.h" 3 4
extern int alphasort64 (__const void *__e1, __const void *__e2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int versionsort (__const void *__e1, __const void *__e2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
// # 314 "/usr/include/dirent.h" 3 4
extern int versionsort64 (__const void *__e1, __const void *__e2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
// # 324 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));
// # 341 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
      size_t __nbytes,
      __off64_t *__restrict __basep)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));





// # 156 "zsh_system.h" 2
// # 183 "zsh_system.h"
// # 1 "/usr/include/stdlib.h" 1 3 4
// # 33 "/usr/include/stdlib.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 34 "/usr/include/stdlib.h" 2 3 4








// # 1 "/usr/include/bits/waitflags.h" 1 3 4
// # 43 "/usr/include/stdlib.h" 2 3 4
// # 1 "/usr/include/bits/waitstatus.h" 1 3 4
// # 67 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
// # 44 "/usr/include/stdlib.h" 2 3 4
// # 68 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
// # 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


// # 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__)) ;




extern double atof (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

// # 240 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;






extern double __strtod_internal (__const char *__restrict __nptr,
     char **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern float __strtof_internal (__const char *__restrict __nptr,
    char **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern long double __strtold_internal (__const char *__restrict __nptr,
           char **__restrict __endptr,
           int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern long int __strtol_internal (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern unsigned long int __strtoul_internal (__const char *__restrict __nptr,
          char **__restrict __endptr,
          int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int __strtoll_internal (__const char *__restrict __nptr,
      char **__restrict __endptr,
      int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



__extension__
extern unsigned long long int __strtoull_internal (__const char *
         __restrict __nptr,
         char **__restrict __endptr,
         int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
// # 429 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__)) ;


extern long int a64l (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
// # 445 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__));







extern double drand48 (void) __attribute__ ((__nothrow__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;







extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__));



// # 1 "/usr/include/alloca.h" 1 3 4
// # 25 "/usr/include/alloca.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 26 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__));






// # 613 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));






extern void _Exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__));






extern int clearenv (void) __attribute__ ((__nothrow__));
// # 698 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
// # 709 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
// # 719 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
// # 729 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;








extern int system (__const char *__command) ;







extern char *canonicalize_file_name (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
// # 756 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__)) ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;






extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));



extern int abs (int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;

// # 821 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__)) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__));

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__));








extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
// # 909 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
// # 977 "/usr/include/stdlib.h" 3 4

// # 184 "zsh_system.h" 2
// # 199 "zsh_system.h"
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stdarg.h" 1 3 4
// # 200 "zsh_system.h" 2
// # 231 "zsh_system.h"
// # 1 "/usr/include/errno.h" 1 3 4
// # 32 "/usr/include/errno.h" 3 4




// # 1 "/usr/include/bits/errno.h" 1 3 4
// # 25 "/usr/include/bits/errno.h" 3 4
// # 1 "/usr/include/linux/errno.h" 1 3 4



// # 1 "/usr/include/asm/errno.h" 1 3 4




// # 1 "/usr/include/asm-x86_64/errno.h" 1 3 4



// # 1 "/usr/include/asm-generic/errno.h" 1 3 4



// # 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
// # 5 "/usr/include/asm-generic/errno.h" 2 3 4
// # 5 "/usr/include/asm-x86_64/errno.h" 2 3 4
// # 6 "/usr/include/asm/errno.h" 2 3 4
// # 5 "/usr/include/linux/errno.h" 2 3 4
// # 26 "/usr/include/bits/errno.h" 2 3 4
// # 43 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
// # 37 "/usr/include/errno.h" 2 3 4
// # 55 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;




// # 69 "/usr/include/errno.h" 3 4
typedef int error_t;
// # 232 "zsh_system.h" 2



// # 1 "/usr/include/sys/time.h" 1 3 4
// # 27 "/usr/include/sys/time.h" 3 4
// # 1 "/usr/include/time.h" 1 3 4
// # 28 "/usr/include/sys/time.h" 2 3 4

// # 1 "/usr/include/bits/time.h" 1 3 4
// # 30 "/usr/include/sys/time.h" 2 3 4
// # 39 "/usr/include/sys/time.h" 3 4

// # 57 "/usr/include/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
// # 73 "/usr/include/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int settimeofday (__const struct timeval *__tv,
    __const struct timezone *__tz)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int adjtime (__const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;






extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__));




extern int setitimer (__itimer_which_t __which,
        __const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__));




extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, __const struct timeval __tvp[2]) __attribute__ ((__nothrow__));






extern int futimesat (int __fd, __const char *__file,
        __const struct timeval __tvp[2]) __attribute__ ((__nothrow__));
// # 191 "/usr/include/sys/time.h" 3 4

// # 236 "zsh_system.h" 2
// # 1 "/usr/include/time.h" 1 3 4
// # 31 "/usr/include/time.h" 3 4








// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 40 "/usr/include/time.h" 2 3 4



// # 1 "/usr/include/bits/time.h" 1 3 4
// # 44 "/usr/include/time.h" 2 3 4
// # 132 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
// # 181 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__));





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__));







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__));

extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__));






extern struct tm *gmtime (__const time_t *__timer) __attribute__ ((__nothrow__));



extern struct tm *localtime (__const time_t *__timer) __attribute__ ((__nothrow__));





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__));



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__));





extern char *asctime (__const struct tm *__tp) __attribute__ ((__nothrow__));


extern char *ctime (__const time_t *__timer) __attribute__ ((__nothrow__));







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__));


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__));



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) __attribute__ ((__nothrow__));
// # 312 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__));


extern int dysize (int __year) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
// # 327 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__));


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     __attribute__ ((__nothrow__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__));


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__));
// # 389 "/usr/include/time.h" 3 4
extern int getdate_err;
// # 398 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
// # 412 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);



// # 237 "zsh_system.h" 2
// # 267 "zsh_system.h"
// # 1 "/usr/include/sys/times.h" 1 3 4
// # 32 "/usr/include/sys/times.h" 3 4



struct tms
  {
    clock_t tms_utime;
    clock_t tms_stime;

    clock_t tms_cutime;
    clock_t tms_cstime;
  };






extern clock_t times (struct tms *__buffer) __attribute__ ((__nothrow__));


// # 268 "zsh_system.h" 2



// # 1 "/usr/include/string.h" 1 3 4
// # 28 "/usr/include/string.h" 3 4





// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern void *rawmemchr (__const void *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern void *memrchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

// # 121 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
// # 165 "/usr/include/string.h" 3 4


extern char *strchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern char *strrchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strchrnul (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (__const char *__s, __const char *__reject)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strpbrk (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strstr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));




extern char *strcasestr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__));

// # 281 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *index (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *rindex (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));



extern int ffs (int __i) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strsignal (int __sig) __attribute__ ((__nothrow__));


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern char *basename (__const char *__filename) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
// # 426 "/usr/include/string.h" 3 4

// # 272 "zsh_system.h" 2
// # 282 "zsh_system.h"
// # 1 "/usr/include/locale.h" 1 3 4
// # 29 "/usr/include/locale.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 30 "/usr/include/locale.h" 2 3 4
// # 1 "/usr/include/bits/locale.h" 1 3 4
// # 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
// # 31 "/usr/include/locale.h" 2 3 4


// # 52 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
// # 119 "/usr/include/locale.h" 3 4
};





extern char *setlocale (int __category, __const char *__locale) __attribute__ ((__nothrow__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__));


// # 148 "/usr/include/locale.h" 3 4
typedef __locale_t locale_t;





extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) __attribute__ ((__nothrow__));
// # 189 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) __attribute__ ((__nothrow__));



extern void freelocale (__locale_t __dataset) __attribute__ ((__nothrow__));






extern __locale_t uselocale (__locale_t __dataset) __attribute__ ((__nothrow__));








// # 283 "zsh_system.h" 2



// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/limits.h" 1 3 4
// # 11 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/limits.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/syslimits.h" 1 3 4






// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/limits.h" 1 3 4
// # 122 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/limits.h" 3 4
// # 1 "/usr/include/limits.h" 1 3 4
// # 149 "/usr/include/limits.h" 3 4
// # 1 "/usr/include/bits/posix2_lim.h" 1 3 4
// # 150 "/usr/include/limits.h" 2 3 4



// # 1 "/usr/include/bits/xopen_lim.h" 1 3 4
// # 34 "/usr/include/bits/xopen_lim.h" 3 4
// # 1 "/usr/include/bits/stdio_lim.h" 1 3 4
// # 35 "/usr/include/bits/xopen_lim.h" 2 3 4
// # 154 "/usr/include/limits.h" 2 3 4
// # 123 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/limits.h" 2 3 4
// # 8 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/syslimits.h" 2 3 4
// # 12 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/limits.h" 2 3 4
// # 287 "zsh_system.h" 2
// # 329 "zsh_system.h"
// # 1 "/usr/include/fcntl.h" 1 3 4
// # 30 "/usr/include/fcntl.h" 3 4




// # 1 "/usr/include/bits/fcntl.h" 1 3 4
// # 25 "/usr/include/bits/fcntl.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 26 "/usr/include/bits/fcntl.h" 2 3 4

// # 1 "/usr/include/bits/uio.h" 1 3 4
// # 44 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
// # 28 "/usr/include/bits/fcntl.h" 2 3 4
// # 155 "/usr/include/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };
// # 222 "/usr/include/bits/fcntl.h" 3 4





extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__));



extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
       unsigned int __flags);



extern int vmsplice (int __fdout, const struct iovec *__iov, size_t __count,
       unsigned int __flags);


extern int splice (int __fdin, __off64_t *__offin, int __fdout,
     __off64_t *__offout, size_t __len, unsigned int __flags)
    __attribute__ ((__nothrow__));


extern int tee (int __fdin, int __fdout, size_t __len, unsigned int __flags)
    __attribute__ ((__nothrow__));




// # 35 "/usr/include/fcntl.h" 2 3 4
// # 76 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
// # 85 "/usr/include/fcntl.h" 3 4
extern int open (__const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
// # 95 "/usr/include/fcntl.h" 3 4
extern int open64 (__const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
// # 109 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, __const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
// # 120 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, __const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
// # 130 "/usr/include/fcntl.h" 3 4
extern int creat (__const char *__file, __mode_t __mode) __attribute__ ((__nonnull__ (1)));
// # 140 "/usr/include/fcntl.h" 3 4
extern int creat64 (__const char *__file, __mode_t __mode) __attribute__ ((__nonnull__ (1)));
// # 176 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off_t __offset, __off_t __len,
     int __advise) __attribute__ ((__nothrow__));
// # 188 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, __off64_t __offset, __off64_t __len,
       int __advise) __attribute__ ((__nothrow__));
// # 198 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off_t __offset, __off_t __len);
// # 209 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, __off64_t __offset, __off64_t __len);




// # 330 "zsh_system.h" 2
// # 341 "zsh_system.h"
// # 1 "/usr/include/sys/wait.h" 1 3 4
// # 29 "/usr/include/sys/wait.h" 3 4



// # 1 "/usr/include/sys/resource.h" 1 3 4
// # 25 "/usr/include/sys/resource.h" 3 4
// # 1 "/usr/include/bits/resource.h" 1 3 4
// # 33 "/usr/include/bits/resource.h" 3 4
enum __rlimit_resource
{

  RLIMIT_CPU = 0,



  RLIMIT_FSIZE = 1,



  RLIMIT_DATA = 2,



  RLIMIT_STACK = 3,



  RLIMIT_CORE = 4,






  __RLIMIT_RSS = 5,



  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,




  RLIMIT_AS = 9,



  __RLIMIT_NPROC = 6,



  __RLIMIT_MEMLOCK = 8,



  __RLIMIT_LOCKS = 10,



  __RLIMIT_SIGPENDING = 11,



  __RLIMIT_MSGQUEUE = 12,





  __RLIMIT_NICE = 13,




  __RLIMIT_RTPRIO = 14,


  __RLIMIT_NLIMITS = 15,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};
// # 127 "/usr/include/bits/resource.h" 3 4
typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,



  RUSAGE_CHILDREN = -1,




  RUSAGE_THREAD = 1




};


// # 1 "/usr/include/bits/time.h" 1 3 4
// # 175 "/usr/include/bits/resource.h" 2 3 4


struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    long int ru_maxrss;


    long int ru_ixrss;

    long int ru_idrss;

    long int ru_isrss;


    long int ru_minflt;

    long int ru_majflt;

    long int ru_nswap;


    long int ru_inblock;

    long int ru_oublock;

    long int ru_msgsnd;

    long int ru_msgrcv;

    long int ru_nsignals;



    long int ru_nvcsw;


    long int ru_nivcsw;
  };







enum __priority_which
{
  PRIO_PROCESS = 0,

  PRIO_PGRP = 1,

  PRIO_USER = 2

};
// # 26 "/usr/include/sys/resource.h" 2 3 4













typedef enum __rlimit_resource __rlimit_resource_t;
typedef enum __rusage_who __rusage_who_t;
typedef enum __priority_which __priority_which_t;
// # 51 "/usr/include/sys/resource.h" 3 4
extern int getrlimit (__rlimit_resource_t __resource,
        struct rlimit *__rlimits) __attribute__ ((__nothrow__));
// # 62 "/usr/include/sys/resource.h" 3 4
extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) __attribute__ ((__nothrow__));






extern int setrlimit (__rlimit_resource_t __resource,
        __const struct rlimit *__rlimits) __attribute__ ((__nothrow__));
// # 82 "/usr/include/sys/resource.h" 3 4
extern int setrlimit64 (__rlimit_resource_t __resource,
   __const struct rlimit64 *__rlimits) __attribute__ ((__nothrow__));




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) __attribute__ ((__nothrow__));





extern int getpriority (__priority_which_t __which, id_t __who) __attribute__ ((__nothrow__));



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     __attribute__ ((__nothrow__));


// # 33 "/usr/include/sys/wait.h" 2 3 4
// # 102 "/usr/include/sys/wait.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
// # 116 "/usr/include/sys/wait.h" 3 4
extern __pid_t wait (__WAIT_STATUS __stat_loc);
// # 139 "/usr/include/sys/wait.h" 3 4
extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options);



// # 1 "/usr/include/bits/siginfo.h" 1 3 4
// # 25 "/usr/include/bits/siginfo.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 26 "/usr/include/bits/siginfo.h" 2 3 4
// # 144 "/usr/include/sys/wait.h" 2 3 4
// # 155 "/usr/include/sys/wait.h" 3 4
extern int waitid (idtype_t __idtype, __id_t __id, siginfo_t *__infop,
     int __options);





struct rusage;






extern __pid_t wait3 (__WAIT_STATUS __stat_loc, int __options,
        struct rusage * __usage) __attribute__ ((__nothrow__));





struct rusage;


extern __pid_t wait4 (__pid_t __pid, __WAIT_STATUS __stat_loc, int __options,
        struct rusage *__usage) __attribute__ ((__nothrow__));




// # 342 "zsh_system.h" 2
// # 402 "zsh_system.h"
// # 1 "/usr/include/termios.h" 1 3 4
// # 36 "/usr/include/termios.h" 3 4




// # 1 "/usr/include/bits/termios.h" 1 3 4
// # 25 "/usr/include/bits/termios.h" 3 4
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;


struct termios
  {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;


  };
// # 41 "/usr/include/termios.h" 2 3 4
// # 49 "/usr/include/termios.h" 3 4
extern speed_t cfgetospeed (__const struct termios *__termios_p) __attribute__ ((__nothrow__));


extern speed_t cfgetispeed (__const struct termios *__termios_p) __attribute__ ((__nothrow__));


extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__));


extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__));



extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__));




extern int tcgetattr (int __fd, struct termios *__termios_p) __attribute__ ((__nothrow__));



extern int tcsetattr (int __fd, int __optional_actions,
        __const struct termios *__termios_p) __attribute__ ((__nothrow__));




extern void cfmakeraw (struct termios *__termios_p) __attribute__ ((__nothrow__));



extern int tcsendbreak (int __fd, int __duration) __attribute__ ((__nothrow__));





extern int tcdrain (int __fd);



extern int tcflush (int __fd, int __queue_selector) __attribute__ ((__nothrow__));



extern int tcflow (int __fd, int __action) __attribute__ ((__nothrow__));




extern __pid_t tcgetsid (int __fd) __attribute__ ((__nothrow__));




// # 1 "/usr/include/sys/ttydefaults.h" 1 3 4
// # 106 "/usr/include/termios.h" 2 3 4



// # 403 "zsh_system.h" 2
// # 421 "zsh_system.h"
// # 1 "/usr/include/sys/ioctl.h" 1 3 4
// # 24 "/usr/include/sys/ioctl.h" 3 4



// # 1 "/usr/include/bits/ioctls.h" 1 3 4
// # 24 "/usr/include/bits/ioctls.h" 3 4
// # 1 "/usr/include/asm/ioctls.h" 1 3 4




// # 1 "/usr/include/asm-x86_64/ioctls.h" 1 3 4



// # 1 "/usr/include/asm/ioctl.h" 1 3 4




// # 1 "/usr/include/asm-x86_64/ioctl.h" 1 3 4
// # 1 "/usr/include/asm-generic/ioctl.h" 1 3 4
// # 1 "/usr/include/asm-x86_64/ioctl.h" 2 3 4
// # 6 "/usr/include/asm/ioctl.h" 2 3 4
// # 5 "/usr/include/asm-x86_64/ioctls.h" 2 3 4
// # 6 "/usr/include/asm/ioctls.h" 2 3 4
// # 25 "/usr/include/bits/ioctls.h" 2 3 4
// # 28 "/usr/include/sys/ioctl.h" 2 3 4


// # 1 "/usr/include/bits/ioctl-types.h" 1 3 4
// # 28 "/usr/include/bits/ioctl-types.h" 3 4
struct winsize
  {
    unsigned short int ws_row;
    unsigned short int ws_col;
    unsigned short int ws_xpixel;
    unsigned short int ws_ypixel;
  };


struct termio
  {
    unsigned short int c_iflag;
    unsigned short int c_oflag;
    unsigned short int c_cflag;
    unsigned short int c_lflag;
    unsigned char c_line;
    unsigned char c_cc[8];
};
// # 31 "/usr/include/sys/ioctl.h" 2 3 4






// # 1 "/usr/include/sys/ttydefaults.h" 1 3 4
// # 38 "/usr/include/sys/ioctl.h" 2 3 4




extern int ioctl (int __fd, unsigned long int __request, ...) __attribute__ ((__nothrow__));


// # 422 "zsh_system.h" 2







// # 1 "/usr/include/sys/param.h" 1 3 4
// # 22 "/usr/include/sys/param.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/limits.h" 1 3 4
// # 23 "/usr/include/sys/param.h" 2 3 4

// # 1 "/usr/include/linux/param.h" 1 3 4



// # 1 "/usr/include/asm/param.h" 1 3 4




// # 1 "/usr/include/asm-x86_64/param.h" 1 3 4
// # 6 "/usr/include/asm/param.h" 2 3 4
// # 5 "/usr/include/linux/param.h" 2 3 4
// # 25 "/usr/include/sys/param.h" 2 3 4
// # 430 "zsh_system.h" 2



// # 1 "/usr/include/sys/utsname.h" 1 3 4
// # 28 "/usr/include/sys/utsname.h" 3 4


// # 1 "/usr/include/bits/utsname.h" 1 3 4
// # 31 "/usr/include/sys/utsname.h" 2 3 4
// # 49 "/usr/include/sys/utsname.h" 3 4
struct utsname
  {

    char sysname[65];


    char nodename[65];


    char release[65];

    char version[65];


    char machine[65];




    char domainname[65];




  };
// # 82 "/usr/include/sys/utsname.h" 3 4
extern int uname (struct utsname *__name) __attribute__ ((__nothrow__));



// # 434 "zsh_system.h" 2
// # 510 "zsh_system.h"
// # 1 "/usr/include/sys/capability.h" 1 3 4
// # 24 "/usr/include/sys/capability.h" 3 4
// # 1 "/usr/include/stdint.h" 1 3 4
// # 28 "/usr/include/stdint.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 29 "/usr/include/stdint.h" 2 3 4
// # 49 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
// # 66 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
// # 91 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
// # 104 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
// # 123 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
// # 135 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
// # 25 "/usr/include/sys/capability.h" 2 3 4







typedef unsigned int __u32;

// # 1 "/usr/include/linux/capability.h" 1 3 4
// # 16 "/usr/include/linux/capability.h" 3 4
// # 1 "/usr/include/linux/types.h" 1 3 4
// # 17 "/usr/include/linux/capability.h" 2 3 4
// # 31 "/usr/include/linux/capability.h" 3 4
typedef struct __user_cap_header_struct {
 __u32 version;
 int pid;
} *cap_user_header_t;

typedef struct __user_cap_data_struct {
        __u32 effective;
        __u32 permitted;
        __u32 inheritable;
} *cap_user_data_t;
// # 35 "/usr/include/sys/capability.h" 2 3 4
// # 44 "/usr/include/sys/capability.h" 3 4
typedef struct _cap_struct *cap_t;







typedef int cap_value_t;




typedef enum {
    CAP_EFFECTIVE=0,
    CAP_PERMITTED=1,
    CAP_INHERITABLE=2
} cap_flag_t;




typedef enum {
    CAP_CLEAR=0,
    CAP_SET=1
} cap_flag_value_t;






cap_t cap_dup(cap_t);
int cap_free(void *);
cap_t cap_init(void);


int cap_get_flag(cap_t, cap_value_t, cap_flag_t, cap_flag_value_t *);
int cap_set_flag(cap_t, cap_flag_t, int, cap_value_t *, cap_flag_value_t);
int cap_clear(cap_t);


cap_t cap_get_fd(int);
cap_t cap_get_file(const char *);
int cap_set_fd(int, cap_t);
int cap_set_file(const char *, cap_t);


cap_t cap_get_proc(void);
int cap_set_proc(cap_t);


ssize_t cap_size(cap_t);
ssize_t cap_copy_ext(void *, cap_t, ssize_t);
cap_t cap_copy_int(const void *);


cap_t cap_from_text(const char *);
char * cap_to_text(cap_t, ssize_t *);
// # 511 "zsh_system.h" 2
// # 718 "zsh_system.h"
extern char **environ;
// # 798 "zsh_system.h"
// # 1 "/usr/include/wchar.h" 1 3 4
// # 48 "/usr/include/wchar.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 49 "/usr/include/wchar.h" 2 3 4
// # 93 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



// # 118 "/usr/include/wchar.h" 3 4





struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) __attribute__ ((__nothrow__));

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) __attribute__ ((__nothrow__));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__));


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) __attribute__ ((__nothrow__));


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) __attribute__ ((__nothrow__));





extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) __attribute__ ((__nothrow__));

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) __attribute__ ((__nothrow__));





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) __attribute__ ((__nothrow__));



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__));








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) __attribute__ ((__nothrow__));




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) __attribute__ ((__nothrow__));


extern wchar_t *wcsdup (__const wchar_t *__s) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));




extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));





extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));


extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) __attribute__ ((__nothrow__));


extern size_t wcslen (__const wchar_t *__s) __attribute__ ((__nothrow__)) __attribute__ ((__pure__));




extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));




extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));





extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));


extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__));



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__));


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __attribute__ ((__nothrow__));





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     __attribute__ ((__nothrow__));






extern wint_t btowc (int __c) __attribute__ ((__nothrow__));



extern int wctob (wint_t __c) __attribute__ ((__nothrow__));



extern int mbsinit (__const mbstate_t *__ps) __attribute__ ((__nothrow__)) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) __attribute__ ((__nothrow__));


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));

// # 348 "/usr/include/wchar.h" 3 4



extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));






extern int wcwidth (wchar_t __c) __attribute__ ((__nothrow__));



extern int wcswidth (__const wchar_t *__s, size_t __n) __attribute__ ((__nothrow__));






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) __attribute__ ((__nothrow__));



extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__));
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__));





extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) __attribute__ ((__nothrow__));



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__));




__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__));



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) __attribute__ ((__nothrow__));






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__));



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) __attribute__ ((__nothrow__));
// # 467 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__));

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) __attribute__ ((__nothrow__));

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) __attribute__ ((__nothrow__));

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__));

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__));

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__));

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) __attribute__ ((__nothrow__));





extern double __wcstod_internal (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__));
extern float __wcstof_internal (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__));
extern long double __wcstold_internal (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __group) __attribute__ ((__nothrow__));
// # 593 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__dest, __const wchar_t *__src) __attribute__ ((__nothrow__));



extern wchar_t *wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n)
     __attribute__ ((__nothrow__));
// # 607 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__));






extern int fwide (__FILE *__fp, int __mode) __attribute__ ((__nothrow__));






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__)) ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__)) ;











extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) ;










extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

// # 768 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
// # 794 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
// # 804 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__));







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__));
// # 858 "/usr/include/wchar.h" 3 4

// # 799 "zsh_system.h" 2
// # 1 "/usr/include/wctype.h" 1 3 4
// # 35 "/usr/include/wctype.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 36 "/usr/include/wctype.h" 2 3 4
// # 45 "/usr/include/wctype.h" 3 4

// # 63 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

// # 85 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};












extern int iswalnum (wint_t __wc) __attribute__ ((__nothrow__));





extern int iswalpha (wint_t __wc) __attribute__ ((__nothrow__));


extern int iswcntrl (wint_t __wc) __attribute__ ((__nothrow__));



extern int iswdigit (wint_t __wc) __attribute__ ((__nothrow__));



extern int iswgraph (wint_t __wc) __attribute__ ((__nothrow__));




extern int iswlower (wint_t __wc) __attribute__ ((__nothrow__));


extern int iswprint (wint_t __wc) __attribute__ ((__nothrow__));




extern int iswpunct (wint_t __wc) __attribute__ ((__nothrow__));




extern int iswspace (wint_t __wc) __attribute__ ((__nothrow__));




extern int iswupper (wint_t __wc) __attribute__ ((__nothrow__));




extern int iswxdigit (wint_t __wc) __attribute__ ((__nothrow__));





extern int iswblank (wint_t __wc) __attribute__ ((__nothrow__));
// # 185 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (__const char *__property) __attribute__ ((__nothrow__));



extern int iswctype (wint_t __wc, wctype_t __desc) __attribute__ ((__nothrow__));










typedef __const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) __attribute__ ((__nothrow__));


extern wint_t towupper (wint_t __wc) __attribute__ ((__nothrow__));



// # 227 "/usr/include/wctype.h" 3 4





extern wctrans_t wctrans (__const char *__property) __attribute__ ((__nothrow__));


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) __attribute__ ((__nothrow__));








extern int iswalnum_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));





extern int iswalpha_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));



extern int iswdigit_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));



extern int iswgraph_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));




extern int iswlower_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));


extern int iswprint_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));




extern int iswpunct_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));




extern int iswspace_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));




extern int iswupper_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));




extern int iswblank_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));



extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     __attribute__ ((__nothrow__));



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     __attribute__ ((__nothrow__));







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__));



extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     __attribute__ ((__nothrow__));


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) __attribute__ ((__nothrow__));




// # 800 "zsh_system.h" 2


// # 1 "/usr/include/langinfo.h" 1 3 4
// # 24 "/usr/include/langinfo.h" 3 4
// # 1 "/usr/include/nl_types.h" 1 3 4
// # 31 "/usr/include/nl_types.h" 3 4



typedef void *nl_catd;


typedef int nl_item;





extern nl_catd catopen (__const char *__cat_name, int __flag) __attribute__ ((__nonnull__ (1)));



extern char *catgets (nl_catd __catalog, int __set, int __number,
        __const char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int catclose (nl_catd __catalog) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


// # 25 "/usr/include/langinfo.h" 2 3 4

// # 1 "/usr/include/bits/locale.h" 1 3 4
// # 27 "/usr/include/langinfo.h" 2 3 4



// # 42 "/usr/include/langinfo.h" 3 4
enum
{



  ABDAY_1 = (((__LC_TIME) << 16) | (0)),

  ABDAY_2,

  ABDAY_3,

  ABDAY_4,

  ABDAY_5,

  ABDAY_6,

  ABDAY_7,



  DAY_1,

  DAY_2,

  DAY_3,

  DAY_4,

  DAY_5,

  DAY_6,

  DAY_7,



  ABMON_1,

  ABMON_2,

  ABMON_3,

  ABMON_4,

  ABMON_5,

  ABMON_6,

  ABMON_7,

  ABMON_8,

  ABMON_9,

  ABMON_10,

  ABMON_11,

  ABMON_12,



  MON_1,

  MON_2,

  MON_3,

  MON_4,

  MON_5,

  MON_6,

  MON_7,

  MON_8,

  MON_9,

  MON_10,

  MON_11,

  MON_12,


  AM_STR,

  PM_STR,


  D_T_FMT,

  D_FMT,

  T_FMT,

  T_FMT_AMPM,


  ERA,

  __ERA_YEAR,



  ERA_D_FMT,

  ALT_DIGITS,

  ERA_D_T_FMT,

  ERA_T_FMT,


  _NL_TIME_ERA_NUM_ENTRIES,
  _NL_TIME_ERA_ENTRIES,

  _NL_WABDAY_1,
  _NL_WABDAY_2,
  _NL_WABDAY_3,
  _NL_WABDAY_4,
  _NL_WABDAY_5,
  _NL_WABDAY_6,
  _NL_WABDAY_7,


  _NL_WDAY_1,
  _NL_WDAY_2,
  _NL_WDAY_3,
  _NL_WDAY_4,
  _NL_WDAY_5,
  _NL_WDAY_6,
  _NL_WDAY_7,


  _NL_WABMON_1,
  _NL_WABMON_2,
  _NL_WABMON_3,
  _NL_WABMON_4,
  _NL_WABMON_5,
  _NL_WABMON_6,
  _NL_WABMON_7,
  _NL_WABMON_8,
  _NL_WABMON_9,
  _NL_WABMON_10,
  _NL_WABMON_11,
  _NL_WABMON_12,


  _NL_WMON_1,
  _NL_WMON_2,
  _NL_WMON_3,
  _NL_WMON_4,
  _NL_WMON_5,
  _NL_WMON_6,
  _NL_WMON_7,
  _NL_WMON_8,
  _NL_WMON_9,
  _NL_WMON_10,
  _NL_WMON_11,
  _NL_WMON_12,

  _NL_WAM_STR,
  _NL_WPM_STR,

  _NL_WD_T_FMT,
  _NL_WD_FMT,
  _NL_WT_FMT,
  _NL_WT_FMT_AMPM,

  _NL_WERA_YEAR,
  _NL_WERA_D_FMT,
  _NL_WALT_DIGITS,
  _NL_WERA_D_T_FMT,
  _NL_WERA_T_FMT,

  _NL_TIME_WEEK_NDAYS,
  _NL_TIME_WEEK_1STDAY,
  _NL_TIME_WEEK_1STWEEK,
  _NL_TIME_FIRST_WEEKDAY,
  _NL_TIME_FIRST_WORKDAY,
  _NL_TIME_CAL_DIRECTION,
  _NL_TIME_TIMEZONE,

  _DATE_FMT,

  _NL_W_DATE_FMT,

  _NL_TIME_CODESET,

  _NL_NUM_LC_TIME,




  _NL_COLLATE_NRULES = (((__LC_COLLATE) << 16) | (0)),
  _NL_COLLATE_RULESETS,
  _NL_COLLATE_TABLEMB,
  _NL_COLLATE_WEIGHTMB,
  _NL_COLLATE_EXTRAMB,
  _NL_COLLATE_INDIRECTMB,
  _NL_COLLATE_GAP1,
  _NL_COLLATE_GAP2,
  _NL_COLLATE_GAP3,
  _NL_COLLATE_TABLEWC,
  _NL_COLLATE_WEIGHTWC,
  _NL_COLLATE_EXTRAWC,
  _NL_COLLATE_INDIRECTWC,
  _NL_COLLATE_SYMB_HASH_SIZEMB,
  _NL_COLLATE_SYMB_TABLEMB,
  _NL_COLLATE_SYMB_EXTRAMB,
  _NL_COLLATE_COLLSEQMB,
  _NL_COLLATE_COLLSEQWC,
  _NL_COLLATE_CODESET,
  _NL_NUM_LC_COLLATE,




  _NL_CTYPE_CLASS = (((__LC_CTYPE) << 16) | (0)),
  _NL_CTYPE_TOUPPER,
  _NL_CTYPE_GAP1,
  _NL_CTYPE_TOLOWER,
  _NL_CTYPE_GAP2,
  _NL_CTYPE_CLASS32,
  _NL_CTYPE_GAP3,
  _NL_CTYPE_GAP4,
  _NL_CTYPE_GAP5,
  _NL_CTYPE_GAP6,
  _NL_CTYPE_CLASS_NAMES,
  _NL_CTYPE_MAP_NAMES,
  _NL_CTYPE_WIDTH,
  _NL_CTYPE_MB_CUR_MAX,
  _NL_CTYPE_CODESET_NAME,
  CODESET = _NL_CTYPE_CODESET_NAME,

  _NL_CTYPE_TOUPPER32,
  _NL_CTYPE_TOLOWER32,
  _NL_CTYPE_CLASS_OFFSET,
  _NL_CTYPE_MAP_OFFSET,
  _NL_CTYPE_INDIGITS_MB_LEN,
  _NL_CTYPE_INDIGITS0_MB,
  _NL_CTYPE_INDIGITS1_MB,
  _NL_CTYPE_INDIGITS2_MB,
  _NL_CTYPE_INDIGITS3_MB,
  _NL_CTYPE_INDIGITS4_MB,
  _NL_CTYPE_INDIGITS5_MB,
  _NL_CTYPE_INDIGITS6_MB,
  _NL_CTYPE_INDIGITS7_MB,
  _NL_CTYPE_INDIGITS8_MB,
  _NL_CTYPE_INDIGITS9_MB,
  _NL_CTYPE_INDIGITS_WC_LEN,
  _NL_CTYPE_INDIGITS0_WC,
  _NL_CTYPE_INDIGITS1_WC,
  _NL_CTYPE_INDIGITS2_WC,
  _NL_CTYPE_INDIGITS3_WC,
  _NL_CTYPE_INDIGITS4_WC,
  _NL_CTYPE_INDIGITS5_WC,
  _NL_CTYPE_INDIGITS6_WC,
  _NL_CTYPE_INDIGITS7_WC,
  _NL_CTYPE_INDIGITS8_WC,
  _NL_CTYPE_INDIGITS9_WC,
  _NL_CTYPE_OUTDIGIT0_MB,
  _NL_CTYPE_OUTDIGIT1_MB,
  _NL_CTYPE_OUTDIGIT2_MB,
  _NL_CTYPE_OUTDIGIT3_MB,
  _NL_CTYPE_OUTDIGIT4_MB,
  _NL_CTYPE_OUTDIGIT5_MB,
  _NL_CTYPE_OUTDIGIT6_MB,
  _NL_CTYPE_OUTDIGIT7_MB,
  _NL_CTYPE_OUTDIGIT8_MB,
  _NL_CTYPE_OUTDIGIT9_MB,
  _NL_CTYPE_OUTDIGIT0_WC,
  _NL_CTYPE_OUTDIGIT1_WC,
  _NL_CTYPE_OUTDIGIT2_WC,
  _NL_CTYPE_OUTDIGIT3_WC,
  _NL_CTYPE_OUTDIGIT4_WC,
  _NL_CTYPE_OUTDIGIT5_WC,
  _NL_CTYPE_OUTDIGIT6_WC,
  _NL_CTYPE_OUTDIGIT7_WC,
  _NL_CTYPE_OUTDIGIT8_WC,
  _NL_CTYPE_OUTDIGIT9_WC,
  _NL_CTYPE_TRANSLIT_TAB_SIZE,
  _NL_CTYPE_TRANSLIT_FROM_IDX,
  _NL_CTYPE_TRANSLIT_FROM_TBL,
  _NL_CTYPE_TRANSLIT_TO_IDX,
  _NL_CTYPE_TRANSLIT_TO_TBL,
  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN,
  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING,
  _NL_CTYPE_TRANSLIT_IGNORE_LEN,
  _NL_CTYPE_TRANSLIT_IGNORE,
  _NL_CTYPE_MAP_TO_NONASCII,
  _NL_CTYPE_EXTRA_MAP_1,
  _NL_CTYPE_EXTRA_MAP_2,
  _NL_CTYPE_EXTRA_MAP_3,
  _NL_CTYPE_EXTRA_MAP_4,
  _NL_CTYPE_EXTRA_MAP_5,
  _NL_CTYPE_EXTRA_MAP_6,
  _NL_CTYPE_EXTRA_MAP_7,
  _NL_CTYPE_EXTRA_MAP_8,
  _NL_CTYPE_EXTRA_MAP_9,
  _NL_CTYPE_EXTRA_MAP_10,
  _NL_CTYPE_EXTRA_MAP_11,
  _NL_CTYPE_EXTRA_MAP_12,
  _NL_CTYPE_EXTRA_MAP_13,
  _NL_CTYPE_EXTRA_MAP_14,
  _NL_NUM_LC_CTYPE,




  __INT_CURR_SYMBOL = (((__LC_MONETARY) << 16) | (0)),



  __CURRENCY_SYMBOL,



  __MON_DECIMAL_POINT,



  __MON_THOUSANDS_SEP,



  __MON_GROUPING,



  __POSITIVE_SIGN,



  __NEGATIVE_SIGN,



  __INT_FRAC_DIGITS,



  __FRAC_DIGITS,



  __P_CS_PRECEDES,



  __P_SEP_BY_SPACE,



  __N_CS_PRECEDES,



  __N_SEP_BY_SPACE,



  __P_SIGN_POSN,



  __N_SIGN_POSN,



  _NL_MONETARY_CRNCYSTR,

  __INT_P_CS_PRECEDES,



  __INT_P_SEP_BY_SPACE,



  __INT_N_CS_PRECEDES,



  __INT_N_SEP_BY_SPACE,



  __INT_P_SIGN_POSN,



  __INT_N_SIGN_POSN,



  _NL_MONETARY_DUO_INT_CURR_SYMBOL,
  _NL_MONETARY_DUO_CURRENCY_SYMBOL,
  _NL_MONETARY_DUO_INT_FRAC_DIGITS,
  _NL_MONETARY_DUO_FRAC_DIGITS,
  _NL_MONETARY_DUO_P_CS_PRECEDES,
  _NL_MONETARY_DUO_P_SEP_BY_SPACE,
  _NL_MONETARY_DUO_N_CS_PRECEDES,
  _NL_MONETARY_DUO_N_SEP_BY_SPACE,
  _NL_MONETARY_DUO_INT_P_CS_PRECEDES,
  _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE,
  _NL_MONETARY_DUO_INT_N_CS_PRECEDES,
  _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE,
  _NL_MONETARY_DUO_P_SIGN_POSN,
  _NL_MONETARY_DUO_N_SIGN_POSN,
  _NL_MONETARY_DUO_INT_P_SIGN_POSN,
  _NL_MONETARY_DUO_INT_N_SIGN_POSN,
  _NL_MONETARY_UNO_VALID_FROM,
  _NL_MONETARY_UNO_VALID_TO,
  _NL_MONETARY_DUO_VALID_FROM,
  _NL_MONETARY_DUO_VALID_TO,
  _NL_MONETARY_CONVERSION_RATE,
  _NL_MONETARY_DECIMAL_POINT_WC,
  _NL_MONETARY_THOUSANDS_SEP_WC,
  _NL_MONETARY_CODESET,
  _NL_NUM_LC_MONETARY,



  __DECIMAL_POINT = (((__LC_NUMERIC) << 16) | (0)),



  RADIXCHAR = __DECIMAL_POINT,

  __THOUSANDS_SEP,



  THOUSEP = __THOUSANDS_SEP,

  __GROUPING,



  _NL_NUMERIC_DECIMAL_POINT_WC,
  _NL_NUMERIC_THOUSANDS_SEP_WC,
  _NL_NUMERIC_CODESET,
  _NL_NUM_LC_NUMERIC,

  __YESEXPR = (((__LC_MESSAGES) << 16) | (0)),

  __NOEXPR,

  __YESSTR,



  __NOSTR,



  _NL_MESSAGES_CODESET,
  _NL_NUM_LC_MESSAGES,

  _NL_PAPER_HEIGHT = (((__LC_PAPER) << 16) | (0)),
  _NL_PAPER_WIDTH,
  _NL_PAPER_CODESET,
  _NL_NUM_LC_PAPER,

  _NL_NAME_NAME_FMT = (((__LC_NAME) << 16) | (0)),
  _NL_NAME_NAME_GEN,
  _NL_NAME_NAME_MR,
  _NL_NAME_NAME_MRS,
  _NL_NAME_NAME_MISS,
  _NL_NAME_NAME_MS,
  _NL_NAME_CODESET,
  _NL_NUM_LC_NAME,

  _NL_ADDRESS_POSTAL_FMT = (((__LC_ADDRESS) << 16) | (0)),
  _NL_ADDRESS_COUNTRY_NAME,
  _NL_ADDRESS_COUNTRY_POST,
  _NL_ADDRESS_COUNTRY_AB2,
  _NL_ADDRESS_COUNTRY_AB3,
  _NL_ADDRESS_COUNTRY_CAR,
  _NL_ADDRESS_COUNTRY_NUM,
  _NL_ADDRESS_COUNTRY_ISBN,
  _NL_ADDRESS_LANG_NAME,
  _NL_ADDRESS_LANG_AB,
  _NL_ADDRESS_LANG_TERM,
  _NL_ADDRESS_LANG_LIB,
  _NL_ADDRESS_CODESET,
  _NL_NUM_LC_ADDRESS,

  _NL_TELEPHONE_TEL_INT_FMT = (((__LC_TELEPHONE) << 16) | (0)),
  _NL_TELEPHONE_TEL_DOM_FMT,
  _NL_TELEPHONE_INT_SELECT,
  _NL_TELEPHONE_INT_PREFIX,
  _NL_TELEPHONE_CODESET,
  _NL_NUM_LC_TELEPHONE,

  _NL_MEASUREMENT_MEASUREMENT = (((__LC_MEASUREMENT) << 16) | (0)),
  _NL_MEASUREMENT_CODESET,
  _NL_NUM_LC_MEASUREMENT,

  _NL_IDENTIFICATION_TITLE = (((__LC_IDENTIFICATION) << 16) | (0)),
  _NL_IDENTIFICATION_SOURCE,
  _NL_IDENTIFICATION_ADDRESS,
  _NL_IDENTIFICATION_CONTACT,
  _NL_IDENTIFICATION_EMAIL,
  _NL_IDENTIFICATION_TEL,
  _NL_IDENTIFICATION_FAX,
  _NL_IDENTIFICATION_LANGUAGE,
  _NL_IDENTIFICATION_TERRITORY,
  _NL_IDENTIFICATION_AUDIENCE,
  _NL_IDENTIFICATION_APPLICATION,
  _NL_IDENTIFICATION_ABBREVIATION,
  _NL_IDENTIFICATION_REVISION,
  _NL_IDENTIFICATION_DATE,
  _NL_IDENTIFICATION_CATEGORY,
  _NL_IDENTIFICATION_CODESET,
  _NL_NUM_LC_IDENTIFICATION,


  _NL_NUM
};
// # 582 "/usr/include/langinfo.h" 3 4
extern char *nl_langinfo (nl_item __item) __attribute__ ((__nothrow__));
// # 593 "/usr/include/langinfo.h" 3 4
extern char *nl_langinfo_l (nl_item __item, __locale_t l);



// # 803 "zsh_system.h" 2

// # 1 "/usr/include/iconv.h" 1 3 4
// # 24 "/usr/include/iconv.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 25 "/usr/include/iconv.h" 2 3 4





typedef void *iconv_t;







extern iconv_t iconv_open (__const char *__tocode, __const char *__fromcode);




extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
       size_t *__restrict __inbytesleft,
       char **__restrict __outbuf,
       size_t *__restrict __outbytesleft);





extern int iconv_close (iconv_t __cd);


// # 805 "zsh_system.h" 2
// # 865 "zsh_system.h"
// # 1 "/usr/include/termio.h" 1 3 4
// # 866 "zsh_system.h" 2


// # 1 "zshcurses.h" 1
// # 1 "/usr/include/ncursesw/ncurses.h" 1 3 4
// # 66 "/usr/include/ncursesw/ncurses.h" 3 4
// # 1 "/usr/include/ncursesw/ncurses_dll.h" 1 3 4
// # 67 "/usr/include/ncursesw/ncurses.h" 2 3 4
// # 122 "/usr/include/ncursesw/ncurses.h" 3 4
typedef unsigned long chtype;
typedef unsigned long mmask_t;



// # 1 "/usr/include/ncursesw/unctrl.h" 1 3 4
// # 54 "/usr/include/ncursesw/unctrl.h" 3 4
// # 1 "/usr/include/ncursesw/curses.h" 1 3 4
// # 55 "/usr/include/ncursesw/unctrl.h" 2 3 4


 char * unctrl (chtype);
// # 128 "/usr/include/ncursesw/ncurses.h" 2 3 4


// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stddef.h" 1 3 4
// # 131 "/usr/include/ncursesw/ncurses.h" 2 3 4
// # 151 "/usr/include/ncursesw/ncurses.h" 3 4
typedef unsigned char NCURSES_BOOL;
// # 161 "/usr/include/ncursesw/ncurses.h" 3 4
// # 1 "/nfs/apps/gcc/4.2.4/lib/gcc/x86_64-unknown-linux-gnu/4.2.4/include/stdbool.h" 1 3 4
// # 162 "/usr/include/ncursesw/ncurses.h" 2 3 4
// # 202 "/usr/include/ncursesw/ncurses.h" 3 4
extern int COLORS;
extern int COLOR_PAIRS;
// # 220 "/usr/include/ncursesw/ncurses.h" 3 4
extern chtype acs_map[];
// # 310 "/usr/include/ncursesw/ncurses.h" 3 4
typedef struct screen SCREEN;
typedef struct _win_st WINDOW;

typedef chtype attr_t;
// # 337 "/usr/include/ncursesw/ncurses.h" 3 4
typedef struct
{
    attr_t attr;
    wchar_t chars[5];



}
cchar_t;



struct ldat;

struct _win_st
{
 short _cury, _curx;


 short _maxy, _maxx;
 short _begy, _begx;

 short _flags;


 attr_t _attrs;
 chtype _bkgd;


 _Bool _notimeout;
 _Bool _clear;
 _Bool _leaveok;
 _Bool _scroll;
 _Bool _idlok;
 _Bool _idcok;
 _Bool _immed;
 _Bool _sync;
 _Bool _use_keypad;
 int _delay;

 struct ldat *_line;


 short _regtop;
 short _regbottom;


 int _parx;
 int _pary;
 WINDOW *_parent;


 struct pdat
 {
     short _pad_y, _pad_x;
     short _pad_top, _pad_left;
     short _pad_bottom, _pad_right;
 } _pad;

 short _yoffset;


 cchar_t _bkgrnd;




};

extern WINDOW * stdscr;
extern WINDOW * curscr;
extern WINDOW * newscr;

extern int LINES;
extern int COLS;
extern int TABSIZE;




extern int ESCDELAY;

extern char ttytype[];





extern _Bool is_term_resized (int, int);
extern char * keybound (int, int);
extern const char * curses_version (void);
extern int assume_default_colors (int, int);
extern int define_key (const char *, int);
extern int key_defined (const char *);
extern int keyok (int, _Bool);
extern int resize_term (int, int);
extern int resizeterm (int, int);
extern int use_default_colors (void);
extern int use_extended_names (_Bool);
extern int use_legacy_coding (int);
extern int wresize (WINDOW *, int, int);
extern void nofilter(void);
// # 537 "/usr/include/ncursesw/ncurses.h" 3 4
extern int addch (const chtype);
extern int addchnstr (const chtype *, int);
extern int addchstr (const chtype *);
extern int addnstr (const char *, int);
extern int addstr (const char *);
extern int attroff (int);
extern int attron (int);
extern int attrset (int);
extern int attr_get (attr_t *, short *, void *);
extern int attr_off (attr_t, void *);
extern int attr_on (attr_t, void *);
extern int attr_set (attr_t, short, void *);
extern int baudrate (void);
extern int beep (void);
extern int bkgd (chtype);
extern void bkgdset (chtype);
extern int border (chtype,chtype,chtype,chtype,chtype,chtype,chtype,chtype);
extern int box (WINDOW *, chtype, chtype);
extern _Bool can_change_color (void);
extern int cbreak (void);
extern int chgat (int, attr_t, short, const void *);
extern int clear (void);
extern int clearok (WINDOW *,_Bool);
extern int clrtobot (void);
extern int clrtoeol (void);
extern int color_content (short,short*,short*,short*);
extern int color_set (short,void*);
extern int COLOR_PAIR (int);
extern int copywin (const WINDOW*,WINDOW*,int,int,int,int,int,int,int);
extern int curs_set (int);
extern int def_prog_mode (void);
extern int def_shell_mode (void);
extern int delay_output (int);
extern int delch (void);
extern void delscreen (SCREEN *);
extern int delwin (WINDOW *);
extern int deleteln (void);
extern WINDOW * derwin (WINDOW *,int,int,int,int);
extern int doupdate (void);
extern WINDOW * dupwin (WINDOW *);
extern int echo (void);
extern int echochar (const chtype);
extern int erase (void);
extern int endwin (void);
extern char erasechar (void);
extern void filter (void);
extern int flash (void);
extern int flushinp (void);
extern chtype getbkgd (WINDOW *);
extern int getch (void);
extern int getnstr (char *, int);
extern int getstr (char *);
extern WINDOW * getwin (FILE *);
extern int halfdelay (int);
extern _Bool has_colors (void);
extern _Bool has_ic (void);
extern _Bool has_il (void);
extern int hline (chtype, int);
extern void idcok (WINDOW *, _Bool);
extern int idlok (WINDOW *, _Bool);
extern void immedok (WINDOW *, _Bool);
extern chtype inch (void);
extern int inchnstr (chtype *, int);
extern int inchstr (chtype *);
extern WINDOW * initscr (void);
extern int init_color (short,short,short,short);
extern int init_pair (short,short,short);
extern int innstr (char *, int);
extern int insch (chtype);
extern int insdelln (int);
extern int insertln (void);
extern int insnstr (const char *, int);
extern int insstr (const char *);
extern int instr (char *);
extern int intrflush (WINDOW *,_Bool);
extern _Bool isendwin (void);
extern _Bool is_linetouched (WINDOW *,int);
extern _Bool is_wintouched (WINDOW *);
extern char * keyname (int);
extern int keypad (WINDOW *,_Bool);
extern char killchar (void);
extern int leaveok (WINDOW *,_Bool);
extern char * longname (void);
extern int meta (WINDOW *,_Bool);
extern int move (int, int);
extern int mvaddch (int, int, const chtype);
extern int mvaddchnstr (int, int, const chtype *, int);
extern int mvaddchstr (int, int, const chtype *);
extern int mvaddnstr (int, int, const char *, int);
extern int mvaddstr (int, int, const char *);
extern int mvchgat (int, int, int, attr_t, short, const void *);
extern int mvcur (int,int,int,int);
extern int mvdelch (int, int);
extern int mvderwin (WINDOW *, int, int);
extern int mvgetch (int, int);
extern int mvgetnstr (int, int, char *, int);
extern int mvgetstr (int, int, char *);
extern int mvhline (int, int, chtype, int);
extern chtype mvinch (int, int);
extern int mvinchnstr (int, int, chtype *, int);
extern int mvinchstr (int, int, chtype *);
extern int mvinnstr (int, int, char *, int);
extern int mvinsch (int, int, chtype);
extern int mvinsnstr (int, int, const char *, int);
extern int mvinsstr (int, int, const char *);
extern int mvinstr (int, int, char *);
extern int mvprintw (int,int, const char *,...)
  ;
extern int mvscanw (int,int, char *,...)
  ;
extern int mvvline (int, int, chtype, int);
extern int mvwaddch (WINDOW *, int, int, const chtype);
extern int mvwaddchnstr (WINDOW *, int, int, const chtype *, int);
extern int mvwaddchstr (WINDOW *, int, int, const chtype *);
extern int mvwaddnstr (WINDOW *, int, int, const char *, int);
extern int mvwaddstr (WINDOW *, int, int, const char *);
extern int mvwchgat (WINDOW *, int, int, int, attr_t, short, const void *);
extern int mvwdelch (WINDOW *, int, int);
extern int mvwgetch (WINDOW *, int, int);
extern int mvwgetnstr (WINDOW *, int, int, char *, int);
extern int mvwgetstr (WINDOW *, int, int, char *);
extern int mvwhline (WINDOW *, int, int, chtype, int);
extern int mvwin (WINDOW *,int,int);
extern chtype mvwinch (WINDOW *, int, int);
extern int mvwinchnstr (WINDOW *, int, int, chtype *, int);
extern int mvwinchstr (WINDOW *, int, int, chtype *);
extern int mvwinnstr (WINDOW *, int, int, char *, int);
extern int mvwinsch (WINDOW *, int, int, chtype);
extern int mvwinsnstr (WINDOW *, int, int, const char *, int);
extern int mvwinsstr (WINDOW *, int, int, const char *);
extern int mvwinstr (WINDOW *, int, int, char *);
extern int mvwprintw (WINDOW*,int,int, const char *,...)
  ;
extern int mvwscanw (WINDOW *,int,int, char *,...)
  ;
extern int mvwvline (WINDOW *,int, int, chtype, int);
extern int napms (int);
extern WINDOW * newpad (int,int);
extern SCREEN * newterm ( char *,FILE *,FILE *);
extern WINDOW * newwin (int,int,int,int);
extern int nl (void);
extern int nocbreak (void);
extern int nodelay (WINDOW *,_Bool);
extern int noecho (void);
extern int nonl (void);
extern void noqiflush (void);
extern int noraw (void);
extern int notimeout (WINDOW *,_Bool);
extern int overlay (const WINDOW*,WINDOW *);
extern int overwrite (const WINDOW*,WINDOW *);
extern int pair_content (short,short*,short*);
extern int PAIR_NUMBER (int);
extern int pechochar (WINDOW *, const chtype);
extern int pnoutrefresh (WINDOW*,int,int,int,int,int,int);
extern int prefresh (WINDOW *,int,int,int,int,int,int);
extern int printw (const char *,...)
  ;
extern int putp (const char *);
extern int putwin (WINDOW *, FILE *);
extern void qiflush (void);
extern int raw (void);
extern int redrawwin (WINDOW *);
extern int refresh (void);
extern int resetty (void);
extern int reset_prog_mode (void);
extern int reset_shell_mode (void);
extern int ripoffline (int, int (*)(WINDOW *, int));
extern int savetty (void);
extern int scanw ( char *,...)
  ;
extern int scr_dump (const char *);
extern int scr_init (const char *);
extern int scrl (int);
extern int scroll (WINDOW *);
extern int scrollok (WINDOW *,_Bool);
extern int scr_restore (const char *);
extern int scr_set (const char *);
extern int setscrreg (int,int);
extern SCREEN * set_term (SCREEN *);
extern int slk_attroff (const chtype);
extern int slk_attr_off (const attr_t, void *);
extern int slk_attron (const chtype);
extern int slk_attr_on (attr_t,void*);
extern int slk_attrset (const chtype);
extern attr_t slk_attr (void);
extern int slk_attr_set (const attr_t,short,void*);
extern int slk_clear (void);
extern int slk_color (short);
extern int slk_init (int);
extern char * slk_label (int);
extern int slk_noutrefresh (void);
extern int slk_refresh (void);
extern int slk_restore (void);
extern int slk_set (int,const char *,int);
extern int slk_touch (void);
extern int standout (void);
extern int standend (void);
extern int start_color (void);
extern WINDOW * subpad (WINDOW *, int, int, int, int);
extern WINDOW * subwin (WINDOW *,int,int,int,int);
extern int syncok (WINDOW *, _Bool);
extern chtype termattrs (void);
extern char * termname (void);
extern int tigetflag ( char *);
extern int tigetnum ( char *);
extern char * tigetstr ( char *);
extern void timeout (int);
extern int touchline (WINDOW *, int, int);
extern int touchwin (WINDOW *);
extern char * tparm ( char *, ...);
extern int typeahead (int);
extern int ungetch (int);
extern int untouchwin (WINDOW *);
extern void use_env (_Bool);
extern int vidattr (chtype);
extern int vidputs (chtype, int (*)(int));
extern int vline (chtype, int);
extern int vwprintw (WINDOW *, const char *,va_list);
extern int vw_printw (WINDOW *, const char *,va_list);
extern int vwscanw (WINDOW *, char *,va_list);
extern int vw_scanw (WINDOW *, char *,va_list);
extern int waddch (WINDOW *, const chtype);
extern int waddchnstr (WINDOW *,const chtype *,int);
extern int waddchstr (WINDOW *,const chtype *);
extern int waddnstr (WINDOW *,const char *,int);
extern int waddstr (WINDOW *,const char *);
extern int wattron (WINDOW *, int);
extern int wattroff (WINDOW *, int);
extern int wattrset (WINDOW *, int);
extern int wattr_get (WINDOW *, attr_t *, short *, void *);
extern int wattr_on (WINDOW *, attr_t, void *);
extern int wattr_off (WINDOW *, attr_t, void *);
extern int wattr_set (WINDOW *, attr_t, short, void *);
extern int wbkgd (WINDOW *, chtype);
extern void wbkgdset (WINDOW *,chtype);
extern int wborder (WINDOW *,chtype,chtype,chtype,chtype,chtype,chtype,chtype,chtype);
extern int wchgat (WINDOW *, int, attr_t, short, const void *);
extern int wclear (WINDOW *);
extern int wclrtobot (WINDOW *);
extern int wclrtoeol (WINDOW *);
extern int wcolor_set (WINDOW*,short,void*);
extern void wcursyncup (WINDOW *);
extern int wdelch (WINDOW *);
extern int wdeleteln (WINDOW *);
extern int wechochar (WINDOW *, const chtype);
extern int werase (WINDOW *);
extern int wgetch (WINDOW *);
extern int wgetnstr (WINDOW *,char *,int);
extern int wgetstr (WINDOW *, char *);
extern int whline (WINDOW *, chtype, int);
extern chtype winch (WINDOW *);
extern int winchnstr (WINDOW *, chtype *, int);
extern int winchstr (WINDOW *, chtype *);
extern int winnstr (WINDOW *, char *, int);
extern int winsch (WINDOW *, chtype);
extern int winsdelln (WINDOW *,int);
extern int winsertln (WINDOW *);
extern int winsnstr (WINDOW *, const char *,int);
extern int winsstr (WINDOW *, const char *);
extern int winstr (WINDOW *, char *);
extern int wmove (WINDOW *,int,int);
extern int wnoutrefresh (WINDOW *);
extern int wprintw (WINDOW *, const char *,...)
  ;
extern int wredrawln (WINDOW *,int,int);
extern int wrefresh (WINDOW *);
extern int wscanw (WINDOW *, char *,...)
  ;
extern int wscrl (WINDOW *,int);
extern int wsetscrreg (WINDOW *,int,int);
extern int wstandout (WINDOW *);
extern int wstandend (WINDOW *);
extern void wsyncdown (WINDOW *);
extern void wsyncup (WINDOW *);
extern void wtimeout (WINDOW *,int);
extern int wtouchln (WINDOW *,int,int,int);
extern int wvline (WINDOW *,chtype,int);




extern int getcurx (const WINDOW *);
extern int getcury (const WINDOW *);
extern int getbegx (const WINDOW *);
extern int getbegy (const WINDOW *);
extern int getmaxx (const WINDOW *);
extern int getmaxy (const WINDOW *);
extern int getparx (const WINDOW *);
extern int getpary (const WINDOW *);
// # 1204 "/usr/include/ncursesw/ncurses.h" 3 4
extern cchar_t * _nc_wacs;
// # 1267 "/usr/include/ncursesw/ncurses.h" 3 4
extern int add_wch (const cchar_t *);
extern int add_wchnstr (const cchar_t *, int);
extern int add_wchstr (const cchar_t *);
extern int addnwstr (const wchar_t *, int);
extern int addwstr (const wchar_t *);
extern int bkgrnd (const cchar_t *);
extern void bkgrndset (const cchar_t *);
extern int border_set (const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*);
extern int box_set (WINDOW *, const cchar_t *, const cchar_t *);
extern int echo_wchar (const cchar_t *);
extern int erasewchar (wchar_t*);
extern int get_wch (wint_t *);
extern int get_wstr (wint_t *);
extern int getbkgrnd (cchar_t *);
extern int getcchar (const cchar_t *, wchar_t*, attr_t*, short*, void*);
extern int getn_wstr (wint_t *, int);
extern int hline_set (const cchar_t *, int);
extern int in_wch (cchar_t *);
extern int in_wchnstr (cchar_t *, int);
extern int in_wchstr (cchar_t *);
extern int innwstr (wchar_t *, int);
extern int ins_nwstr (const wchar_t *, int);
extern int ins_wch (const cchar_t *);
extern int ins_wstr (const wchar_t *);
extern int inwstr (wchar_t *);
extern char* key_name (wchar_t);
extern int killwchar (wchar_t *);
extern int mvadd_wch (int, int, const cchar_t *);
extern int mvadd_wchnstr (int, int, const cchar_t *, int);
extern int mvadd_wchstr (int, int, const cchar_t *);
extern int mvaddnwstr (int, int, const wchar_t *, int);
extern int mvaddwstr (int, int, const wchar_t *);
extern int mvget_wch (int, int, wint_t *);
extern int mvget_wstr (int, int, wint_t *);
extern int mvgetn_wstr (int, int, wint_t *, int);
extern int mvhline_set (int, int, const cchar_t *, int);
extern int mvin_wch (int, int, cchar_t *);
extern int mvin_wchnstr (int, int, cchar_t *, int);
extern int mvin_wchstr (int, int, cchar_t *);
extern int mvinnwstr (int, int, wchar_t *, int);
extern int mvins_nwstr (int, int, const wchar_t *, int);
extern int mvins_wch (int, int, const cchar_t *);
extern int mvins_wstr (int, int, const wchar_t *);
extern int mvinwstr (int, int, wchar_t *);
extern int mvvline_set (int, int, const cchar_t *, int);
extern int mvwadd_wch (WINDOW *, int, int, const cchar_t *);
extern int mvwadd_wchnstr (WINDOW *, int, int, const cchar_t *, int);
extern int mvwadd_wchstr (WINDOW *, int, int, const cchar_t *);
extern int mvwaddnwstr (WINDOW *, int, int, const wchar_t *, int);
extern int mvwaddwstr (WINDOW *, int, int, const wchar_t *);
extern int mvwget_wch (WINDOW *, int, int, wint_t *);
extern int mvwget_wstr (WINDOW *, int, int, wint_t *);
extern int mvwgetn_wstr (WINDOW *, int, int, wint_t *, int);
extern int mvwhline_set (WINDOW *, int, int, const cchar_t *, int);
extern int mvwin_wch (WINDOW *, int, int, cchar_t *);
extern int mvwin_wchnstr (WINDOW *, int,int, cchar_t *,int);
extern int mvwin_wchstr (WINDOW *, int, int, cchar_t *);
extern int mvwinnwstr (WINDOW *, int, int, wchar_t *, int);
extern int mvwins_nwstr (WINDOW *, int,int, const wchar_t *,int);
extern int mvwins_wch (WINDOW *, int, int, const cchar_t *);
extern int mvwins_wstr (WINDOW *, int, int, const wchar_t *);
extern int mvwinwstr (WINDOW *, int, int, wchar_t *);
extern int mvwvline_set (WINDOW *, int,int, const cchar_t *,int);
extern int pecho_wchar (WINDOW *, const cchar_t *);
extern int setcchar (cchar_t *, const wchar_t *, const attr_t, short, const void *);
extern int slk_wset (int, const wchar_t *, int);
extern attr_t term_attrs (void);
extern int unget_wch (const wchar_t);
extern int vid_attr (attr_t, short, void *);
extern int vid_puts (attr_t, short, void *, int (*)(int));
extern int vline_set (const cchar_t *, int);
extern int wadd_wch (WINDOW *,const cchar_t *);
extern int wadd_wchnstr (WINDOW *,const cchar_t *,int);
extern int wadd_wchstr (WINDOW *,const cchar_t *);
extern int waddnwstr (WINDOW *,const wchar_t *,int);
extern int waddwstr (WINDOW *,const wchar_t *);
extern int wbkgrnd (WINDOW *,const cchar_t *);
extern void wbkgrndset (WINDOW *,const cchar_t *);
extern int wborder_set (WINDOW *,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*);
extern int wecho_wchar (WINDOW *, const cchar_t *);
extern int wget_wch (WINDOW *, wint_t *);
extern int wget_wstr (WINDOW *, wint_t *);
extern int wgetbkgrnd (WINDOW *, cchar_t *);
extern int wgetn_wstr (WINDOW *,wint_t *, int);
extern int whline_set (WINDOW *, const cchar_t *, int);
extern int win_wch (WINDOW *, cchar_t *);
extern int win_wchnstr (WINDOW *, cchar_t *, int);
extern int win_wchstr (WINDOW *, cchar_t *);
extern int winnwstr (WINDOW *, wchar_t *, int);
extern int wins_nwstr (WINDOW *, const wchar_t *, int);
extern int wins_wch (WINDOW *, const cchar_t *);
extern int wins_wstr (WINDOW *, const wchar_t *);
extern int winwstr (WINDOW *, wchar_t *);
extern wchar_t* wunctrl (cchar_t *);
extern int wvline_set (WINDOW *, const cchar_t *, int);
// # 1532 "/usr/include/ncursesw/ncurses.h" 3 4
typedef struct
{
    short id;
    int x, y, z;
    mmask_t bstate;
}
MEVENT;

extern int getmouse (MEVENT *);
extern int ungetmouse (MEVENT *);
extern mmask_t mousemask (mmask_t, mmask_t *);
extern _Bool wenclose (const WINDOW *, int, int);
extern int mouseinterval (int);
extern _Bool wmouse_trafo (const WINDOW*, int*, int*, _Bool);
extern _Bool mouse_trafo (int*, int*, _Bool);





extern int mcprint (char *, int);
extern int has_key (int);



extern void _tracef (const char *, ...) ;
extern void _tracedump (const char *, WINDOW *);
extern char * _traceattr (attr_t);
extern char * _traceattr2 (int, chtype);
extern char * _nc_tracebits (void);
extern char * _tracechar (int);
extern char * _tracechtype (chtype);
extern char * _tracechtype2 (int, chtype);


extern char * _tracecchar_t (const cchar_t *);

extern char * _tracecchar_t2 (int, const cchar_t *);




extern char * _tracemouse (const MEVENT *);
extern void trace (const unsigned int);
// # 1 "zshcurses.h" 2
// # 869 "zsh_system.h" 2

// # 1 "zshterm.h" 1
// # 1 "/usr/include/ncursesw/term.h" 1 3 4
// # 673 "/usr/include/ncursesw/term.h" 3 4
typedef struct termtype {
    char *term_names;
    char *str_table;
    char *Booleans;
    short *Numbers;
    char **Strings;


    char *ext_str_table;
    char **ext_Names;

    unsigned short num_Booleans;
    unsigned short num_Numbers;
    unsigned short num_Strings;

    unsigned short ext_Booleans;
    unsigned short ext_Numbers;
    unsigned short ext_Strings;


} TERMTYPE;

typedef struct term {
    TERMTYPE type;
    short Filedes;
    struct termios Ottyb,
  Nttyb;
    int _baudrate;
    char * _termname;
} TERMINAL;

extern TERMINAL * cur_term;
// # 729 "/usr/include/ncursesw/term.h" 3 4
extern char * const boolnames[];
extern char * const boolcodes[];
extern char * const boolfnames[];
extern char * const numnames[];
extern char * const numcodes[];
extern char * const numfnames[];
extern char * const strnames[];
extern char * const strcodes[];
extern char * const strfnames[];




extern int _nc_set_tty_mode (struct termios *buf);
extern int _nc_get_tty_mode (struct termios *buf);
extern int _nc_read_entry (const char * const, char * const, TERMTYPE *const);
extern int _nc_read_file_entry (const char *const, TERMTYPE *);
extern char * _nc_first_name (const char *const);
extern int _nc_name_match (const char *const, const char *const, const char *const);
extern int _nc_read_termcap_entry (const char *const, TERMTYPE *const);
extern const TERMTYPE * _nc_fallback (const char *);


extern TERMINAL * set_curterm (TERMINAL *);
extern int del_curterm (TERMINAL *);


extern int restartterm ( char *, int, int *);
extern int setupterm ( char *,int,int *);
// # 771 "/usr/include/ncursesw/term.h" 3 4
extern char * tgetstr ( char *, char **);
extern char * tgoto (const char *, int, int);
extern int tgetent (char *, const char *);
extern int tgetflag ( char *);
extern int tgetnum ( char *);
extern int tputs (const char *, int, int (*)(int));
// # 1 "zshterm.h" 2
// # 871 "zsh_system.h" 2
// # 18 "zsh.mdh" 2
// # 1 "zsh.h" 1
// # 48 "zsh.h"
typedef long zlong;
typedef unsigned long zulong;
// # 61 "zsh.h"
typedef struct {
    union {
 zlong l;
 double d;
    } u;
    int type;
} mnumber;





typedef struct mathfunc *MathFunc;
typedef mnumber (*NumMathFunc)(char *, int, mnumber *, int);
typedef mnumber (*StrMathFunc)(char *, char *, int);

struct mathfunc {
    MathFunc next;
    char *name;
    int flags;
    NumMathFunc nfunc;
    StrMathFunc sfunc;
    char *module;
    int minargs;
    int maxargs;
    int funcid;
};
// # 197 "zsh.h"
enum {




    QT_NONE,

    QT_BACKSLASH,

    QT_SINGLE,

    QT_DOUBLE,

    QT_DOLLARS,





    QT_BACKTICK,




    QT_SINGLE_OPTIONAL,



    QT_BACKSLASH_SHOWNULL
};
// # 235 "zsh.h"
enum {
    NULLTOK,
    SEPER,
    NEWLIN,
    SEMI,
    DSEMI,
    AMPER,
    INPAR,
    OUTPAR,
    DBAR,
    DAMPER,
    OUTANG,
    OUTANGBANG,
    DOUTANG,
    DOUTANGBANG,
    INANG,
    INOUTANG,
    DINANG,
    DINANGDASH,
    INANGAMP,
    OUTANGAMP,
    AMPOUTANG,
    OUTANGAMPBANG,
    DOUTANGAMP,
    DOUTANGAMPBANG,
    TRINANG,
    BAR,
    BARAMP,
    INOUTPAR,
    DINPAR,
    DOUTPAR,
    AMPERBANG,
    SEMIAMP,
    SEMIBAR,
    DOUTBRACK,
    STRING,
    ENVSTRING,
    ENVARRAY,
    ENDINPUT,
    LEXERR,


    BANG,
    DINBRACK,
    INBRACE,
    OUTBRACE,
    CASE,
    COPROC,
    DOLOOP,
    DONE,
    ELIF,
    ELSE,
    ZEND,
    ESAC,
    FI,
    FOR,
    FOREACH,
    FUNC,
    IF,
    NOCORRECT,
    REPEAT,
    SELECT,
    THEN,
    TIME,
    UNTIL,
    WHILE
};





enum {
    REDIR_WRITE,
    REDIR_WRITENOW,
    REDIR_APP,
    REDIR_APPNOW,
    REDIR_ERRWRITE,
    REDIR_ERRWRITENOW,
    REDIR_ERRAPP,
    REDIR_ERRAPPNOW,
    REDIR_READWRITE,
    REDIR_READ,
    REDIR_HEREDOC,
    REDIR_HEREDOCDASH,
    REDIR_HERESTR,
    REDIR_MERGEIN,
    REDIR_MERGEOUT,
    REDIR_CLOSE,
    REDIR_INPIPE,
    REDIR_OUTPIPE
};
// # 403 "zsh.h"
typedef struct alias *Alias;
typedef struct asgment *Asgment;
typedef struct builtin *Builtin;
typedef struct cmdnam *Cmdnam;
typedef struct complist *Complist;
typedef struct conddef *Conddef;
typedef struct dirsav *Dirsav;
typedef struct features *Features;
typedef struct feature_enables *Feature_enables;
typedef struct funcstack *Funcstack;
typedef struct funcwrap *FuncWrap;
typedef struct hashnode *HashNode;
typedef struct hashtable *HashTable;
typedef struct heap *Heap;
typedef struct heapstack *Heapstack;
typedef struct histent *Histent;
typedef struct hookdef *Hookdef;
typedef struct job *Job;
typedef struct linkedmod *Linkedmod;
typedef struct linknode *LinkNode;
typedef union linkroot *LinkList;
typedef struct module *Module;
typedef struct nameddir *Nameddir;
typedef struct options *Options;
typedef struct optname *Optname;
typedef struct param *Param;
typedef struct paramdef *Paramdef;
typedef struct patprog *Patprog;
typedef struct prepromptfn *Prepromptfn;
typedef struct process *Process;
typedef struct redir *Redir;
typedef struct reswd *Reswd;
typedef struct shfunc *Shfunc;
typedef struct timedfn *Timedfn;
typedef struct value *Value;







struct linknode {
    LinkNode next;
    LinkNode prev;
    void *dat;
};

struct linklist {
    LinkNode first;
    LinkNode last;
    int flags;
};

union linkroot {
    struct linklist list;
    struct linknode node;
};
// # 509 "zsh.h"
typedef void (*voidvoidfnptr_t) (void);




struct prepromptfn {
    voidvoidfnptr_t func;
};





struct timedfn {
    voidvoidfnptr_t func;
    time_t when;
};
// # 562 "zsh.h"
typedef int (*CondHandler) (char **, int);

struct conddef {
    Conddef next;
    char *name;
    int flags;
    CondHandler handler;
    int min;
    int max;
    int condid;
    char *module;
};
// # 587 "zsh.h"
enum {

    REDIRF_FROM_HEREDOC = 1
};



struct redir {
    int type;
    int flags;
    int fd1, fd2;
    char *name;
    char *varid;
    char *here_terminator;
    char *munged_here_terminator;
};
// # 616 "zsh.h"
struct multio {
    int ct;
    int rflag;
    int pipe;
    int fds[8];
};



struct asgment {
    struct asgment *next;
    char *name;
    char *value;
};



struct value {
    int isarr;
    Param pm;
    int flags;
    int start;
    int end;
    char **arr;
};

enum {
    VALFLAG_INV = 0x0001,
    VALFLAG_EMPTY = 0x0002,
    VALFLAG_SUBST = 0x0004
};







typedef unsigned int wordcode;
typedef wordcode *Wordcode;

typedef struct funcdump *FuncDump;
typedef struct eprog *Eprog;

struct funcdump {
    FuncDump next;
    dev_t dev;
    ino_t ino;
    int fd;
    Wordcode map;
    Wordcode addr;
    int len;
    int count;
    char *filename;
};
// # 689 "zsh.h"
struct eprog {
    int flags;
    int len;
    int npats;
    int nref;
    Patprog *pats;
    Wordcode prog;
    char *strs;
    Shfunc shf;
    FuncDump dump;
};






typedef struct estate *Estate;

struct estate {
    Eprog prog;
    Wordcode pc;
    char *strs;
};

typedef struct eccstr *Eccstr;

struct eccstr {
    Eccstr left, right;
    char *str;
    wordcode offs, aoffs;
    int nfunc;
};
// # 878 "zsh.h"
struct job {
    pid_t gleader;
    pid_t other;
    int stat;
    char *pwd;

    struct process *procs;
    struct process *auxprocs;
    LinkList filelist;
    int stty_in_env;
    struct ttyinfo *ty;
};
// # 914 "zsh.h"
struct timeinfo {
    long ut;
    long st;
};
// # 927 "zsh.h"
typedef struct rusage child_times_t;




struct process {
    struct process *next;
    pid_t pid;
    char text[80];
    int status;
    child_times_t ti;
    struct timeval bgtime;
    struct timeval endtime;
};

struct execstack {
    struct execstack *next;

    pid_t list_pipe_pid;
    int nowait;
    int pline_level;
    int list_pipe_child;
    int list_pipe_job;
    char list_pipe_text[80];
    int lastval;
    int noeval;
    int badcshglob;
    pid_t cmdoutpid;
    int cmdoutval;
    int use_cmdoutval;
    int trap_return;
    int trap_state;
    int trapisfunc;
    int traplocallevel;
    int noerrs;
    int subsh_close;
    char *underscore;
};

struct heredocs {
    struct heredocs *next;
    int type;
    int pc;
    char *str;
};

struct dirsav {
    int dirfd, level;
    char *dirname;
    dev_t dev;
    ino_t ino;
};







typedef void *(*VFunc) (void *);
typedef void (*FreeFunc) (void *);

typedef unsigned (*HashFunc) (const char *);
typedef void (*TableFunc) (HashTable);





typedef void (*AddNodeFunc) (HashTable, char *, void *);
typedef HashNode (*GetNodeFunc) (HashTable, const char *);
typedef HashNode (*RemoveNodeFunc) (HashTable, const char *);
typedef void (*FreeNodeFunc) (HashNode);
typedef int (*CompareFunc) (const char *, const char *);



typedef void (*ScanFunc) (HashNode, int);
typedef void (*ScanTabFunc) (HashTable, ScanFunc, int);

typedef void (*PrintTableStats) (HashTable);



struct hashtable {

    int hsize;
    int ct;
    HashNode *nodes;
    void *tmpdata;


    HashFunc hash;
    TableFunc emptytable;
    TableFunc filltable;
    CompareFunc cmpnodes;
    AddNodeFunc addnode;
    GetNodeFunc getnode;
    GetNodeFunc getnode2;

    RemoveNodeFunc removenode;
    ScanFunc disablenode;
    ScanFunc enablenode;
    FreeNodeFunc freenode;
    ScanFunc printnode;
    ScanTabFunc scantab;




};



struct hashnode {
    HashNode next;
    char *nam;
    int flags;
};
// # 1054 "zsh.h"
struct optname {
    struct hashnode node;
    int optno;
};



struct reswd {
    struct hashnode node;
    int token;
};



struct alias {
    struct hashnode node;
    char *text;
    int inuse;
};
// # 1082 "zsh.h"
struct cmdnam {
    struct hashnode node;
    union {
 char **name;
 char *cmd;
    }
    u;
};







struct shfunc {
    struct hashnode node;
    char *filename;
    zlong lineno;
    Eprog funcdef;
    int emulation;
};
// # 1118 "zsh.h"
enum {
    FS_SOURCE,
    FS_FUNC,
    FS_EVAL
};



struct funcstack {
    Funcstack prev;
    char *name;
    char *filename;
    char *caller;
    zlong flineno;
    zlong lineno;
    int tp;
};



typedef int (*WrapFunc) (Eprog, FuncWrap, char *);

struct funcwrap {
    FuncWrap next;
    int flags;
    WrapFunc handler;
    Module module;
};
// # 1194 "zsh.h"
struct options {
    unsigned char ind[128];
    char **args;
    int argscount, argsalloc;
};







typedef int (*HandlerFunc) (char *, char **, Options, int);


struct builtin {
    struct hashnode node;
    HandlerFunc handlerfunc;
    int minargs;
    int maxargs;
    int funcid;
    char *optstr;
    char *defopts;
};
// # 1251 "zsh.h"
struct module {
    struct hashnode node;
    union {
 void *handle;
 Linkedmod linked;
 char *alias;
    } u;
    LinkList autoloads;
    LinkList deps;
    int wrapper;
};
// # 1282 "zsh.h"
typedef int (*Module_generic_func) (void);
typedef int (*Module_void_func) (Module);
typedef int (*Module_features_func) (Module, char ***);
typedef int (*Module_enables_func) (Module, int **);

struct linkedmod {
    char *name;
    Module_void_func setup;
    Module_features_func features;
    Module_enables_func enables;
    Module_void_func boot;
    Module_void_func cleanup;
    Module_void_func finish;
};





struct features {

    Builtin bn_list;
    int bn_size;

    Conddef cd_list;
    int cd_size;

    MathFunc mf_list;
    int mf_size;

    Paramdef pd_list;
    int pd_size;

    int n_abstract;
};




struct feature_enables {

    char *str;

    Patprog pat;
};



typedef int (*Hookfn) (Hookdef, void *);

struct hookdef {
    Hookdef next;
    char *name;
    Hookfn def;
    int flags;
    LinkList funcs;
};
// # 1349 "zsh.h"
struct patprog {
    long startoff;
    long size;
    long mustoff;
    long patmlen;
    int globflags;
    int globend;
    int flags;
    int patnpar;
    char patstartch;
};
// # 1438 "zsh.h"
typedef const struct gsu_scalar *GsuScalar;
typedef const struct gsu_integer *GsuInteger;
typedef const struct gsu_float *GsuFloat;
typedef const struct gsu_array *GsuArray;
typedef const struct gsu_hash *GsuHash;

struct gsu_scalar {
    char *(*getfn) (Param);
    void (*setfn) (Param, char *);
    void (*unsetfn) (Param, int);
};

struct gsu_integer {
    zlong (*getfn) (Param);
    void (*setfn) (Param, zlong);
    void (*unsetfn) (Param, int);
};

struct gsu_float {
    double (*getfn) (Param);
    void (*setfn) (Param, double);
    void (*unsetfn) (Param, int);
};

struct gsu_array {
    char **(*getfn) (Param);
    void (*setfn) (Param, char **);
    void (*unsetfn) (Param, int);
};

struct gsu_hash {
    HashTable (*getfn) (Param);
    void (*setfn) (Param, HashTable);
    void (*unsetfn) (Param, int);
};




struct param {
    struct hashnode node;


    union {
 void *data;
 char **arr;
 char *str;
 zlong val;
 zlong *valptr;
 double dval;

        HashTable hash;
    } u;
// # 1500 "zsh.h"
    union {
 GsuScalar s;
 GsuInteger i;
 GsuFloat f;
 GsuArray a;
 GsuHash h;
    } gsu;

    int base;
    int width;
    char *env;
    char *ename;
    Param old;
    int level;
};


struct tieddata {
    char ***arrptr;
    int joinchar;
};
// # 1631 "zsh.h"
struct repldata {
    int b, e;
    char *replstr;
};
typedef struct repldata *Repldata;




enum {

    ZSHTOK_SUBST = 0x0001,

    ZSHTOK_SHGLOB = 0x0002
};
// # 1676 "zsh.h"
struct paramdef {
    char *name;
    int flags;
    void *var;
    const void *gsu;
    GetNodeFunc getnfn;
    ScanTabFunc scantfn;
    Param pm;
};
// # 1727 "zsh.h"
enum {
    ASSPM_AUGMENT = 1 << 0,
    ASSPM_WARN_CREATE = 1 << 1
};



struct nameddir {
    struct hashnode node;
    char *dir;
    int diff;
};







typedef struct {

    char *name;

    gid_t gid;
} groupmap;
typedef groupmap *Groupmap;


typedef struct {

    Groupmap array;

    int num;
} groupset;
typedef groupset *Groupset;
// # 1780 "zsh.h"
enum loop_return {

    LOOP_OK,

    LOOP_EMPTY,

    LOOP_ERROR
};



enum source_return {

    SOURCE_OK = 0,

    SOURCE_NOT_FOUND = 1,

    SOURCE_ERROR = 2
};







struct histent {
    struct hashnode node;

    Histent up;
    Histent down;
    char *zle_text;




    time_t stim;
    time_t ftim;
    short *words;

    int nwords;
    zlong histnum;
};
// # 1933 "zsh.h"
enum {
    OPT_INVALID,
    ALIASESOPT,
    ALLEXPORT,
    ALWAYSLASTPROMPT,
    ALWAYSTOEND,
    APPENDHISTORY,
    AUTOCD,
    AUTOCONTINUE,
    AUTOLIST,
    AUTOMENU,
    AUTONAMEDIRS,
    AUTOPARAMKEYS,
    AUTOPARAMSLASH,
    AUTOPUSHD,
    AUTOREMOVESLASH,
    AUTORESUME,
    BADPATTERN,
    BANGHIST,
    BAREGLOBQUAL,
    BASHAUTOLIST,
    BASHREMATCH,
    BEEP,
    BGNICE,
    BRACECCL,
    BSDECHO,
    CASEGLOB,
    CASEMATCH,
    CBASES,
    CDABLEVARS,
    CHASEDOTS,
    CHASELINKS,
    CHECKJOBS,
    CLOBBER,
    COMBININGCHARS,
    COMPLETEALIASES,
    COMPLETEINWORD,
    CORRECT,
    CORRECTALL,
    CPRECEDENCES,
    CSHJUNKIEHISTORY,
    CSHJUNKIELOOPS,
    CSHJUNKIEQUOTES,
    CSHNULLCMD,
    CSHNULLGLOB,
    DEBUGBEFORECMD,
    EMACSMODE,
    EQUALS,
    ERREXIT,
    ERRRETURN,
    EXECOPT,
    EXTENDEDGLOB,
    EXTENDEDHISTORY,
    EVALLINENO,
    FLOWCONTROL,
    FUNCTIONARGZERO,
    GLOBOPT,
    GLOBALEXPORT,
    GLOBALRCS,
    GLOBASSIGN,
    GLOBCOMPLETE,
    GLOBDOTS,
    GLOBSUBST,
    HASHCMDS,
    HASHDIRS,
    HASHEXECUTABLESONLY,
    HASHLISTALL,
    HISTALLOWCLOBBER,
    HISTBEEP,
    HISTEXPIREDUPSFIRST,
    HISTFCNTLLOCK,
    HISTFINDNODUPS,
    HISTIGNOREALLDUPS,
    HISTIGNOREDUPS,
    HISTIGNORESPACE,
    HISTLEXWORDS,
    HISTNOFUNCTIONS,
    HISTNOSTORE,
    HISTREDUCEBLANKS,
    HISTSAVEBYCOPY,
    HISTSAVENODUPS,
    HISTSUBSTPATTERN,
    HISTVERIFY,
    HUP,
    IGNOREBRACES,
    IGNORECLOSEBRACES,
    IGNOREEOF,
    INCAPPENDHISTORY,
    INTERACTIVE,
    INTERACTIVECOMMENTS,
    KSHARRAYS,
    KSHAUTOLOAD,
    KSHGLOB,
    KSHOPTIONPRINT,
    KSHTYPESET,
    KSHZEROSUBSCRIPT,
    LISTAMBIGUOUS,
    LISTBEEP,
    LISTPACKED,
    LISTROWSFIRST,
    LISTTYPES,
    LOCALOPTIONS,
    LOCALTRAPS,
    LOGINSHELL,
    LONGLISTJOBS,
    MAGICEQUALSUBST,
    MAILWARNING,
    MARKDIRS,
    MENUCOMPLETE,
    MONITOR,
    MULTIBYTE,
    MULTIFUNCDEF,
    MULTIOS,
    NOMATCH,
    NOTIFY,
    NULLGLOB,
    NUMERICGLOBSORT,
    OCTALZEROES,
    OVERSTRIKE,
    PATHDIRS,
    PATHSCRIPT,
    POSIXALIASES,
    POSIXBUILTINS,
    POSIXCD,
    POSIXIDENTIFIERS,
    POSIXJOBS,
    POSIXSTRINGS,
    POSIXTRAPS,
    PRINTEIGHTBIT,
    PRINTEXITVALUE,
    PRIVILEGED,
    PROMPTBANG,
    PROMPTCR,
    PROMPTPERCENT,
    PROMPTSP,
    PROMPTSUBST,
    PUSHDIGNOREDUPS,
    PUSHDMINUS,
    PUSHDSILENT,
    PUSHDTOHOME,
    RCEXPANDPARAM,
    RCQUOTES,
    RCS,
    RECEXACT,
    REMATCHPCRE,
    RESTRICTED,
    RMSTARSILENT,
    RMSTARWAIT,
    SHAREHISTORY,
    SHFILEEXPANSION,
    SHGLOB,
    SHINSTDIN,
    SHNULLCMD,
    SHOPTIONLETTERS,
    SHORTLOOPS,
    SHWORDSPLIT,
    SINGLECOMMAND,
    SINGLELINEZLE,
    SOURCETRACE,
    SUNKEYBOARDHACK,
    TRANSIENTRPROMPT,
    TRAPSASYNC,
    TYPESETSILENT,
    UNSET,
    VERBOSE,
    VIMODE,
    WARNCREATEGLOBAL,
    XTRACE,
    USEZLE,
    DVORAK,
    OPT_SIZE
};
// # 2120 "zsh.h"
struct ttyinfo {

    struct termios tio;
// # 2134 "zsh.h"
    struct winsize winsize;

};
// # 2286 "zsh.h"
enum {

    TSC_RAW = 0x0001,

    TSC_PROMPT = 0x0002,

    TSC_OUTPUT_MASK = 0x0003,

    TSC_DIRTY = 0x0004
};
// # 2354 "zsh.h"
typedef unsigned int Heapid;
// # 2399 "zsh.h"
struct heapstack {
    struct heapstack *next;
    size_t used;



};



struct heap {
    struct heap *next;
    size_t size;
    size_t used;
    struct heapstack *sp;
// # 2426 "zsh.h"
}



;
// # 2475 "zsh.h"
enum trap_state {

    TRAP_STATE_INACTIVE,




    TRAP_STATE_PRIMED,




    TRAP_STATE_FORCE_RETURN
};
// # 2497 "zsh.h"
typedef int (*CompareFn) (const void *, const void *);

enum {
    SORTIT_ANYOLDHOW = 0,
    SORTIT_IGNORING_CASE = 1,
    SORTIT_NUMERICALLY = 2,
    SORTIT_BACKWARDS = 4,




    SORTIT_IGNORING_BACKSLASHES = 8,




    SORTIT_SOMEHOW = 16,
};




struct sortelt {

    char *orig;

    const char *cmp;




    int origlen;




    int len;
};

typedef struct sortelt *SortElt;





enum {
    CASMOD_NONE,
    CASMOD_UPPER,
    CASMOD_LOWER,
    CASMOD_CAPS
};
// # 2557 "zsh.h"
enum {





    GETKEY_OCTAL_ESC = (1 << 0),






    GETKEY_EMACS = (1 << 1),

    GETKEY_CTRL = (1 << 2),

    GETKEY_BACKSLASH_C = (1 << 3),

    GETKEY_DOLLAR_QUOTE = (1 << 4),

    GETKEY_BACKSLASH_MINUS = (1 << 5),

    GETKEY_SINGLE_CHAR = (1 << 6),





    GETKEY_UPDATE_OFFSET = (1 << 7),



    GETKEY_PRINTF_PERCENT = (1 << 8)
};
// # 2631 "zsh.h"
enum {
    ZLCON_LINE_START,
    ZLCON_LINE_CONT,
    ZLCON_SELECT,
    ZLCON_VARED
};







typedef int (*CompctlReadFn) (char *, char **, Options, char *);



typedef char * (*ZleEntryPoint)(int cmd, va_list ap);



enum {
    ZLE_CMD_GET_LINE,
    ZLE_CMD_READ,
    ZLE_CMD_ADD_TO_LINE,
    ZLE_CMD_TRASH,
    ZLE_CMD_RESET_PROMPT,
    ZLE_CMD_REFRESH,
    ZLE_CMD_SET_KEYMAP,
    ZLE_CMD_GET_KEY
};
// # 2674 "zsh.h"
typedef wint_t convchar_t;
// # 19 "zsh.mdh" 2
// # 1 "sigcount.h" 1
// # 20 "zsh.mdh" 2
// # 1 "signals.h" 1
// # 106 "signals.h"
extern sigset_t signal_block (sigset_t);


extern sigset_t signal_unblock (sigset_t);
// # 21 "zsh.mdh" 2
// # 1 "prototypes.h" 1
// # 22 "zsh.mdh" 2
// # 1 "hashtable.h" 1
// # 23 "zsh.mdh" 2
// # 1 "ztype.h" 1
// # 24 "zsh.mdh" 2
// # 34 "zsh.mdh"
// # 1 "builtin.epro" 1




extern HashTable builtintab;
extern void createbuiltintable (void);
extern void init_builtins (void);
extern int execbuiltin (LinkList args,Builtin bn);
extern int bin_enable (char*name,char**argv,Options ops,int func);
extern int bin_set (char*nam,char**args,Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern int doprintdir;
extern int bin_pwd (char*name __attribute__((__unused__)),char**argv __attribute__((__unused__)),Options ops,int func __attribute__((__unused__)));
extern LinkList dirstack;
extern int bin_dirs (char*name __attribute__((__unused__)),char**argv,Options ops,int func __attribute__((__unused__)));
extern void set_pwd_env (void);
extern int bin_cd (char*nam,char**argv,Options ops,int func);
extern char*cd_able_vars (char*s);
extern int fixdir (char*src);
extern void printqt (char*str);
extern void printif (char*str,int c);
extern int bin_fc (char*nam,char**argv,Options ops,int func);
extern int bin_typeset (char*name,char**argv,Options ops,int func);
extern int eval_autoload (Shfunc shf,char*name,Options ops,int func);
extern int bin_functions (char*name,char**argv,Options ops,int func);
extern Eprog mkautofn (Shfunc shf);
extern int bin_unset (char*name,char**argv,Options ops,int func);
extern int bin_whence (char*nam,char**argv,Options ops,int func);
extern int bin_hash (char*name,char**argv,Options ops,int func __attribute__((__unused__)));
extern int bin_unhash (char*name,char**argv,Options ops,int func __attribute__((__unused__)));
extern int bin_alias (char*name,char**argv,Options ops,int func __attribute__((__unused__)));
extern int bin_true (char*name __attribute__((__unused__)),char**argv __attribute__((__unused__)),Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern int bin_false (char*name __attribute__((__unused__)),char**argv __attribute__((__unused__)),Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern LinkList bufstack;
extern int bin_print (char*name,char**args,Options ops,int func);
extern int bin_shift (char*name,char**argv,Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern int optcind;
extern int bin_getopts (char*name __attribute__((__unused__)),char**argv,Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern int exit_pending;
extern int bin_break (char*name,char**argv,Options ops __attribute__((__unused__)),int func);
extern int stopmsg;
extern void zexit (int val,int from_where);
extern int bin_dot (char*name,char**argv,Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern int bin_emulate (char*nam __attribute__((__unused__)),char**argv,Options ops,int func __attribute__((__unused__)));
extern int ineval;
extern int bin_eval (char*nam __attribute__((__unused__)),char**argv,Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern int bin_read (char*name,char**args,Options ops,int func __attribute__((__unused__)));
extern char**testargs;
extern char**curtestarg;
extern void testlex (void);
extern int bin_test (char*name,char**argv,Options ops __attribute__((__unused__)),int func);
extern int bin_times (char*name __attribute__((__unused__)),char**argv __attribute__((__unused__)),Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern int bin_trap (char*name,char**argv,Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern int bin_ttyctl (char*name __attribute__((__unused__)),char**argv __attribute__((__unused__)),Options ops,int func __attribute__((__unused__)));
extern int bin_let (char*name __attribute__((__unused__)),char**argv,Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern int bin_umask (char*nam,char**args,Options ops,int func __attribute__((__unused__)));
extern int bin_notavail (char*nam,char**argv __attribute__((__unused__)),Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
// # 35 "zsh.mdh" 2
// # 1 "compat.epro" 1




extern long zpathmax (char*dir);
extern long zopenmax (void);
extern char*zgetdir (struct dirsav*d);
extern char*zgetcwd (void);
extern int zchdir (char*dir);
// # 36 "zsh.mdh" 2
// # 1 "cond.epro" 1




extern int evalcond (Estate state,char*fromtest);
extern char*cond_str (char**args,int num,int raw);
extern zlong cond_val (char**args,int num);
extern int cond_match (char**args,int num,char*str);
// # 37 "zsh.mdh" 2
// # 1 "exec.epro" 1




extern int noerrexit;
extern int noerrs;
extern int nohistsave;
extern int errflag;
extern int trap_state;
extern int trap_return;
extern int subsh;
extern int retflag;
extern long lastval2;
extern unsigned char*fdtable;
extern int fdtable_size;
extern int max_zsh_fd;
extern int coprocin;
extern int coprocout;
extern int fdtable_flocks;
extern int zleactive;
extern pid_t cmdoutpid;
extern int cmdoutval;
extern int use_cmdoutval;
extern int sfcontext;
extern struct execstack*exstack;
extern Funcstack funcstack;
extern Eprog parse_string (char*s,int reset_lineno);

extern struct rlimit current_limits[__RLIM_NLIMITS];
extern struct rlimit limits[__RLIM_NLIMITS];
extern int zsetlimit (int limnum,char*nam);
extern int setlimits (char*nam);

extern int list_pipe;
extern int simple_pline;
extern char*findcmd (char*arg0,int docopy);
extern int iscom (char*s);
extern int isreallycom (Cmdnam cn);
extern int isrelative (char*s);
extern Cmdnam hashcmd (char*arg0,char**pp);
extern int forklevel;
extern void execstring (char*s,int dont_change_job,int exiting,char*context);
extern void execode (Eprog p,int dont_change_job,int exiting,char*context);
extern void execlist (Estate state,int dont_change_job,int exiting);
extern void untokenize (char*s);
extern void quote_tokenized_output (char*str,FILE*file);
extern void setunderscore (char*str);
extern void execsubst (LinkList strs);
extern void closem (int how);
extern char*gethere (char**strp,int typ);
extern LinkList getoutput (char*cmd,int qt);
extern LinkList readoutput (int in,int qt);
extern char*getoutputfile (char*cmd,char**eptr);
extern char*getproc (char*cmd,char**eptr);
extern Shfunc loadautofn (Shfunc shf,int fksh,int autol);
extern int doshfunc (Shfunc shfunc,LinkList doshargs,int noreturnval);
extern void runshfunc (Eprog prog,FuncWrap wrap,char*name);
extern Eprog getfpfunc (char*s,int*ksh,char**fname);
extern Eprog stripkshdef (Eprog prog,char*name);
extern void execsave (void);
extern void execrestore (void);
// # 38 "zsh.mdh" 2
// # 1 "glob.epro" 1




extern int badcshglob;
extern int pathpos;
extern char*pathbuf;
extern char*glob_pre;
extern char*glob_suf;
extern int haswilds (char*str);
extern void zglob (LinkList list,LinkNode np,int nountok);
extern char file_type (mode_t filemode);
extern int hasbraces (char*str);
extern int xpandredir (struct redir*fn,LinkList redirtab);
extern void xpandbraces (LinkList list,LinkNode*np);
extern int matchpat (char*a,char*b);
extern int getmatch (char**sp,char*pat,int fl,int n,char*replstr);
extern void getmatcharr (char***ap,char*pat,int fl,int n,char*replstr);
extern int getmatchlist (char*str,Patprog p,LinkList*repllistp);
extern void freematchlist (LinkList repllist);



extern void tokenize (char*s);
extern void shtokenize (char*s);
extern void remnulargs (char*s);
// # 39 "zsh.mdh" 2
// # 1 "hashtable.epro" 1




extern unsigned hasher (const char*str);
extern HashTable newhashtable (int size,char const*name __attribute__((__unused__)),PrintTableStats printinfo __attribute__((__unused__)));
extern void deletehashtable (HashTable ht);
extern void addhashnode (HashTable ht,char*nam,void*nodeptr);
extern HashNode addhashnode2 (HashTable ht,char*nam,void*nodeptr);
extern HashNode gethashnode (HashTable ht,const char*nam);
extern HashNode gethashnode2 (HashTable ht,const char*nam);
extern HashNode removehashnode (HashTable ht,const char*nam);
extern void disablehashnode (HashNode hn,int flags __attribute__((__unused__)));
extern void enablehashnode (HashNode hn,int flags __attribute__((__unused__)));
extern int scanmatchtable (HashTable ht,Patprog pprog,int sorted,int flags1,int flags2,ScanFunc scanfunc,int scanflags);
extern int scanhashtable (HashTable ht,int sorted,int flags1,int flags2,ScanFunc scanfunc,int scanflags);
extern void emptyhashtable (HashTable ht);



extern HashTable cmdnamtab;
extern char**pathchecked;
extern void createcmdnamtable (void);
extern void hashdir (char**dirp);
extern HashTable shfunctab;
extern void createshfunctable (void);
extern HashTable reswdtab;
extern void createreswdtable (void);
extern HashTable aliastab;
extern HashTable sufaliastab;
extern void createaliastable (HashTable ht);
extern void createaliastables (void);
extern Alias createaliasnode (char*txt,int flags);
extern void createhisttable (void);
extern unsigned histhasher (const char*str);
extern void emptyhisttable (HashTable ht);
extern int histstrcmp (const char*str1,const char*str2);
extern void addhistnode (HashTable ht,char*nam,void*nodeptr);
extern void freehistnode (HashNode nodeptr);
extern void freehistdata (Histent he,int unlink);
// # 40 "zsh.mdh" 2
// # 1 "hashnameddir.epro" 1




extern HashTable nameddirtab;
extern void createnameddirtable (void);
// # 41 "zsh.mdh" 2
// # 1 "hist.epro" 1




extern int(*hgetc)(void);
extern void(*hungetc)(int);
extern void(*hwaddc)(int);
extern void(*hwbegin)(int);
extern void(*hwend)(void);
extern void(*addtoline)(int);
extern int stophist;
extern int expanding;
extern int excs;
extern int exlast;
extern zlong curhist;
extern struct histent curline;
extern zlong histlinect;
extern HashTable histtab;
extern Histent hist_ring;
extern zlong histsiz;
extern zlong savehistsiz;
extern int histdone;
extern int histactive;
extern int hist_ignore_all_dups;
extern int hist_skip_flags;
extern short*chwords;
extern int chwordlen;
extern int chwordpos;
extern char*hsubl;
extern char*hsubr;
extern char*hptr;
extern char*chline;
extern char*zle_chline;
extern int qbang;
extern int hlinesz;
extern void iaddtoline (int c);
extern void herrflush (void);
extern void strinbeg (int dohist);
extern void strinend (void);
extern void hbegin (int dohist);
extern void histreduceblanks (void);
extern void histremovedups (void);
extern zlong addhistnum (zlong hl,int n,int xflags);
extern Histent movehistent (Histent he,int n,int xflags);
extern Histent up_histent (Histent he);
extern Histent down_histent (Histent he);
extern Histent gethistent (zlong ev,int nearmatch);
extern Histent prepnexthistent (void);
extern int hend (Eprog prog);
extern int hwgetword;
extern void ihwbegin (int offset);
extern void ihwend (void);
extern void histbackword (void);
extern void hwrep (char*rep);
extern char*hgetline (void);
extern zlong hcomsearch (char*str);
extern int chabspath (char**junkptr);
extern int chrealpath (char**junkptr);
extern int remtpath (char**junkptr);
extern int remtext (char**junkptr);
extern int rembutext (char**junkptr);
extern int remlpaths (char**junkptr);
extern char*casemodify (char*str,int how);
extern int subst (char**strptr,char*in,char*out,int gbal);
extern void checkcurline (Histent he);
extern Histent quietgethist (int ev);
extern int quote (char**tr);
extern void inithist (void);
extern void resizehistents (void);
extern void readhistfile (char*fn,int err,int readflags);
extern void savehistfile (char*fn,int err,int writeflags);
extern int lockhistfile (char*fn,int keep_trying);
extern void unlockhistfile (char*fn);
extern int histfileIsLocked (void);
extern LinkList bufferwords (LinkList list,char*buf,int*index,int flags);
extern void histsplitwords (char*lineptr,short**wordsp,int*nwordsp,int*nwordposp,int uselex);
extern int pushhiststack (char*hf,zlong hs,zlong shs,int level);
extern int pophiststack (void);
extern int saveandpophiststack (int pop_through,int writeflags);
// # 42 "zsh.mdh" 2
// # 1 "init.epro" 1




extern int noexitct;
extern char*zunderscore;
extern int underscorelen;
extern int underscoreused;
extern int sourcelevel;
extern int SHTTY;
extern FILE*shout;
extern char*tcstr[34];
extern int tclen[34];
extern int tclines;
extern int tccolumns;
extern int hasam;
extern int hasxn;
extern int tccolours;
extern sigset_t sigchld_mask;
extern struct hookdef zshhooks[];
extern enum loop_return loop (int toplevel,int justonce);
extern char*parseopts (char*nam,char***argvp);
extern void init_io (void);
extern void init_shout (void);
extern char*tccap_get_name (int cap);
extern int init_term (void);
extern void setupvals (void);
extern void init_signals (void);
extern void run_init_scripts (void);
extern void init_misc (void);
extern enum source_return source (char*s);
extern void sourcehome (char*s);
extern void init_bltinmods (void);
extern void noop_function (void);
extern void noop_function_int (int nothing __attribute__((__unused__)));
extern ZleEntryPoint zle_entry_ptr;
extern int zle_load_state;
extern char * zleentry(int cmd, ...);
extern CompctlReadFn compctlreadptr;
extern int fallback_compctlread (char*name,char**args __attribute__((__unused__)),Options ops __attribute__((__unused__)),char*reply __attribute__((__unused__)));
extern int use_exit_printed;
extern int zsh_main (int argc __attribute__((__unused__)),char**argv);
// # 43 "zsh.mdh" 2
// # 1 "input.epro" 1




extern int SHIN;
extern FILE*bshin;
extern int strin;
extern int inbufct;
extern int inbufflags;
extern char*shingetline (void);
extern int ingetc (void);
extern void inungetc (int c);
extern int stuff (char*fn);
extern void inerrflush (void);
extern void inpush (char*str,int flags,Alias inalias);
extern void inpop (void);
extern void inpopalias (void);
extern char*ingetptr (void);
// # 44 "zsh.mdh" 2
// # 1 "jobs.epro" 1




extern pid_t origpgrp;
extern pid_t mypgrp;
extern int thisjob;
extern int curjob;
extern int prevjob;
extern struct job*jobtab;
extern int jobtabsize;
extern int maxjob;



extern int ttyfrozen;
extern int prev_errflag;
extern int prev_breaks;
extern int errbrk_saved;
extern int numpipestats;
extern int pipestats[256];
extern long lastpid_status;
extern void makerunning (Job jn);
extern int findproc (pid_t pid,Job*jptr,Process*pptr,int aux);
extern int hasprocs (int job);
extern void get_usage (void);
extern void update_process (Process pn,int status);
extern void check_cursh_sig (int sig);
extern void update_job (Job jn);


extern int printjob (Job jn,int lng,int synch);
extern void deletefilelist (LinkList file_list,int disowning);
extern void freejob (Job jn,int deleting);
extern void deletejob (Job jn,int disowning);
extern void addproc (pid_t pid,char*text,int aux,struct timeval*bgtime);
extern int havefiles (void);
extern int waitforpid (pid_t pid,int wait_cmd);
extern void waitjobs (void);
extern void clearjobtab (int monitor);
extern int initjob (void);
extern void setjobpwd (void);
extern void spawnjob (void);
extern void shelltime (void);
extern void scanjobs (void);
extern int getjob (const char*s,const char*prog);
extern void init_jobs (char**argv,char**envp);
extern int expandjobtab (void);
extern void maybeshrinkjobtab (void);
extern int bin_fg (char*name,char**argv,Options ops,int func);
extern int bin_kill (char*nam,char**argv,Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern int getsignum (const char*s);
extern const char*getsigname (int sig);
extern HashNode gettrapnode (int sig,int ignoredisable);
extern void removetrapnode (int sig);
extern int bin_suspend (char*name,char**argv __attribute__((__unused__)),Options ops,int func __attribute__((__unused__)));
extern int findjobnam (const char*s);
extern void acquire_pgrp (void);
extern void release_pgrp (void);
// # 45 "zsh.mdh" 2
// # 1 "lex.epro" 1




extern char ztokens[];
extern char*zshlextext;
extern char*tokstr;
extern int tok;
extern int tokfd;
extern zlong toklineno;
extern int lexstop;
extern int isfirstln;
extern int isfirstch;
extern int inalmore;
extern int nocorrect;
extern int zlemetacs;
extern int zlemetall;
extern int inwhat;
extern int addedx;
extern int wb;
extern int we;
extern int noaliases;
extern int lexflags;
extern int wordbeg;
extern int parbegin;
extern int parend;
extern int nocomments;
extern char*tokstrings[WHILE+1];
extern void lexsave (void);
extern void lexrestore (void);
extern void zshlex (void);
extern void ctxtlex (void);
extern void initlextabs (void);
extern void lexinit (void);
extern void add (int c);
extern int parsestr (char*s);
extern int parsestrnoerr (char*s);
extern char*parse_subscript (char*s,int sub,int endchar);
extern int parse_subst_string (char*s);
extern void gotword (void);
extern int exalias (void);
// # 46 "zsh.mdh" 2
// # 1 "linklist.epro" 1




extern LinkList newlinklist (void);
extern LinkList znewlinklist (void);
extern LinkNode insertlinknode (LinkList list,LinkNode node,void*dat);
extern LinkNode zinsertlinknode (LinkList list,LinkNode node,void*dat);
extern LinkNode uinsertlinknode (LinkList list,LinkNode node,LinkNode new);
extern void insertlinklist (LinkList l,LinkNode where,LinkList x);
extern void*getlinknode (LinkList list);
extern void*ugetnode (LinkList list);
extern void*remnode (LinkList list,LinkNode nd);
extern void*uremnode (LinkList list,LinkNode nd);
extern void freelinklist (LinkList list,FreeFunc freefunc);
extern int countlinknodes (LinkList list);
extern void rolllist (LinkList l,LinkNode nd);
extern LinkList newsizedlist (int size);
extern LinkNode linknodebydatum (LinkList list,void*dat);
extern LinkNode linknodebystring (LinkList list,char*dat);
extern char**hlinklist2array (LinkList list,int copy);
extern char**zlinklist2array (LinkList list);
// # 47 "zsh.mdh" 2
// # 1 "loop.epro" 1




extern int loops;
extern int contflag;
extern int breaks;
extern int execfor (Estate state,int do_exec);
extern int execselect (Estate state,int do_exec __attribute__((__unused__)));
extern size_t selectlist (LinkList l,size_t start);
extern int execwhile (Estate state,int do_exec __attribute__((__unused__)));
extern int execrepeat (Estate state,int do_exec __attribute__((__unused__)));
extern int execif (Estate state,int do_exec);
extern int execcase (Estate state,int do_exec);
extern zlong try_errflag;
extern zlong try_tryflag;
extern int exectry (Estate state,int do_exec);
// # 48 "zsh.mdh" 2
// # 1 "math.epro" 1




extern int noeval;
extern mnumber zero_mnumber;
extern mnumber lastmathval;
extern int lastbase;
extern int outputradix;
extern void op (int what);
extern mnumber matheval (char*s);
extern zlong mathevali (char*s);
extern zlong mathevalarg (char*s,char**ss);
// # 49 "zsh.mdh" 2
// # 1 "mem.epro" 1







extern Heap new_heaps (void);
extern void old_heaps (Heap old);
extern Heap switch_heaps (Heap new);
extern void pushheap (void);
extern void freeheap (void);
extern void popheap (void);
extern void*zheapptr (void*p);
extern void*zhalloc (size_t size);
extern void*hrealloc (char*p,size_t old,size_t new);



extern void*hcalloc (size_t size);
extern void*zalloc (size_t size);
extern void*zshcalloc (size_t size);
extern void*zrealloc (void*ptr,size_t size);





extern void zfree (void*p,int sz __attribute__((__unused__)));
extern void zsfree (char*p);
// # 50 "zsh.mdh" 2
// # 1 "module.epro" 1




extern LinkList linkedmodules;
extern char**module_path;
extern HashTable modulestab;
extern HashTable newmoduletable (int size,char const*name);
extern int setup_zshQsmain (Module m __attribute__((__unused__)));
extern int features_zshQsmain (Module m __attribute__((__unused__)),char***features __attribute__((__unused__)));
extern int enables_zshQsmain (Module m __attribute__((__unused__)),int**enables __attribute__((__unused__)));
extern int boot_zshQsmain (Module m __attribute__((__unused__)));
extern int cleanup_zshQsmain (Module m __attribute__((__unused__)));
extern int finish_zshQsmain (Module m __attribute__((__unused__)));
extern void register_module (char*n,Module_void_func setup,Module_features_func features,Module_enables_func enables,Module_void_func boot,Module_void_func cleanup,Module_void_func finish);
extern Linkedmod module_linked (char const*name);
extern int deletebuiltin (const char*nam);
extern int addbuiltins (char const*nam,Builtin binl,int size);
extern FuncWrap wrappers;
extern int addwrapper (Module m,FuncWrap w);
extern int deletewrapper (Module m,FuncWrap w);
extern Conddef condtab;
extern Conddef getconddef (int inf,const char*name,int autol);
extern int deleteconddef (Conddef c);
extern Hookdef hooktab;
extern Hookdef gethookdef (char*n);
extern int addhookdef (Hookdef h);
extern int addhookdefs (Module m,Hookdef h,int size);
extern int deletehookdef (Hookdef h);
extern int deletehookdefs (Module m __attribute__((__unused__)),Hookdef h,int size);
extern int addhookdeffunc (Hookdef h,Hookfn f);
extern int addhookfunc (char*n,Hookfn f);
extern int deletehookdeffunc (Hookdef h,Hookfn f);
extern int deletehookfunc (char*n,Hookfn f);
extern int runhookdef (Hookdef h,void*d);
extern int addparamdef (Paramdef d);
extern int deleteparamdef (Paramdef d);
extern MathFunc mathfuncs;
extern void removemathfunc (MathFunc previous,MathFunc current);
extern MathFunc getmathfunc (const char*name,int autol);
extern int deletemathfunc (MathFunc f);
// # 50 "module.epro"
extern int module_loaded (const char*name);






extern int load_module (char const*name,Feature_enables enablesarr,int silent);
extern int require_module (const char*module,Feature_enables features);
extern void add_dep (const char*name,char*from);
extern int bin_zmodload (char*nam,char**args,Options ops,int func __attribute__((__unused__)));
extern int unload_module (Module m);
extern int unload_named_module (char*modname,char*nam,int silent);
extern char**featuresarray (Module m __attribute__((__unused__)),Features f);
extern int*getfeatureenables (Module m __attribute__((__unused__)),Features f);
extern int setfeatureenables (Module m,Features f,int*e);
extern int handlefeatures (Module m,Features f,int**enables);
extern int ensurefeature (const char*modname,const char*prefix,const char*feature);
extern int autofeatures (const char*cmdnam,const char*module,char**features,int prefchar,int defflags);
// # 51 "zsh.mdh" 2
// # 1 "options.epro" 1




extern int emulation;
extern int sticky_emulation;
extern char opts[OPT_SIZE];
extern HashTable optiontab;
extern void createoptiontable (void);
extern void installemulation (void);
extern void emulate (const char*zsh_name,int fully);
extern int bin_setopt (char*nam,char**args,Options ops __attribute__((__unused__)),int isun);
extern int optlookup (char const*name);
extern int optlookupc (char c);
extern int dosetopt (int optno,int value,int force);
extern char*dashgetfn (Param pm __attribute__((__unused__)));
extern void printoptionstates (int hadplus);
extern void printoptionlist (void);
// # 52 "zsh.mdh" 2
// # 1 "params.epro" 1




extern int locallevel;
extern char**pparams;
extern char**cdpath;
extern char**fpath;
extern char**mailpath;
extern char**manpath;
extern char**psvar;
extern char**watch;
extern char**zsh_eval_context;
extern char**path;
extern char**fignore;
extern char*argzero;
extern char*home;
extern char*nullcmd;
extern char*oldpwd;
extern char*zoptarg;
extern char*prompt;
extern char*prompt2;
extern char*prompt3;
extern char*prompt4;
extern char*readnullcmd;
extern char*rprompt;
extern char*rprompt2;
extern char*sprompt;
extern char*wordchars;
extern char*zsh_name;
extern char*ifs;
extern char*postedit;
extern char*term;
extern char*zsh_terminfo;
extern char*ttystrname;
extern char*pwd;
extern zlong lastval;
extern zlong mypid;
extern zlong lastpid;
extern zlong zterm_columns;
extern zlong zterm_lines;
extern zlong ppid;
extern zlong zsh_subshell;
extern zlong lineno;
extern zlong zoptind;
extern zlong shlvl;
extern unsigned char bangchar;
extern unsigned char hatchar;
extern unsigned char hashchar;
extern unsigned char keyboardhackchar;
extern struct timeval shtimer;
extern int termflags;
extern const struct gsu_scalar stdscalar_gsu;
extern const struct gsu_scalar varscalar_gsu;
extern const struct gsu_scalar nullsetscalar_gsu;
extern const struct gsu_integer stdinteger_gsu;
extern const struct gsu_integer varinteger_gsu;
extern const struct gsu_integer nullsetinteger_gsu;
extern const struct gsu_float stdfloat_gsu;
extern const struct gsu_array stdarray_gsu;
extern const struct gsu_array vararray_gsu;
extern const struct gsu_hash stdhash_gsu;
extern const struct gsu_hash nullsethash_gsu;
extern HashTable paramtab;
extern HashTable realparamtab;
extern HashTable newparamtable (int size,char const*name);
extern HashTable copyparamtable (HashTable ht,char*name);
extern void deleteparamtable (HashTable t);
extern void scancountparams (HashNode hn __attribute__((__unused__)),int flags);
extern char**paramvalarr (HashTable ht,int flags);
extern void createparamtable (void);
extern void assigngetset (Param pm);
extern Param createparam (char*name,int flags);
extern Param createspecialhash (char*name,GetNodeFunc get,ScanTabFunc scan,int flags);
extern void copyparam (Param tpm,Param pm,int fakecopy);
extern int isident (char*s);
extern int getindex (char**pptr,Value v,int flags);
extern Value getvalue (Value v,char**pptr,int bracks);
extern Value fetchvalue (Value v,char**pptr,int bracks,int flags);
extern char*getstrvalue (Value v);
extern char**getarrvalue (Value v);
extern zlong getintvalue (Value v);
extern mnumber getnumvalue (Value v);
extern void export_param (Param pm);
extern void setstrvalue (Value v,char*val);
extern void setnumvalue (Value v,mnumber val);
extern void setarrvalue (Value v,char**val);
extern zlong getiparam (char*s);
extern mnumber getnparam (char*s);
extern char*getsparam (char*s);
extern char**getaparam (char*s);
extern char**gethparam (char*s);
extern char**gethkparam (char*s);
extern Param assignsparam (char*s,char*val,int flags);
extern Param assignaparam (char*s,char**val,int flags);
extern Param sethparam (char*s,char**val);
extern Param setnparam (char*s,mnumber val);
extern Param setiparam (char*s,zlong val);
extern void unsetparam (char*s);
extern int unsetparam_pm (Param pm,int altflag,int exp);
extern void stdunsetfn (Param pm,int exp __attribute__((__unused__)));
extern zlong intgetfn (Param pm);
extern char*strgetfn (Param pm);
extern void strsetfn (Param pm,char*x);
extern char**arrgetfn (Param pm);
extern void arrsetfn (Param pm,char**x);
extern HashTable hashgetfn (Param pm);
extern void hashsetfn (Param pm,HashTable x);
extern void nullsethashfn (Param pm __attribute__((__unused__)),HashTable x);
extern void arrhashsetfn (Param pm,char**val,int augment);
extern void nullstrsetfn (Param pm __attribute__((__unused__)),char*x);
extern void nullintsetfn (Param pm __attribute__((__unused__)),zlong x __attribute__((__unused__)));
extern void nullunsetfn (Param pm __attribute__((__unused__)),int exp __attribute__((__unused__)));
extern zlong intvargetfn (Param pm);
extern void intvarsetfn (Param pm,zlong x);
extern void zlevarsetfn (Param pm,zlong x);
extern void strvarsetfn (Param pm,char*x);
extern char*strvargetfn (Param pm);
extern char**arrvargetfn (Param pm);
extern void arrvarsetfn (Param pm,char**x);
extern char*colonarrgetfn (Param pm);
extern void colonarrsetfn (Param pm,char*x);
extern char*tiedarrgetfn (Param pm);
extern void tiedarrsetfn (Param pm,char*x);
extern void tiedarrunsetfn (Param pm,int exp __attribute__((__unused__)));
extern HashTable newuniqtable (zlong size);
extern void uniqarray (char**x);
extern void zhuniqarray (char**x);
extern zlong poundgetfn (Param pm __attribute__((__unused__)));
extern zlong randomgetfn (Param pm __attribute__((__unused__)));
extern void randomsetfn (Param pm __attribute__((__unused__)),zlong v);
extern zlong intsecondsgetfn (Param pm __attribute__((__unused__)));
extern void intsecondssetfn (Param pm __attribute__((__unused__)),zlong x);
extern double floatsecondsgetfn (Param pm __attribute__((__unused__)));
extern void floatsecondssetfn (Param pm __attribute__((__unused__)),double x);
extern double getrawseconds (void);
extern void setrawseconds (double x);
extern int setsecondstype (Param pm,int on,int off);
extern char*usernamegetfn (Param pm __attribute__((__unused__)));
extern void usernamesetfn (Param pm __attribute__((__unused__)),char*x);
extern zlong uidgetfn (Param pm __attribute__((__unused__)));
extern void uidsetfn (Param pm __attribute__((__unused__)),zlong x);
extern zlong euidgetfn (Param pm __attribute__((__unused__)));
extern void euidsetfn (Param pm __attribute__((__unused__)),zlong x);
extern zlong gidgetfn (Param pm __attribute__((__unused__)));
extern void gidsetfn (Param pm __attribute__((__unused__)),zlong x);
extern zlong egidgetfn (Param pm __attribute__((__unused__)));
extern void egidsetfn (Param pm __attribute__((__unused__)),zlong x);
extern zlong ttyidlegetfn (Param pm __attribute__((__unused__)));
extern char*ifsgetfn (Param pm __attribute__((__unused__)));
extern void ifssetfn (Param pm __attribute__((__unused__)),char*x);
extern void lc_allsetfn (Param pm,char*x);
extern void langsetfn (Param pm,char*x);
extern void lcsetfn (Param pm,char*x);
extern zlong histsizegetfn (Param pm __attribute__((__unused__)));
extern void histsizesetfn (Param pm __attribute__((__unused__)),zlong v);
extern zlong savehistsizegetfn (Param pm __attribute__((__unused__)));
extern void savehistsizesetfn (Param pm __attribute__((__unused__)),zlong v);
extern void errnosetfn (Param pm __attribute__((__unused__)),zlong x);
extern zlong errnogetfn (Param pm __attribute__((__unused__)));
extern char*keyboardhackgetfn (Param pm __attribute__((__unused__)));
extern void keyboardhacksetfn (Param pm __attribute__((__unused__)),char*x);
extern char*histcharsgetfn (Param pm __attribute__((__unused__)));
extern void histcharssetfn (Param pm __attribute__((__unused__)),char*x);
extern char*homegetfn (Param pm __attribute__((__unused__)));
extern void homesetfn (Param pm __attribute__((__unused__)),char*x);
extern char*wordcharsgetfn (Param pm __attribute__((__unused__)));
extern void wordcharssetfn (Param pm __attribute__((__unused__)),char*x);
extern char*underscoregetfn (Param pm __attribute__((__unused__)));
extern char*termgetfn (Param pm __attribute__((__unused__)));
extern void termsetfn (Param pm __attribute__((__unused__)),char*x);
extern char*terminfogetfn (Param pm __attribute__((__unused__)));
extern void terminfosetfn (Param pm,char*x);
extern void arrfixenv (char*s,char**t);
extern int zputenv (char*str);


extern char*zgetenv (char*name);
extern void addenv (Param pm,char*value);
extern void delenvvalue (char*x);
extern void delenv (Param pm);
extern void convbase (char*s,zlong v,int base);
extern char*convfloat (double dval,int digits,int flags,FILE*fout);
extern void startparamscope (void);
extern void endparamscope (void);
extern void freeparamnode (HashNode hn);
extern void printparamnode (HashNode hn,int printflags);
// # 53 "zsh.mdh" 2
// # 1 "parse.epro" 1




extern int incmdpos;
extern int aliasspaceflag;
extern int incond;
extern int inredir;
extern int incasepat;
extern int isnewlin;
extern int infor;
extern struct heredocs*hdocs;
extern int eclen;
extern int ecused;
extern int ecnpats;
extern Wordcode ecbuf;
extern Eccstr ecstrs;
extern int ecsoffs;
extern int ecssub;
extern int ecnfunc;
extern int empty_eprog (Eprog p);
extern Eprog parse_event (void);
extern Eprog parse_list (void);
extern Eprog parse_cond (void);
extern void setheredoc (int pc,int type,char*str,char*termstr,char*munged_termstr);
extern void(*condlex)(void);
extern Eprog dupeprog (Eprog p,int heap);
extern void useeprog (Eprog p);
extern void freeeprog (Eprog p);
extern char*ecgetstr (Estate s,int dup,int*tok);
extern char*ecrawstr (Eprog p,Wordcode pc,int*tok);
extern char**ecgetarr (Estate s,int num,int dup,int*tok);
extern LinkList ecgetlist (Estate s,int num,int dup,int*tok);
extern LinkList ecgetredirs (Estate s);
extern struct eprog dummy_eprog;
extern void init_eprog (void);
extern int bin_zcompile (char*nam,char**args,Options ops,int func __attribute__((__unused__)));







extern Eprog try_dump_file (char*path,char*name,char*file,int*ksh);
extern Eprog try_source_file (char*file);
extern void incrdumpcount (FuncDump f);
extern void decrdumpcount (FuncDump f);
extern void closedumps (void);
extern void closedumps (void);
extern int dump_autoload (char*nam,char*file,int on,Options ops,int func);
// # 54 "zsh.mdh" 2
// # 1 "pattern.epro" 1




extern void patcompstart (void);
extern Patprog patcompile (char*exp,int inflags,char**endexp);
extern int patgetglobflags (char**strp,long*assertp,int*ignore);
extern int range_type (char*start,int len);
extern int pattern_range_to_string (char*rangestr,char*outstr);
extern int errsfound;
extern int forceerrs;
extern void pattrystart (void);
extern int pattry (Patprog prog,char*string);
extern int pattrylen (Patprog prog,char*string,int len,int unmetalen,int offset);
extern int pattryrefs (Patprog prog,char*string,int stringlen,int unmetalen,int patoffset,int*nump,int*begp,int*endp);
extern int patmatchlen (void);

extern int mb_patmatchrange (char*range,wchar_t ch,wint_t*indptr,int*mtp);
extern int mb_patmatchindex (char*range,wint_t ind,wint_t*chr,int*mtp);

extern int patmatchrange (char*range,int ch,int*indptr,int*mtp);



extern void freepatprog (Patprog prog);
// # 55 "zsh.mdh" 2
// # 1 "prompt.epro" 1




extern unsigned txtattrmask;
extern unsigned char*cmdstack;
extern int cmdsp;
extern char*promptexpand (char*s,int ns,char*rs,char*Rs,unsigned int*txtchangep);
extern void stradd (char*d);
extern void tsetcap (int cap,int flags);
extern int putstr (int d);
extern void countprompt (char*str,int*wp,int*hp,int overf);
extern void cmdpush (int cmdtok);
extern void cmdpop (void);
extern int match_colour (const char**teststrp,int is_fg,int colour);
extern void match_highlight (const char*teststr,int*on_var);
extern int output_highlight (int atr,char*buf);
extern void set_default_colour_sequences (void);
extern void allocate_colour_buffer (void);
extern void free_colour_buffer (void);
extern void set_colour_attribute (int atr,int fg_bg,int flags);
// # 56 "zsh.mdh" 2
// # 1 "signals.epro" 1




extern int sigtrapped[(31 +3)];
extern Eprog siglists[(31 +3)];
extern int nsigtrapped;
extern int queueing_enabled;
extern int queue_front;
extern int queue_rear;
extern int signal_queue[128];
extern sigset_t signal_mask_queue[128];
extern int trap_queueing_enabled;
extern int trap_queue_front;
extern int trap_queue_rear;
extern int trap_queue[128];
extern void install_handler (int sig);
extern void intr (void);
extern void holdintr (void);
extern void noholdintr (void);
extern sigset_t signal_mask (int sig);


extern sigset_t signal_setmask (sigset_t set);
extern int signal_suspend (int sig __attribute__((__unused__)),int wait_cmd);
extern int last_signal;
extern void wait_for_processes (void);
extern void zhandler (int sig);
extern void killrunjobs (int from_signal);
extern int killjb (Job jn,int sig);
extern int settrap (int sig,Eprog l,int flags);
extern void unsettrap (int sig);
extern HashNode removetrap (int sig);
extern void starttrapscope (void);
extern void endtrapscope (void);
extern void queue_traps (int wait_cmd);
extern void unqueue_traps (void);
extern int intrap;
extern int trapisfunc;
extern int traplocallevel;
extern void dotrap (int sig);
// # 57 "zsh.mdh" 2
// # 1 "signames.epro" 1





extern char*sig_msg[31 +2];
extern char*sigs[31 +4];
// # 58 "zsh.mdh" 2
// # 1 "sort.epro" 1




extern int zstrcmp (const char*as,const char*bs,int sortflags);
extern void strmetasort (char**array,int sortwhat,int*unmetalenp);
// # 59 "zsh.mdh" 2
// # 1 "string.epro" 1




extern char*dupstring (const char*s);
extern char*ztrdup (const char*s);

extern wchar_t*wcs_ztrdup (const wchar_t*s);

extern char*tricat (char const*s1,char const*s2,char const*s3);
extern char*zhtricat (char const*s1,char const*s2,char const*s3);
extern char*dyncat (const char*s1,const char*s2);
extern char*bicat (const char*s1,const char*s2);
extern char*dupstrpfx (const char*s,int len);
extern char*ztrduppfx (const char*s,int len);
extern char*appstr (char*base,char const*append);
extern char*strend (char*str);
// # 60 "zsh.mdh" 2
// # 1 "subst.epro" 1




extern char nulstring[];
extern void prefork (LinkList list,int flags);
extern char*quotesubst (char*str);
extern void globlist (LinkList list,int nountok);
extern void singsub (char**s);
extern void filesub (char**namptr,int assign);
extern char*equalsubstr (char*str,int assign,int nomatch);
extern int filesubstr (char**namptr,int assign);
extern char*get_strarg (char*s,int*lenp);
extern void modify (char**str,char**ptr);
// # 61 "zsh.mdh" 2
// # 1 "text.epro" 1




extern char*getpermtext (Eprog prog,Wordcode c,int start_indent);
extern char*getjobtext (Eprog prog,Wordcode c);
extern void getredirs (LinkList redirs);
// # 62 "zsh.mdh" 2
// # 1 "utils.epro" 1




extern char*scriptname;
extern char*scriptfilename;
extern int incompfunc;
extern void zerr(const char *fmt, ...);
extern void zerrnam(const char *cmd, const char *fmt, ...);
extern void zwarn(const char *fmt, ...);
extern void zwarnnam(const char *cmd, const char *fmt, ...);
extern void dputs(const char *message, ...);
extern void zerrmsg (FILE*file,const char*fmt,va_list ap);
extern int putraw (int c);
extern int putshout (int c);
extern char*nicechar (int c);

extern void mb_metacharinit (void);
extern char*wcs_nicechar (wchar_t c,size_t*widthp,char**swidep);
extern int zwcwidth (wint_t wc);

extern char*pathprog (char*prog,char**namep);
extern char*findpwd (char*s);
extern int ispwd (char*s);
extern char*xsymlink (char*s);
extern void print_if_link (char*s);
extern void fprintdir (char*s,FILE*f);
extern char*substnamedir (char*s);
extern uid_t cached_uid;
extern char*cached_username;
extern char*get_username (void);
extern Nameddir finddir (char*s);
extern void adduserdir (char*s,char*t,int flags,int always);
extern char*getnameddir (char*name);
extern void addprepromptfn (voidvoidfnptr_t func);
extern void delprepromptfn (voidvoidfnptr_t func);
extern LinkList timedfns;
extern void addtimedfn (voidvoidfnptr_t func,time_t when);
extern void deltimedfn (voidvoidfnptr_t func);
extern time_t lastmailcheck;
extern time_t lastwatch;
extern int callhookfunc (char*name,LinkList lnklst,int arrayp,int*retval);
extern void preprompt (void);
extern FILE*xtrerr;
extern void printprompt4 (void);
extern void freestr (void*a);
extern void gettyinfo (struct ttyinfo*ti);
extern void settyinfo (struct ttyinfo*ti);
extern struct ttyinfo shttyinfo;
extern int resetneeded;
extern int winchanged;
extern void adjustwinsize (int from);
extern int movefd (int fd);
extern int redup (int x,int y);
extern void addlockfd (int fd,int cloexec);
extern int zclose (int fd);
extern int zcloselockfd (int fd);
extern char*gettempname (const char*prefix,int use_heap);
extern int gettempfile (const char*prefix,int use_heap,char**tempname);
extern int has_token (const char*s);
extern void chuck (char*str);
extern int tulower (int c);
extern int tuupper (int c);
extern void ztrncpy (char*s,char*t,int len);
extern void strucpy (char**s,char*t);
extern void struncpy (char**s,char*t,int n);
extern int arrlen (char**s);
extern int skipparens (char inpar,char outpar,char**s);
extern zlong zstrtol (const char*s,char**t,int base);
extern int setblock_fd (int turnonblocking,int fd,long*modep);
extern int setblock_stdin (void);
extern int read_poll (int fd,int*readchar,int polltty,zlong microseconds);
extern int checkrmall (char*s);
extern ssize_t read_loop (int fd,char*buf,size_t len);
extern ssize_t write_loop (int fd,const char*buf,size_t len);
extern int noquery (int purge);
extern int getquery (char*valid_chars,int purge);
extern void spckword (char**s,int hist,int cmd,int ask);
extern int ztrftime (char*buf,int bufsize,char*fmt,struct tm*tm);
extern char*zjoin (char**arr,int delim,int heap);
extern char**colonsplit (char*s,int uniq);
extern char**spacesplit (char*s,int allownull,int heap,int quote);
extern char*findword (char**s,char*sep);
extern int wordcount (char*s,char*sep,int mul);
extern char*sepjoin (char**s,char*sep,int heap);
extern char**sepsplit (char*s,char*sep,int allownull,int heap);
extern Shfunc getshfunc (char*nam);
extern char**subst_string_by_func (Shfunc func,char*arg1,char*orig);
extern char**subst_string_by_hook (char*name,char*arg1,char*orig);
extern char**mkarray (char*s);
extern void zbeep (void);
extern void freearray (char**s);
extern int equalsplit (char*s,char**t);
extern short int typtab[256];
extern void inittyptab (void);
extern void makecommaspecial (int yesno);

extern int wcsiblank (wint_t wc);
extern int wcsitype (wchar_t c,int itype);

extern char*itype_end (const char*ptr,int itype,int once);
extern char**arrdup (char**s);
extern char**zarrdup (char**s);

extern wchar_t**wcs_zarrdup (wchar_t**s);

extern void setcbreak (void);
extern void attachtty (pid_t pgrp);
extern pid_t gettygrp (void);
extern char*metafy (char*buf,int len,int heap);
extern char*ztrdup_metafy (const char*s);
extern char*unmetafy (char*s,int*len);
extern int metalen (const char*s,int len);
extern char*unmeta (const char*file_name);
extern int ztrcmp (char const*s1,char const*s2);
extern int ztrlen (char const*s);
extern int ztrsub (char const*t,char const*s);
extern char*zreaddir (DIR*dir,int ignoredots);
extern int zputs (char const*s,FILE*stream);
extern char*nicedup (char const*s,int heap);
extern char*nicedupstring (char const*s);
extern int nicezputs (char const*s,FILE*stream);
extern size_t niceztrlen (char const*s);

extern size_t mb_niceformat (const char*s,FILE*stream,char**outstrp,int heap);
extern char*nicedup (const char*s,int heap);
extern int mb_metacharlenconv_r (const char*s,wint_t*wcp,mbstate_t*mbsp);
extern int mb_metacharlenconv (const char*s,wint_t*wcp);
extern int mb_metastrlen (char*ptr,int width);



extern int hasspecial (char const*s);
extern char*quotestring (const char*s,char**e,int instring);
extern int quotedzputs (char const*s,FILE*stream);
extern char*dquotedztrdup (char const*s);
extern char*getkeystring (char*s,int*len,int how,int*misc);
extern int strpfx (const char*s,const char*t);
extern int strsfx (char*s,char*t);
extern void init_dirsav (Dirsav d);
extern int lchdir (char const*path,struct dirsav*d,int hard);
extern int restoredir (struct dirsav*d);
extern int privasserted (void);
extern int mode_to_octal (mode_t mode);
extern int mailstat (char*path,struct stat*st);
// # 63 "zsh.mdh" 2
// # 1 "watch.epro" 1




extern char const*const default_watchfmt;
extern void dowatch (void);
extern int bin_log (char*nam __attribute__((__unused__)),char**argv __attribute__((__unused__)),Options ops __attribute__((__unused__)),int func __attribute__((__unused__)));
extern void dowatch (void);
extern int bin_log (char*nam,char**argv,Options ops,int func);
// # 64 "zsh.mdh" 2
// # 34 "builtin.c" 2
// # 1 "builtin.pro" 1

static void printbuiltinnode (HashNode hn,int printflags);
static void freebuiltinnode (HashNode hn);
static int new_optarg (Options ops);
static LinkNode cd_get_dest (char*nam,char**argv,int hard,int func);
static char*cd_do_chdir (char*cnam,char*dest,int hard);
static char*cd_try_chdir (char*pfix,char*dest,int hard);
static void cd_new_pwd (int func,LinkNode dir,int quiet);
static void printdirstack (void);
static zlong fcgetcomm (char*s);
static int fcsubs (char**sp,struct asgment*sub);
static int fclist (FILE*f,Options ops,zlong first,zlong last,struct asgment*subs,Patprog pprog,int is_command);
static int fcedit (char*ename,char*fn);
static Asgment getasg (char*s);
static Param typeset_single (char*cname,char*pname,Param pm,int func __attribute__((__unused__)),int on,int off,int roff,char*value,Param altpm,Options ops,int joinchar);
static void checkjobs (void);
static int zread (int izle,int*readchar,long izle_timeout);
// # 35 "builtin.c" 2



static struct builtin builtins[] =
{
    { { ((void *)0), "-", (1<<6) | (1<<5) }, ((HandlerFunc) 0), 0, 0, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "builtin", (1<<7) | (1<<5) }, ((HandlerFunc) 0), 0, 0, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "command", (1<<8) | (1<<5) }, ((HandlerFunc) 0), 0, 0, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "exec", (1<<9) | (1<<5) }, ((HandlerFunc) 0), 0, 0, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "noglob", (1<<10) | (1<<5) }, ((HandlerFunc) 0), 0, 0, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "[", (1<<18) }, bin_test, 0, -1, 21, ((void *)0), ((void *)0) },
    { { ((void *)0), ".", (1<<11) }, bin_dot, 1, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), ":", (1<<11) }, bin_true, 0, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "alias", (1<<4) | (1<<1) }, bin_alias, 0, -1, 0, "Lgmrs", ((void *)0) },
    { { ((void *)0), "autoload", (1<<1) }, bin_functions, 0, -1, 0, "ktUwXz", "u" },
    { { ((void *)0), "bg", 0 }, bin_fg, 0, -1, 1, ((void *)0), ((void *)0) },
    { { ((void *)0), "break", (1<<11) }, bin_break, 0, 1, 6, ((void *)0), ((void *)0) },
    { { ((void *)0), "bye", 0 }, bin_break, 0, 1, 8, ((void *)0), ((void *)0) },
    { { ((void *)0), "cd", (1<<12) | (1<<14) | (1<<15) }, bin_cd, 0, 2, 10, "qsPL", ((void *)0) },
    { { ((void *)0), "chdir", (1<<12) | (1<<14) | (1<<15) }, bin_cd, 0, 2, 10, "qsPL", ((void *)0) },
    { { ((void *)0), "continue", (1<<11) }, bin_break, 0, 1, 7, ((void *)0), ((void *)0) },
    { { ((void *)0), "declare", (1<<1) | (1<<4) | (1<<11) }, bin_typeset, 0, -1, 0, "AE:%F:%HL:%R:%TUZ:%afghi:%klmprtuxz", ((void *)0) },
    { { ((void *)0), "dirs", 0 }, bin_dirs, 0, -1, 0, "clpv", ((void *)0) },
    { { ((void *)0), "disable", 0 }, bin_enable, 0, -1, 24, "afmrs", ((void *)0) },
    { { ((void *)0), "disown", 0 }, bin_fg, 0, -1, 5, ((void *)0), ((void *)0) },
    { { ((void *)0), "echo", (1<<12) }, bin_print, 0, -1, 23, "neE", "-" },
    { { ((void *)0), "emulate", 0 }, bin_emulate, 0, -1, 0, "LR", ((void *)0) },
    { { ((void *)0), "enable", 0 }, bin_enable, 0, -1, 25, "afmrs", ((void *)0) },
    { { ((void *)0), "eval", (1<<11) }, bin_eval, 0, -1, 14, ((void *)0), ((void *)0) },
    { { ((void *)0), "exit", (1<<11) }, bin_break, 0, 1, 8, ((void *)0), ((void *)0) },
    { { ((void *)0), "export", (1<<1) | (1<<4) | (1<<11) }, bin_typeset, 0, -1, 22, "E:%F:%HL:%R:%TUZ:%afhi:%lprtu", "xg" },
    { { ((void *)0), "false", 0 }, bin_false, 0, -1, 0, ((void *)0), ((void *)0) },





    { { ((void *)0), "fc", 0 }, bin_fc, 0, -1, 16, "aAdDe:EfiIlmnpPrRt:W", ((void *)0) },
    { { ((void *)0), "fg", 0 }, bin_fg, 0, -1, 2, ((void *)0), ((void *)0) },
    { { ((void *)0), "float", (1<<1) | (1<<4) | (1<<11) }, bin_typeset, 0, -1, 0, "E:%F:%HL:%R:%Z:%ghlprtux", "E" },
    { { ((void *)0), "functions", (1<<1) }, bin_functions, 0, -1, 0, "kmMtuUz", ((void *)0) },
    { { ((void *)0), "getln", 0 }, bin_read, 0, -1, 0, "ecnAlE", "zr" },
    { { ((void *)0), "getopts", 0 }, bin_getopts, 2, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "hash", (1<<4) }, bin_hash, 0, -1, 0, "Ldfmrv", ((void *)0) },





    { { ((void *)0), "history", 0 }, bin_fc, 0, -1, 16, "adDEfimnpPrt:", "l" },
    { { ((void *)0), "integer", (1<<1) | (1<<4) | (1<<11) }, bin_typeset, 0, -1, 0, "HL:%R:%Z:%ghi:%lprtux", "i" },
    { { ((void *)0), "jobs", 0 }, bin_fg, 0, -1, 3, "dlpZrs", ((void *)0) },
    { { ((void *)0), "kill", (1<<18) }, bin_kill, 0, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "let", 0 }, bin_let, 1, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "local", (1<<1) | (1<<4) | (1<<11) }, bin_typeset, 0, -1, 0, "AE:%F:%HL:%R:%TUZ:%ahi:%lprtux", ((void *)0) },
    { { ((void *)0), "log", 0 }, bin_log, 0, 0, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "logout", 0 }, bin_break, 0, 1, 19, ((void *)0), ((void *)0) },
// # 101 "builtin.c"
    { { ((void *)0), "popd", (1<<12) | (1<<14) | (1<<15) }, bin_cd, 0, 1, 11, "q", ((void *)0) },
    { { ((void *)0), "print", (1<<2) }, bin_print, 0, -1, 13, "abcC:Df:ilmnNoOpPrRsSu:z-", ((void *)0) },
    { { ((void *)0), "printf", 0 }, bin_print, 1, -1, 26, ((void *)0), ((void *)0) },
    { { ((void *)0), "pushd", (1<<12) | (1<<14) | (1<<15) }, bin_cd, 0, 2, 12, "qsPL", ((void *)0) },
    { { ((void *)0), "pushln", 0 }, bin_print, 0, -1, 13, ((void *)0), "-nz" },
    { { ((void *)0), "pwd", 0 }, bin_pwd, 0, 0, 0, "rLP", ((void *)0) },
    { { ((void *)0), "r", 0 }, bin_fc, 0, -1, 17, "nrl", ((void *)0) },
    { { ((void *)0), "read", 0 }, bin_read, 0, -1, 0, "cd:ek:%lnpqrst:%zu:AE", ((void *)0) },
    { { ((void *)0), "readonly", (1<<1) | (1<<4) | (1<<11) }, bin_typeset, 0, -1, 0, "AE:%F:%HL:%R:%TUZ:%afghi:%lptux", "r" },
    { { ((void *)0), "rehash", 0 }, bin_hash, 0, 0, 0, "df", "r" },
    { { ((void *)0), "return", (1<<11) }, bin_break, 0, 1, 9, ((void *)0), ((void *)0) },
    { { ((void *)0), "set", (1<<11) | (1<<18) }, bin_set, 0, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "setopt", 0 }, bin_setopt, 0, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "shift", (1<<11) }, bin_shift, 0, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "source", (1<<11) }, bin_dot, 1, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "suspend", 0 }, bin_suspend, 0, 0, 0, "f", ((void *)0) },
    { { ((void *)0), "test", (1<<18) }, bin_test, 0, -1, 20, ((void *)0), ((void *)0) },
    { { ((void *)0), "ttyctl", 0 }, bin_ttyctl, 0, 0, 0, "fu", ((void *)0) },
    { { ((void *)0), "times", (1<<11) }, bin_times, 0, 0, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "trap", (1<<11) | (1<<18) }, bin_trap, 0, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "true", 0 }, bin_true, 0, -1, 0, ((void *)0), ((void *)0) },
    { { ((void *)0), "type", 0 }, bin_whence, 0, -1, 0, "ampfsw", "v" },
    { { ((void *)0), "typeset", (1<<1) | (1<<4) | (1<<11) }, bin_typeset, 0, -1, 0, "AE:%F:%HL:%R:%TUZ:%afghi:%klprtuxmz", ((void *)0) },
    { { ((void *)0), "umask", 0 }, bin_umask, 0, 1, 0, "S", ((void *)0) },
    { { ((void *)0), "unalias", 0 }, bin_unhash, 1, -1, 0, "ms", "a" },
    { { ((void *)0), "unfunction", 0 }, bin_unhash, 1, -1, 0, "m", "f" },
    { { ((void *)0), "unhash", 0 }, bin_unhash, 1, -1, 0, "adfms", ((void *)0) },
    { { ((void *)0), "unset", (1<<11) }, bin_unset, 1, -1, 0, "fmv", ((void *)0) },
    { { ((void *)0), "unsetopt", 0 }, bin_setopt, 0, -1, 1, ((void *)0), ((void *)0) },
    { { ((void *)0), "wait", 0 }, bin_fg, 0, -1, 4, ((void *)0), ((void *)0) },
    { { ((void *)0), "whence", 0 }, bin_whence, 0, -1, 0, "acmpvfsw", ((void *)0) },
    { { ((void *)0), "where", 0 }, bin_whence, 0, -1, 0, "pmsw", "ca" },
    { { ((void *)0), "which", 0 }, bin_whence, 0, -1, 0, "ampsw", "c" },
    { { ((void *)0), "zmodload", 0 }, bin_zmodload, 0, -1, 0, "AFRILP:abcfdilmpue", ((void *)0) },
    { { ((void *)0), "zcompile", 0 }, bin_zcompile, 0, -1, 0, "tUMRcmzka", ((void *)0) },
};
// # 145 "builtin.c"
 HashTable builtintab;


void
createbuiltintable(void)
{
    builtintab = newhashtable(85, "builtintab", ((void *)0));

    builtintab->hash = hasher;
    builtintab->emptytable = ((void *)0);
    builtintab->filltable = ((void *)0);
    builtintab->cmpnodes = strcmp;
    builtintab->addnode = addhashnode;
    builtintab->getnode = gethashnode;
    builtintab->getnode2 = gethashnode2;
    builtintab->removenode = removehashnode;
    builtintab->disablenode = disablehashnode;
    builtintab->enablenode = enablehashnode;
    builtintab->freenode = freebuiltinnode;
    builtintab->printnode = printbuiltinnode;

    (void)addbuiltins("zsh", builtins, sizeof(builtins)/sizeof(*builtins));
}




static void
printbuiltinnode(HashNode hn, int printflags)
{
    Builtin bn = (Builtin) hn;

    if (printflags & (1<<10)) {
 printf("%s: builtin\n", bn->node.nam);
 return;
    }

    if (printflags & (1<<5)) {
 printf("%s: shell built-in command\n", bn->node.nam);
 return;
    }

    if (printflags & (1<<6)) {
 printf("%s is a shell builtin\n", bn->node.nam);
 return;
    }


    printf("%s\n", bn->node.nam);
}


static void
freebuiltinnode(HashNode hn)
{
    Builtin bn = (Builtin) hn;

    if(!(bn->node.flags & (1<<3))) {
 zsfree(bn->node.nam);
 zsfree(bn->optstr);
 zfree(bn, sizeof(struct builtin));
    }
}


void
init_builtins(void)
{
    if (!(emulation & ((1<<4)))) {
 HashNode hn = reswdtab->getnode2(reswdtab, "repeat");
 if (hn)
     reswdtab->disablenode(hn, 0);
    }
}






static int
new_optarg(Options ops)
{

    if (ops->argscount == 63)
 return 1;
    if (ops->argsalloc == ops->argscount) {
 char **newptr =
     (char **)zhalloc((ops->argsalloc + 16) *
        sizeof(char *));
 if (ops->argsalloc)
     memcpy(newptr, ops->args, ops->argsalloc * sizeof(char *));
 ops->args = newptr;
 ops->argsalloc += 16;
    }
    ops->argscount++;
    return 0;
}





int
execbuiltin(LinkList args, Builtin bn)
{
    char *pp, *name, *optstr;
    int flags, sense, argc, execop, xtr = (opts[XTRACE]);
    struct options ops;


    memset(ops.ind, 0, 128*sizeof(unsigned char));
    ops.args = ((void *)0);
    ops.argscount = ops.argsalloc = 0;


    name = (char *) ugetnode(args);

    if (!bn->handlerfunc) {
 ;
 deletebuiltin(bn->node.nam);
 return 1;
    }

    flags = bn->node.flags;
    optstr = bn->optstr;



    argc = countlinknodes(args);

    {






 char * (argarr)[argc + 1];
 char **argv;





 argv = argarr;
 while ((*argv++ = (char *)ugetnode(args)));
 argv = argarr;


 if (optstr) {
     char *arg = *argv;

     while (arg &&

     ((sense = (*arg == '-')) ||
      ((flags & (1<<1)) && *arg == '+'))) {

  if (!(flags & (1<<13)) && (typtab[((unsigned char)(arg[1]))] & (1 << 0)))
      break;

  if ((flags & (1<<14)) && !arg[1])
      break;
  if ((flags & (1<<15)) && !strcmp(arg, "--")) {




      argv++;
      break;
  }
// # 325 "builtin.c"
  if (flags & (1<<12)) {
      char *p = arg;
      while (*++p && strchr(optstr, (int) *p));
      if (*p)
   break;
  }


  if (arg[1] == '-')
      arg++;
  if (!arg[1]) {
      ops.ind['-'] = 1;
      if (!sense)
   ops.ind['+'] = 1;
  }

  while (*++arg) {
      char *optptr;
      if ((optptr = strchr(optstr, execop = (int)*arg))) {
   ops.ind[(int)*arg] = (sense) ? 1 : 2;
   if (optptr[1] == ':') {
       char *argptr = ((void *)0);
       if (optptr[2] == ':') {
    if (arg[1])
        argptr = arg+1;

       } else if (optptr[2] == '%') {


    if (arg[1] && (typtab[((unsigned char)(arg[1]))] & (1 << 0)))
        argptr = arg+1;
    else if (argv[1] && (typtab[((unsigned char)(*argv[1]))] & (1 << 0)))
        argptr = arg = *++argv;
       } else {

    if (arg[1])
        argptr = arg+1;
    else if ((arg = *++argv))
        argptr = arg;
    else {
        zwarnnam(name, "argument expected: -%c",
          execop);
        return 1;
    }
       }
       if (argptr) {
    if (new_optarg(&ops)) {
        zwarnnam(name,
          "too many option arguments");
        return 1;
    }
    ops.ind[execop] |= ops.argscount << 2;
    ops.args[ops.argscount-1] = argptr;
    while (arg[1])
        arg++;
       }
   }
      } else
   break;
  }


  if (*arg) {
      if(*arg == ((char) 0x83))
   *++arg ^= 32;
      zwarn("bad option: -%c", *arg);
      return 1;
  }
  arg = *++argv;


  if ((flags & (1<<2)) && ops.ind['R'] &&
      !ops.ind['f']) {
      optstr = "ne";
      flags |= (1<<12);
  }

  if (ops.ind['-'])
      break;
     }
 } else if (!(flags & (1<<18)) && *argv &&
     !strcmp(*argv, "--")) {
     ops.ind['-'] = 1;
     argv++;
 }


 if ((pp = bn->defopts)) {
     while (*pp) {

  if (!ops.ind[(int)*pp])
      ops.ind[(int)*pp] = 1;
  pp++;
     }
 }


 argc -= argv - argarr;

 if (errflag) {
     errflag = 0;
     return 1;
 }


 if (argc < bn->minargs || (argc > bn->maxargs && bn->maxargs != -1)) {
     zwarnnam(name, (argc < bn->minargs)
       ? "not enough arguments" : "too many arguments");
     return 1;
 }


 if (xtr) {

     char **fullargv = argarr;
     printprompt4();
     fprintf(xtrerr, "%s", name);
     while (*fullargv) {
         fputc(' ', xtrerr);
         quotedzputs(*fullargv++, xtrerr);
     }
     fputc('\n', xtrerr);
     fflush(xtrerr);
 }

 return (*(bn->handlerfunc)) (name, argv, &ops, bn->funcid);
    }
}






int
bin_enable(char *name, char **argv, Options ops, int func)
{
    HashTable ht;
    HashNode hn;
    ScanFunc scanfunc;
    Patprog pprog;
    int flags1 = 0, flags2 = 0;
    int match = 0, returnval = 0;


    if (((ops)->ind['f'] != 0))
 ht = shfunctab;
    else if (((ops)->ind['r'] != 0))
 ht = reswdtab;
    else if (((ops)->ind['s'] != 0))
 ht = sufaliastab;
    else if (((ops)->ind['a'] != 0))
 ht = aliastab;
    else
 ht = builtintab;


    if (func == 25) {
 flags2 = (1<<0);
 scanfunc = ht->enablenode;
    } else {
 flags1 = (1<<0);
 scanfunc = ht->disablenode;
    }





    if (!*argv) {
 (queueing_enabled++);
 scanhashtable(ht, 1, flags1, flags2, ht->printnode, 0);
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return 0;
    }


    if (((ops)->ind['m'] != 0)) {
 for (; *argv; argv++) {

     tokenize(*argv);
     if ((pprog = patcompile(*argv, 0x0040, 0))) {
  (queueing_enabled++);
  match += scanmatchtable(ht, pprog, 0, 0, 0, scanfunc, 0);
  do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     }
     else {
  untokenize(*argv);
  zwarnnam(name, "bad pattern : %s", *argv);
  returnval = 1;
     }
 }

 if (!match)
     returnval = 1;
 return returnval;
    }


    (queueing_enabled++);
    for (; *argv; argv++) {
 if ((hn = ht->getnode2(ht, *argv))) {
     scanfunc(hn, 0);
 } else {
     zwarnnam(name, "no such hash table element: %s", *argv);
     returnval = 1;
 }
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return returnval;
}





int
bin_set(char *nam, char **args, Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    int action, optno, array = 0, hadopt = 0,
 hadplus = 0, hadend = 0, sort = 0;
    char **x, *arrayname = ((void *)0);



    if (!(emulation & ((1<<4))) && *args && **args == '-' && !args[0][1]) {
 dosetopt(VERBOSE, 0, 0);
 dosetopt(XTRACE, 0, 0);
 if (!args[1])
     return 0;
    }


    while (*args && (**args == '-' || **args == '+')) {
 action = (**args == '-');
 hadplus |= !action;
 if(!args[0][1])
     *args = "--";
 while (*++*args) {
     if(**args == ((char) 0x83))
  *++*args ^= 32;
     if(**args != '-' || action)
  hadopt = 1;

     if (**args == '-') {
  hadend = 1;
  args++;
  goto doneoptions;
     } else if (**args == 'o') {
  if (!*++*args)
      args++;
  if (!*args) {
      printoptionstates(hadplus);
      inittyptab();
      return 0;
  }
  if(!(optno = optlookup(*args)))
      zerrnam(nam, "no such option: %s", *args);
  else if(dosetopt(optno, action, 0))
      zerrnam(nam, "can't change option: %s", *args);
  break;
     } else if(**args == 'A') {
  if(!*++*args)
      args++;
  array = action ? 1 : -1;
  arrayname = *args;
  if (!arrayname)
      goto doneoptions;
  else if (!(opts[KSHARRAYS]))
  {
      args++;
      goto doneoptions;
  }
  break;
     } else if (**args == 's')
  sort = action ? 1 : -1;
     else {
      if (!(optno = optlookupc(**args)))
      zerrnam(nam, "bad option: -%c", **args);
  else if(dosetopt(optno, action, 0))
      zerrnam(nam, "can't change option: -%c", **args);
     }
 }
 args++;
    }
    if (errflag)
 return 1;
 doneoptions:
    inittyptab();


    (queueing_enabled++);
    if (!arrayname)
    {
 if (!hadopt && !*args)
     scanhashtable(paramtab, 1, 0, 0, paramtab->printnode,
     hadplus ? (1<<0) : 0);

 if (array) {

     scanhashtable(paramtab, 1, (1<<0), 0, paramtab->printnode,
     hadplus ? (1<<0) : 0);
 }
 if (!*args && !hadend) {
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 0;
 }
    }
    if (sort)
 strmetasort(args, sort < 0 ? SORTIT_BACKWARDS : 0, ((void *)0));
    if (array) {

 char **a = ((void *)0), **y;
 int len = arrlen(args);

 if (array < 0 && (a = getaparam(arrayname))) {
     int al = arrlen(a);

     if (al > len)
  len = al;
 }
 for (x = y = zalloc((len + 1) * sizeof(char *)); len--; a++) {
     if (!*args)
  args = a;
     *y++ = ztrdup(*args++);
 }
 *y++ = ((void *)0);
 assignaparam(arrayname,x,0);
    } else {

 freearray(pparams);
 pparams = zarrdup(args);
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return 0;
}




int doprintdir = 0;




int
bin_pwd(char *name __attribute__((__unused__)), char **argv __attribute__((__unused__)), Options ops, int func __attribute__((__unused__)))
{
    if (((ops)->ind['r'] != 0) || ((ops)->ind['P'] != 0) ||
 ((opts[CHASELINKS]) && !((ops)->ind['L'] != 0)))
 printf("%s\n", zgetcwd());
    else {
 zputs(pwd, stdout);
 putchar('\n');
    }
    return 0;
}




 LinkList dirstack;




int
bin_dirs(char *name __attribute__((__unused__)), char **argv, Options ops, int func __attribute__((__unused__)))
{
    LinkList l;

    (queueing_enabled++);

    if (!(*argv || ((ops)->ind['c'] != 0)) || ((ops)->ind['v'] != 0) ||
 ((ops)->ind['p'] != 0)) {
 LinkNode node;
 char *fmt;
 int pos = 1;


 if (((ops)->ind['v'] != 0)) {
     printf("0\t");
     fmt = "\n%d\t";

 } else if (((ops)->ind['p'] != 0))
     fmt = "\n";
 else
     fmt = " ";
 if (((ops)->ind['l'] != 0))
     zputs(pwd, stdout);
 else
     fprintdir(pwd, stdout);
 for (node = ((dirstack)->list.first); node; (node = ((node)->next))) {
     printf(fmt, pos++);
     if (((ops)->ind['l'] != 0))
  fputs(((node)->dat), stdout);
     else
  fprintdir(((node)->dat), stdout);

 }
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 putchar('\n');
 return 0;
    }

    l = znewlinklist();
    while (*argv)
 zinsertlinknode(l,((l)->list.last),ztrdup(*argv++));
    freelinklist(dirstack, freestr);
    dirstack = l;
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return 0;
}




void
set_pwd_env(void)
{
    Param pm;



    pm = (Param) paramtab->getnode(paramtab, "PWD");
    if (pm && (pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) != 0) {
 pm->node.flags &= ~(1<<10);
 unsetparam_pm(pm, 0, 1);
    }

    pm = (Param) paramtab->getnode(paramtab, "OLDPWD");
    if (pm && (pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) != 0) {
 pm->node.flags &= ~(1<<10);
 unsetparam_pm(pm, 0, 1);
    }

    assignsparam("PWD",ztrdup(pwd),0);
    assignsparam("OLDPWD",ztrdup(oldpwd),0);

    pm = (Param) paramtab->getnode(paramtab, "PWD");
    if (!(pm->node.flags & (1<<12)))
 addenv(pm, pwd);
    pm = (Param) paramtab->getnode(paramtab, "OLDPWD");
    if (!(pm->node.flags & (1<<12)))
 addenv(pm, oldpwd);
}


static int chasinglinks;
// # 782 "builtin.c"
int
bin_cd(char *nam, char **argv, Options ops, int func)
{
    LinkNode dir;
    struct stat st1, st2;

    if ((opts[RESTRICTED])) {
 zwarnnam(nam, "restricted");
 return 1;
    }
    doprintdir = (doprintdir == -1);

    chasinglinks = ((ops)->ind['P'] != 0) ||
 ((opts[CHASELINKS]) && !((ops)->ind['L'] != 0));
    (queueing_enabled++);
    zinsertlinknode(dirstack,&(dirstack)->node,ztrdup(pwd));
    if (!(dir = cd_get_dest(nam, argv, ((ops)->ind['s'] != 0), func))) {
 zsfree(getlinknode(dirstack));
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return 1;
    }
    cd_new_pwd(func, dir, ((ops)->ind['q'] != 0));

    if (stat(unmeta(pwd), &st1) < 0) {
 setjobpwd();
 zsfree(pwd);
 pwd = ((void *)0);
 pwd = metafy(zgetcwd(), -1, 3);
    } else if (stat(".", &st2) < 0) {
 if (chdir(unmeta(pwd)) < 0)
     zwarn("unable to chdir(%s): %e", pwd, (*__errno_location ()));
    } else if (st1.st_ino != st2.st_ino || st1.st_dev != st2.st_dev) {
 if (chasinglinks) {
     setjobpwd();
     zsfree(pwd);
     pwd = ((void *)0);
     pwd = metafy(zgetcwd(), -1, 3);
 } else if (chdir(unmeta(pwd)) < 0)
     zwarn("unable to chdir(%s): %e", pwd, (*__errno_location ()));
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return 0;
}




static LinkNode
cd_get_dest(char *nam, char **argv, int hard, int func)
{
    LinkNode dir = ((void *)0);
    LinkNode target;
    char *dest;

    if (!argv[0]) {
 if (func == 11 && !((((dirstack)->list.first))->next)) {
     zwarnnam(nam, "directory stack empty");
     return ((void *)0);
 }
 if (func == 12 && (!opts[PUSHDTOHOME]))
     dir = ((((dirstack)->list.first))->next);
 if (dir)
     zinsertlinknode(dirstack, dir, getlinknode(dirstack));
 else if (func != 11)
     zinsertlinknode(dirstack,&(dirstack)->node,ztrdup(home));
    } else if (!argv[1]) {
 int dd;
 char *end;

 doprintdir++;
 if (argv[0][1] && (argv[0][0] == '+' || argv[0][0] == '-')
     && strspn(argv[0]+1, "0123456789") == strlen(argv[0]+1)) {
     dd = zstrtol(argv[0] + 1, &end, 10);
     if (*end == '\0') {
  if ((argv[0][0] == '+') ^ (opts[PUSHDMINUS]))
      for (dir = ((dirstack)->list.first); dir && dd; dd--, (dir = ((dir)->next)));
  else
      for (dir = ((dirstack)->list.last); dir != (LinkNode) dirstack && dd;
    dd--, dir = ((dir)->prev));
  if (!dir || dir == (LinkNode) dirstack) {
      zwarnnam(nam, "no such entry in dir stack");
      return ((void *)0);
  }
     }
 }
 if (!dir)
     zinsertlinknode(dirstack,&(dirstack)->node,ztrdup(strcmp(argv[0], "-") ? (doprintdir--, argv[0]) : oldpwd));

    } else {
 char *u, *d;
 int len1, len2, len3;

 if (!(u = strstr(pwd, argv[0]))) {
     zwarnnam(nam, "string not in pwd: %s", argv[0]);
     return ((void *)0);
 }
 len1 = strlen(argv[0]);
 len2 = strlen(argv[1]);
 len3 = u - pwd;
 d = (char *)zalloc(len3 + len2 + strlen(u + len1) + 1);
 strncpy(d, pwd, len3);
 strcpy(d + len3, argv[1]);
 strcat(d, u + len1);
 zinsertlinknode(dirstack,&(dirstack)->node,d);
 doprintdir++;
    }

    target = dir;
    if (func == 11) {
 if (!dir) {
     target = dir = ((dirstack)->list.first);
 } else if (dir != ((dirstack)->list.first)) {
     return dir;
 }
 dir = ((dir)->next);
    }
    if (!dir) {
 dir = ((dirstack)->list.first);
    }
    if (!(dest = cd_do_chdir(nam, ((dir)->dat), hard))) {
 if (!target)
     zsfree(getlinknode(dirstack));
 if (func == 11)
     zsfree(remnode(dirstack, dir));
 return ((void *)0);
    }
    if (dest != (char *)((dir)->dat)) {
 zsfree(((dir)->dat));
 ((dir)->dat = (dest));
    }
    return target ? target : dir;
}
// # 922 "builtin.c"
static char *
cd_do_chdir(char *cnam, char *dest, int hard)
{
    char **pp, *ret;
    int hasdot = 0, eno = 2;






    int nocdpath;
// # 947 "builtin.c"
    nocdpath = dest[0] == '.' &&
 (dest[1] == '/' || !dest[1] || (dest[1] == '.' &&
     (dest[2] == '/' || !dest[2])));




    if (*dest == '/') {
 if ((ret = cd_try_chdir(((void *)0), dest, hard)))
     return ret;
 zwarnnam(cnam, "%e: %s", (*__errno_location ()), dest);
 return ((void *)0);
    }






    if (!nocdpath && !(opts[POSIXCD]))
 for (pp = cdpath; *pp; pp++)
     if (!(*pp)[0] || ((*pp)[0] == '.' && (*pp)[1] == '\0'))
  hasdot = 1;







    if (!hasdot && !(opts[POSIXCD])) {
 if ((ret = cd_try_chdir(((void *)0), dest, hard)))
     return ret;
 if ((*__errno_location ()) != 2)
     eno = (*__errno_location ());
    }


    if (!nocdpath)
 for (pp = cdpath; *pp; pp++) {
     if ((ret = cd_try_chdir(*pp, dest, hard))) {
  if ((opts[POSIXCD])) {






      if (**pp)
   doprintdir++;
  } else {
      if (strcmp(*pp, ".")) {
   doprintdir++;
      }
  }
  return ret;
     }
     if ((*__errno_location ()) != 2)
  eno = (*__errno_location ());
 }



    if ((opts[POSIXCD])) {
 if ((ret = cd_try_chdir(((void *)0), dest, hard)))
     return ret;
 if ((*__errno_location ()) != 2)
     eno = (*__errno_location ());
    }


    if ((ret = cd_able_vars(dest))) {
 if ((ret = cd_try_chdir(((void *)0), ret,hard))) {
     doprintdir++;
     return ret;
 }
 if ((*__errno_location ()) != 2)
     eno = (*__errno_location ());
    }




    zwarnnam(cnam, "%e: %s", eno, dest);
    return ((void *)0);
}





char *
cd_able_vars(char *s)
{
    char *rest, save;

    if ((opts[CDABLEVARS])) {
 for (rest = s; *rest && *rest != '/'; rest++);
 save = *rest;
 *rest = 0;
 s = getnameddir(s);
 *rest = save;

 if (s && *rest)
     s = dyncat(s, rest);

 return s;
    }
    return ((void *)0);
}
// # 1066 "builtin.c"
static char *
cd_try_chdir(char *pfix, char *dest, int hard)
{
    char *buf;
    int dlen, dochaselinks = 0;


    if (pfix && *pfix) {
 if (*pfix == '/') {
// # 1084 "builtin.c"
     buf = tricat(pfix, "/", dest);

 } else {
     int pfl = strlen(pfix);
     dlen = strlen(pwd);

     buf = zalloc(dlen + pfl + strlen(dest) + 3);
     strcpy(buf, pwd);
     buf[dlen] = '/';
     strcpy(buf + dlen + 1, pfix);
     buf[dlen + 1 + pfl] = '/';
     strcpy(buf + dlen + pfl + 2, dest);
 }
    } else if (*dest == '/')
 buf = ztrdup(dest);
    else {
 dlen = strlen(pwd);
 if (pwd[dlen-1] == '/')
     --dlen;
 buf = zalloc(dlen + strlen(dest) + 2);
 strcpy(buf, pwd);
 buf[dlen] = '/';
 strcpy(buf + dlen + 1, dest);
    }




    if (!chasinglinks)
 dochaselinks = fixdir(buf);
    else
 unmetafy(buf, &dlen);





    if (lchdir(buf, ((void *)0), hard) && lchdir(dest, ((void *)0), hard)) {
 free(buf);
 return ((void *)0);
    }

    if (dochaselinks)
 chasinglinks = 1;
    return metafy(buf, -1, 5);
}




static void
cd_new_pwd(int func, LinkNode dir, int quiet)
{
    char *new_pwd, *s;
    int dirstacksize;

    if (func == 12)
 rolllist(dirstack, dir);
    new_pwd = remnode(dirstack, dir);

    if (func == 11 && ((dirstack)->list.first)) {
 zsfree(new_pwd);
 new_pwd = getlinknode(dirstack);
    } else if (func == 10 && (!opts[AUTOPUSHD]))
 zsfree(getlinknode(dirstack));

    if (chasinglinks) {
 s = new_pwd;
 new_pwd = findpwd(s);
 zsfree(s);
    }
    if ((opts[PUSHDIGNOREDUPS])) {
 LinkNode n;
 for (n = ((dirstack)->list.first); n; (n = ((n)->next))) {
     if (!strcmp(new_pwd, ((n)->dat))) {
  zsfree(remnode(dirstack, n));
  break;
     }
 }
    }



    zsfree(oldpwd);
    oldpwd = pwd;
    setjobpwd();
    pwd = new_pwd;
    set_pwd_env();

    if ((opts[INTERACTIVE]) || (opts[POSIXCD])) {
 if (func != 10 && (opts[INTERACTIVE])) {
            if ((!opts[PUSHDSILENT]) && !quiet)
         printdirstack();
        } else if (doprintdir) {
     fprintdir(pwd, stdout);
     putchar('\n');
 }
    }


    fflush(stdout);
    fflush(stderr);
    if (!quiet)
 callhookfunc("chpwd", ((void *)0), 1, ((void *)0));

    dirstacksize = getiparam("DIRSTACKSIZE");

    if (dirstacksize > 0) {
 int remove = countlinknodes(dirstack) -
     (dirstacksize < 2 ? 2 : dirstacksize);
 while (remove-- >= 0)
     zsfree(remnode(dirstack, ((dirstack)->list.last)));
    }
}




static void
printdirstack(void)
{
    LinkNode node;

    fprintdir(pwd, stdout);
    for (node = ((dirstack)->list.first); node; (node = ((node)->next))) {
 putchar(' ');
 fprintdir(((node)->dat), stdout);
    }
    putchar('\n');
}
// # 1222 "builtin.c"
int
fixdir(char *src)
{
    char *dest = src, *d0 = dest;



    int ret = 0;
// # 1243 "builtin.c"
    for (;;) {

 if (*src == '/') {





     *dest++ = *src++;
     while (*src == '/')
  src++;
 }


 if (!*src) {
     while (dest > d0 + 1 && dest[-1] == '/')
  dest--;
     *dest = '\0';
     return ret;
 }
 if (src[0] == '.' && src[1] == '.' &&
     (src[2] == '\0' || src[2] == '/')) {
     if ((opts[CHASEDOTS])) {
  ret = 1;

     } else {
  if (dest > d0 + 1) {




      struct stat st;
      *dest = '\0';
      if (stat(d0, &st) < 0 || !((((st.st_mode)) & 0170000) == (0040000))) {
   char *ptrd, *ptrs;
   if (dest == src)
       *dest = '.';
   for (ptrs = src, ptrd = dest; *ptrs; ptrs++, ptrd++)
       *ptrd = (*ptrs == ((char) 0x83)) ? (*++ptrs ^ 32) : *ptrs;
   *ptrd = '\0';
   return 1;
      }
      for (dest--; dest > d0 + 1 && dest[-1] != '/'; dest--);
      if (dest[-1] != '/')
   dest--;
  }
  src++;
  while (*++src == '/');
  continue;
     }
 }
 if (src[0] == '.' && (src[1] == '/' || src[1] == '\0')) {

     while (*++src == '/');
 } else {

     while (*src != '/' && *src != '\0')
  if ((*dest++ = *src++) == ((char) 0x83))
      dest[-1] = *src++ ^ 32;
 }
    }
}


 void
printqt(char *str)
{

    for (; *str; str++)
 if (*str == '\'')
     printf((opts[RCQUOTES]) ? "''" : "'\\''");
 else
     putchar(*str);
}


 void
printif(char *str, int c)
{

    if (str) {
 printf(" -%c ", c);
 quotedzputs(str, stdout);
    }
}






int
bin_fc(char *nam, char **argv, Options ops, int func)
{
    zlong first = -1, last = -1;
    int retval;
    char *s;
    struct asgment *asgf = ((void *)0), *asgl = ((void *)0);
    Patprog pprog = ((void *)0);
// # 1350 "builtin.c"
    if (((ops)->ind['p'] != 0)) {
 char *hf = "";
 zlong hs = 30;
 zlong shs = 0;
 int level = ((ops)->ind['a'] != 0) ? locallevel : -1;
 if (*argv) {
     hf = *argv++;
     if (*argv) {
  hs = zstrtol(*argv++, ((void *)0), 10);
  if (*argv)
      shs = zstrtol(*argv++, ((void *)0), 10);
  else
      shs = hs;
  if (*argv) {
      zwarnnam("fc", "too many arguments");
      return 1;
  }
     } else {
  hs = histsiz;
  shs = savehistsiz;
     }
 }
 if (!pushhiststack(hf, hs, shs, level))
     return 1;
 if (*hf) {
     struct stat st;
     if (stat(hf, &st) >= 0 || (*__errno_location ()) != 2)
  readhistfile(hf, 1, 0x8000);
 }
 return 0;
    }
    if (((ops)->ind['P'] != 0)) {
 if (*argv) {
     zwarnnam("fc", "too many arguments");
     return 1;
 }
 return !saveandpophiststack(-1, 0x8000);
    }


    if (*argv && ((ops)->ind['m'] != 0)) {
 tokenize(*argv);
 if (!(pprog = patcompile(*argv++, 0, ((void *)0)))) {
     zwarnnam(nam, "invalid match pattern");
     return 1;
 }
    }
    (queueing_enabled++);
    if (((ops)->ind['R'] != 0)) {

 readhistfile(*argv, 1, ((ops)->ind['I'] != 0) ? 0x0002 : 0);
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return 0;
    }
    if (((ops)->ind['W'] != 0)) {

 savehistfile(*argv, 1, ((ops)->ind['I'] != 0) ? 0x0002 : 0);
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return 0;
    }
    if (((ops)->ind['A'] != 0)) {

 savehistfile(*argv, 1, 0x0001 |
       (((ops)->ind['I'] != 0) ? 0x0002 : 0));
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return 0;
    }

    while (*argv && equalsplit(*argv, &s)) {
 Asgment a = (Asgment) zhalloc(sizeof *a);

 if (!**argv) {
     zwarnnam(nam, "invalid replacement pattern: =%s", s);
     return 1;
 }
 if (!asgf)
     asgf = asgl = a;
 else {
     asgl->next = a;
     asgl = a;
 }
 a->name = *argv;
 a->value = s;
 a->next = ((void *)0);
 argv++;
    }

    if (*argv) {
 first = fcgetcomm(*argv);
 if (first == -1) {
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 1;
 }
 argv++;
    }

    if (*argv) {
 last = fcgetcomm(*argv);
 if (last == -1) {
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 1;
 }
 argv++;
    }


    if (*argv) {
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 zwarnnam("fc", "too many arguments");
 return 1;
    }

    if (last == -1) {
 if (((ops)->ind['l'] != 0) && first < curhist) {
// # 1475 "builtin.c"
     last = (curline.histnum == curhist) ? addhistnum(curhist,-1,0)
  : curhist;
     if (last < (hist_ring? hist_ring->down->histnum : curhist))
  last = (hist_ring? hist_ring->down->histnum : curhist);
 }
 else
     last = first;
    }
    if (first == -1) {
// # 1492 "builtin.c"
 first = ((ops)->ind['l'] != 0)? addhistnum(curhist,-16,0)
   : addhistnum(curline.histnum,-1,0);
 if (first < 1)
     first = 1;
 if (last < first)
     last = first;
    }
    if (((ops)->ind['l'] != 0)) {

 retval = fclist(stdout, ops, first, last, asgf, pprog, 0);
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    }
    else {

 int tempfd;
 FILE *out;
 char *fil;

 retval = 1;
 if ((tempfd = gettempfile(((void *)0), 1, &fil)) < 0
  || ((out = fdopen(tempfd, "w")) == ((void *)0))) {
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     zwarnnam("fc", "can't open temp file: %e", (*__errno_location ()));
 } else {





     if (last >= curhist) {
  last = curhist - 1;
  if (first > last) {
      do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
      zwarnnam("fc",
        "current history line would recurse endlessly, aborted");
      fclose(out);
      unlink(fil);
      return 1;
  }
     }
     ops->ind['n'] = 1;
     if (!fclist(out, ops, first, last, asgf, pprog, 1)) {
  char *editor;

  if (func == 17)
      editor = "-";
  else if (((ops)->ind['e'] > 3))
      editor = ((ops)->args[((ops)->ind['e'] >> 2) - 1]);
  else
      editor = getsparam("FCEDIT");
  if (!editor)
      editor = getsparam("EDITOR");
  if (!editor)
      editor = "vi";

  do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
  if (fcedit(editor, fil)) {
      if (stuff(fil))
   zwarnnam("fc", "%e: %s", (*__errno_location ()), s);
      else {
   loop(0,1);
   retval = lastval;
      }
  }
     } else
  do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 }
 unlink(fil);
    }
    return retval;
}
// # 1573 "builtin.c"
static zlong
fcgetcomm(char *s)
{
    zlong cmd;



    if ((cmd = atoi(s)) != 0 || *s == '0') {
 if (cmd < 0)
     cmd = addhistnum(curline.histnum,cmd,0x00000010);
 if (cmd < 0)
     cmd = 0;
 return cmd;
    }

    cmd = hcomsearch(s);
    if (cmd == -1)
 zwarnnam("fc", "event not found: %s", s);
    return cmd;
}





static int
fcsubs(char **sp, struct asgment *sub)
{
    char *oldstr, *newstr, *oldpos, *newpos, *newmem, *s = *sp;
    int subbed = 0;


    while (sub) {
 oldstr = sub->name;
 newstr = sub->value;
 sub = sub->next;
 oldpos = s;

 while ((newpos = (char *)strstr(oldpos, oldstr))) {
     newmem = (char *) zhalloc(1 + (newpos - s)
          + strlen(newstr) + strlen(newpos + strlen(oldstr)));
     ztrncpy(newmem, s, newpos - s);
     strcat(newmem, newstr);
     oldpos = newmem + strlen(newmem);
     strcat(newmem, newpos + strlen(oldstr));
     s = newmem;
     subbed = 1;
 }
    }
    *sp = s;
    return subbed;
}
// # 1640 "builtin.c"
static int
fclist(FILE *f, Options ops, zlong first, zlong last,
       struct asgment *subs, Patprog pprog, int is_command)
{
    int fclistdone = 0;
    zlong tmp;
    char *s, *tdfmt, *timebuf;
    Histent ent;


    if (((ops)->ind['r'] != 0)) {
 tmp = last;
 last = first;
 first = tmp;
    }
    if (is_command && first > last) {
 zwarnnam("fc", "history events can't be executed backwards, aborted");
 if (f != stdout)
     fclose(f);
 return 1;
    }

    if (!subs)
 fclistdone = 1;

    ent = gethistent(first, first < last? 1 : (-1));
    if (!ent || (first < last? ent->histnum > last : ent->histnum < last)) {
 if (first == last) {
     char buf[((int)(((sizeof(zlong) * 8) - 1) * 30103/100000) + 3)];
     convbase(buf, first, 10);
     zwarnnam("fc", "no such event: %s", buf);
 } else
     zwarnnam("fc", "no events in that range");
 if (f != stdout)
     fclose(f);
 return 1;
    }

    if (((ops)->ind['d'] != 0) || ((ops)->ind['f'] != 0) ||
 ((ops)->ind['E'] != 0) || ((ops)->ind['i'] != 0) ||
 ((ops)->ind['t'] != 0)) {
 if (((ops)->ind['t'] != 0)) {
     tdfmt = ((ops)->args[((ops)->ind['t'] >> 2) - 1]);
 } else if (((ops)->ind['i'] != 0)) {
     tdfmt = "%Y-%m-%d %H:%M";
 } else if (((ops)->ind['E'] != 0)) {
     tdfmt = "%f.%-m.%Y %H:%M";
 } else if (((ops)->ind['f'] != 0)) {
     tdfmt = "%-m/%f/%Y %H:%M";
 } else {
     tdfmt = "%H:%M";
 }
 timebuf = zhalloc(256);
    } else {
 tdfmt = timebuf = ((void *)0);
    }

    for (;;) {
 s = dupstring(ent->node.nam);

 if (!pprog || pattry(pprog, s)) {

     fclistdone |= fcsubs(&s, subs);


     if (!((ops)->ind['n'] != 0)) {
  char buf[((int)(((sizeof(zlong) * 8) - 1) * 30103/100000) + 3)];
  convbase(buf, ent->histnum, 10);
  fprintf(f, "%5s%c ", buf,
   ent->node.flags & 0x00000010 ? '*' : ' ');
     }


     if (tdfmt != ((void *)0)) {
  struct tm *ltm;
  ltm = localtime(&ent->stim);
  if (ztrftime(timebuf, 256, tdfmt, ltm))
      fprintf(f, "%s  ", timebuf);
     }

     if (((ops)->ind['D'] != 0)) {
  long diff;
  diff = (ent->ftim) ? ent->ftim - ent->stim : 0;
  fprintf(f, "%ld:%02ld  ", diff / 60, diff % 60);
     }


     if (f == stdout) {
  (void)mb_niceformat((s), (f), ((void *)0), 0);
  _IO_putc ('\n', f);
     } else
  fprintf(f, "%s\n", s);
 }

 if (first < last) {
     if (!(ent = down_histent(ent)) || ent->histnum > last)
  break;
 }
 else {
     if (!(ent = up_histent(ent)) || ent->histnum < last)
  break;
 }
    }


    if (f != stdout)
 fclose(f);
    if (!fclistdone) {
 zwarnnam("fc", "no substitutions performed");
 return 1;
    }
    return 0;
}




static int
fcedit(char *ename, char *fn)
{
    char *s;

    if (!strcmp(ename, "-"))
 return 1;

    s = tricat(ename, " ", fn);
    execstring(s, 1, 0, "fc");
    zsfree(s);

    return !lastval;
}
// # 1780 "builtin.c"
static Asgment
getasg(char *s)
{
    static struct asgment asg;


    if (!s)
 return ((void *)0);


    if (*s == '=') {
 zerr("bad assignment");
 return ((void *)0);
    }
    asg.name = s;


    for (; *s && *s != '='; s++);


    if (*s) {
 *s = '\0';
 asg.value = s + 1;
    } else {

 asg.value = ((void *)0);
    }
    return &asg;
}


enum {
    NS_NONE,
    NS_NORMAL,
    NS_SECONDS
};

static const struct gsu_scalar tiedarr_gsu =
{ tiedarrgetfn, tiedarrsetfn, tiedarrunsetfn };



static int
typeset_setbase(const char *name, Param pm, Options ops, int on, int always)
{
    char *arg = ((void *)0);

    if ((on & (1<<1)) && ((ops)->ind['i'] > 3))
 arg = ((ops)->args[((ops)->ind['i'] >> 2) - 1]);
    else if ((on & (1<<2)) && ((ops)->ind['E'] > 3))
 arg = ((ops)->args[((ops)->ind['E'] >> 2) - 1]);
    else if ((on & (1<<3)) && ((ops)->ind['F'] > 3))
 arg = ((ops)->args[((ops)->ind['F'] >> 2) - 1]);

    if (arg) {
 char *eptr;
 pm->base = (int)zstrtol(arg, &eptr, 10);
 if (*eptr) {
     if (on & (1<<1))
  zwarnnam(name, "bad base value: %s", arg);
     else
  zwarnnam(name, "bad precision value: %s", arg);
     return 1;
 }
 if (pm->base < 2 || pm->base > 36) {
     zwarnnam(name, "invalid base (must be 2 to 36 inclusive): %d",
       pm->base);
     return 1;
 }
    } else if (always)
 pm->base = 0;

    return 0;
}



static int
typeset_setwidth(const char * name, Param pm, Options ops, int on, int always)
{
    char *arg = ((void *)0);

    if ((on & (1<<5)) && ((ops)->ind['L'] > 3))
 arg = ((ops)->args[((ops)->ind['L'] >> 2) - 1]);
    else if ((on & (1<<6)) && ((ops)->ind['R'] > 3))
 arg = ((ops)->args[((ops)->ind['R'] >> 2) - 1]);
    else if ((on & (1<<7)) && ((ops)->ind['Z'] > 3))
 arg = ((ops)->args[((ops)->ind['Z'] >> 2) - 1]);

    if (arg) {
 char *eptr;
 pm->width = (int)zstrtol(arg, &eptr, 10);
 if (*eptr) {
     zwarnnam(name, "bad width value: %s", arg);
     return 1;
 }
    } else if (always)
 pm->width = 0;

    return 0;
}




static Param
typeset_single(char *cname, char *pname, Param pm, int func __attribute__((__unused__)),
        int on, int off, int roff, char *value, Param altpm,
        Options ops, int joinchar)
{
    int usepm, tc, keeplocal = 0, newspecial = NS_NONE, readonly;
    char *subscript;
// # 1900 "builtin.c"
    usepm = pm && !(pm->node.flags & (1<<25));





    if (pm && (pm->node.flags & (1<<22)))
 usepm = 1;






    if (usepm && locallevel != pm->level && (on & (1<<21))) {
// # 1923 "builtin.c"
 if ((pm->node.flags & (1<<22))
     && !(on & (1<<14)) && !(pm->node.flags & (1<<14) & ~off))
     newspecial = NS_NORMAL;
 usepm = 0;
    }


    tc = 0;
    if (usepm || newspecial != NS_NONE) {
 int chflags = ((off & pm->node.flags) | (on & ~pm->node.flags)) &
     ((1<<1)|(1<<2)|(1<<3)|(1<<4)|
      (1<<0)|(1<<16)|(1<<27));

 if ((tc = chflags && chflags != ((1<<2)|(1<<3))))
     usepm = 0;
    }







    if ((readonly =
  ((usepm || newspecial != NS_NONE) &&
   (off & pm->node.flags & (1<<10)))) ||
 tc) {
 if (pm->node.flags & (1<<22)) {
     int err = 1;
     if (!readonly && !strcmp(pname, "SECONDS"))
     {
// # 1964 "builtin.c"
  if (newspecial != NS_NONE)
  {





      if ((on & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == 0 || (on & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == (1<<1) ||
   (on & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == (1<<3) || (on & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == (1<<2))
      {
   newspecial = NS_SECONDS;
   err = 0;
   tc = 0;
      }
  } else if (!setsecondstype(pm, on, off)) {
      if (value && !(pm = assignsparam(pname,ztrdup(value),0)))
   return ((void *)0);
      usepm = 1;
      err = 0;
  }
     }
     if (err)
     {
  zerrnam(cname, "%s: can't change type of a special parameter",
   pname);
  return ((void *)0);
     }
 } else if (pm->node.flags & (1<<27)) {
     zerrnam(cname, "%s: can't change type of autoloaded parameter",
      pname);
     return ((void *)0);
 }
    }
    else if (newspecial != NS_NONE && strcmp(pname, "SECONDS") == 0)
 newspecial = NS_SECONDS;
// # 2009 "builtin.c"
    if (usepm) {
 on &= ~(1<<21);
 if (!on && !roff && !value) {
     if (((ops)->ind['p'] != 0))
  paramtab->printnode(&pm->node, (1<<5));
     else if (!((ops)->ind['g'] != 0) &&
       ((!opts[TYPESETSILENT]) || ((ops)->ind['m'] != 0)))
  paramtab->printnode(&pm->node, (1<<4));
     return pm;
 }
 if ((pm->node.flags & (1<<24)) && (opts[RESTRICTED])) {
     zerrnam(cname, "%s: restricted", pname);
     return pm;
 }
 if ((on & (1<<13)) && !(pm->node.flags & (1<<10) & ~off)) {
     Param apm;
     char **x;
     if ((pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == (1<<0)) {
  x = (*pm->gsu.a->getfn)(pm);
  uniqarray(x);
  if (pm->node.flags & (1<<22)) {
      if (zheapptr(x))
   x = zarrdup(x);
      (*pm->gsu.a->setfn)(pm, x);
  } else if (pm->ename && x)
      arrfixenv(pm->ename, x);
     } else if ((pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == 0 && pm->ename &&
         (apm =
   (Param) paramtab->getnode(paramtab, pm->ename))) {
  x = (*apm->gsu.a->getfn)(apm);
  uniqarray(x);
  if (x)
      arrfixenv(pm->node.nam, x);
     }
 }
 pm->node.flags = (pm->node.flags | (on & ~(1<<10))) & ~(off | (1<<25));
 if (on & ((1<<5) | (1<<6) | (1<<7))) {
     if (typeset_setwidth(cname, pm, ops, on, 0))
  return ((void *)0);
 }
 if (on & ((1<<1) | (1<<2) | (1<<3))) {
     if (typeset_setbase(cname, pm, ops, on, 0))
  return ((void *)0);
 }
 if (!(pm->node.flags & ((1<<0)|(1<<4)))) {
     if (pm->node.flags & (1<<12)) {
  if (!(pm->node.flags & (1<<25)) && !pm->env && !value)
      addenv(pm, getsparam(pname));
     } else if (pm->env && !(pm->node.flags & (1<<29)))
  delenv(pm);
     if (value && !(pm = assignsparam(pname,ztrdup(value),0)))
  return ((void *)0);
 } else if (value) {
     zwarnnam(cname, "can't assign new value for array %s", pname);
     return ((void *)0);
 }
 pm->node.flags |= (on & (1<<10));
 if (((ops)->ind['p'] != 0))
     paramtab->printnode(&pm->node, (1<<5));
 return pm;
    }







    if (tc) {

 on |= ~off & ((1<<10)|(1<<12)) & pm->node.flags;

 pm->node.flags &= ~(1<<10);




 keeplocal = pm->level;




 if (!value && !((pm->node.flags|on) & ((1<<0)|(1<<4))))
     value = dupstring(getsparam(pname));

 pname = dupstring(pname);
 unsetparam_pm(pm, 0, 1);
    }

    if (newspecial != NS_NONE) {
 Param tpm, pm2;
 if ((pm->node.flags & (1<<24)) && (opts[RESTRICTED])) {
     zerrnam(cname, "%s: restricted", pname);
     return pm;
 }





 tpm = (Param) zshcalloc(sizeof *tpm);

 tpm->node.nam = pm->node.nam;
 if (pm->ename &&
     (pm2 = (Param) paramtab->getnode(paramtab, pm->ename)) &&
     pm2->level == locallevel) {
// # 2126 "builtin.c"
     tpm->node.flags = pm->node.flags | (1<<28);
 } else {
     copyparam(tpm, pm, 1);
 }
 tpm->old = pm->old;
 tpm->level = pm->level;
 tpm->base = pm->base;
 tpm->width = pm->width;
 if (pm->env)
     delenv(pm);
 tpm->env = ((void *)0);

 pm->old = tpm;




 pm->node.flags = ((pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) | on | (1<<22)) & ~off;



 pm->node.flags |= tpm->node.flags & (1<<10);
 if (newspecial == NS_SECONDS) {

     tpm->u.dval = getrawseconds();
     setsecondstype(pm, on, off);
 }





 if (on & ((1<<5)|(1<<6)|(1<<7))) {
     if (typeset_setwidth(cname, pm, ops, on, 1))
  return ((void *)0);
 }
 if (on & ((1<<1)|(1<<2)|(1<<3))) {
     if (typeset_setbase(cname, pm, ops, on, 1))
  return ((void *)0);
 }
    } else if ((subscript = strchr(pname, '['))) {
 if (on & (1<<10)) {
     zerrnam(cname,
      "%s: can't create readonly array elements", pname);
     return ((void *)0);
 } else if (on & (1<<21)) {
     *subscript = 0;
     pm = (Param) (paramtab == realparamtab ?
     gethashnode2(paramtab, pname) :
     paramtab->getnode(paramtab, pname));
     *subscript = '[';
     if (!pm || pm->level != locallevel) {
  zerrnam(cname,
   "%s: can't create local array elements", pname);
  return ((void *)0);
     }
 }
 if ((on & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == 0) {






     if (!(pm = assignsparam(pname,ztrdup(value ? value : ""),0)))
  return ((void *)0);
     value = ((void *)0);
     keeplocal = 0;
     on = pm->node.flags;
 } else {
     zerrnam(cname,
      "%s: array elements must be scalar", pname);
     return ((void *)0);
 }
    }
// # 2213 "builtin.c"
    else if ((isident(pname) || paramtab->getnode(paramtab, pname))
      && (!(typtab[((unsigned char)(*pname))] & (1 << 0)) || !strcmp(pname, "0"))) {




 pm = createparam(pname, on & ~(1<<10));
 ;
 if (on & ((1<<5) | (1<<6) | (1<<7))) {
     if (typeset_setwidth(cname, pm, ops, on, 0))
  return ((void *)0);
 }
 if (on & ((1<<1) | (1<<2) | (1<<3))) {
     if (typeset_setbase(cname, pm, ops, on, 0))
  return ((void *)0);
 }
    } else {
 if ((typtab[((unsigned char)(*pname))] & (1 << 0)))
     zerrnam(cname, "not an identifier: %s", pname);
 else
     zerrnam(cname, "not valid in this context: %s", pname);
 return ((void *)0);
    }

    if (altpm && (pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == 0) {





 struct tieddata *tdp = (struct tieddata *)
     zalloc(sizeof(struct tieddata));
 if (!tdp)
     return ((void *)0);
 tdp->joinchar = joinchar;
 tdp->arrptr = &altpm->u.arr;

 pm->gsu.s = &tiedarr_gsu;
 pm->u.data = tdp;
    }

    if (keeplocal)
 pm->level = keeplocal;
    else if (on & (1<<21))
 pm->level = locallevel;
    if (value && !(pm->node.flags & ((1<<0)|(1<<4)))) {
 Param ipm = pm;
 if (!(pm = assignsparam(pname,ztrdup(value),0)))
     return ((void *)0);
 if (pm != ipm) {
     ;

     unsetparam_pm(ipm, 0, 1);
 }
    } else if (newspecial != NS_NONE &&
        !(pm->old->node.flags & ((1<<28)|(1<<10)))) {




 switch ((pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4)))) {
 case 0:
     pm->gsu.s->setfn(pm, ztrdup(""));
     break;
 case (1<<1):
     pm->gsu.i->setfn(pm, 0);
     break;
 case (1<<2):
 case (1<<3):
     pm->gsu.f->setfn(pm, 0.0);
     break;
 case (1<<0):
     pm->gsu.a->setfn(pm, mkarray(((void *)0)));
     break;
 case (1<<4):
     pm->gsu.h->setfn(pm, newparamtable(17, pm->node.nam));
     break;
 }
    }
    pm->node.flags |= (on & (1<<10));
    if (value && (pm->node.flags & ((1<<0)|(1<<4)))) {
 zerrnam(cname, "%s: can't assign initial value for array", pname);

 unsetparam_pm(pm, 0, 1);
 return ((void *)0);
    }

    if (((ops)->ind['p'] != 0))
 paramtab->printnode(&pm->node, (1<<5));

    return pm;
}




int
bin_typeset(char *name, char **argv, Options ops, int func)
{
    Param pm;
    Asgment asg;
    Patprog pprog;
    char *optstr = "aiEFALRZlurtxUhHTkz";
    int on = 0, off = 0, roff, bit = (1<<0);
    int i;
    int returnval = 0, printflags = 0;


    if (((ops)->ind['f'] != 0))
 return bin_functions(name, argv, ops, func);




    for (; *optstr; optstr++, bit <<= 1)
    {
 int optval = ((unsigned char)(*optstr));
 if (((ops)->ind[optval] & 1))
     on |= bit;
 else if (((ops)->ind[optval] & 2))
     off |= bit;
    }
    roff = off;


    if (on & (1<<3)) {
 off |= (1<<9) | (1<<0) | (1<<4) | (1<<1) | (1<<2);

 on &= ~(1<<2);
    }
    if (on & (1<<2))
 off |= (1<<9) | (1<<0) | (1<<4) | (1<<1) | (1<<3);
    if (on & (1<<1))
 off |= (1<<9) | (1<<0) | (1<<4) | (1<<2) | (1<<3);




    if (on & ((1<<5)|(1<<7)))
 off |= (1<<6);
    if (on & (1<<6))
 off |= (1<<5) | (1<<7);
    if (on & (1<<9))
 off |= (1<<8);
    if (on & (1<<8))
 off |= (1<<9);
    if (on & (1<<4))
 off |= (1<<0);
    if (on & (1<<16))
 off |= (1<<1) | (1<<2) | (1<<3) | (1<<0) | (1<<4);

    on &= ~off;

    (queueing_enabled++);


    if (((ops)->ind['p'] != 0))
 printflags |= (1<<5);
    if (!*argv) {
 if (!((ops)->ind['p'] != 0)) {
     if (!(on|roff))
  printflags |= (1<<1);
     if (roff || ((ops)->ind['+'] != 0))
  printflags |= (1<<0);
 }
 scanhashtable(paramtab, 1, on|roff, 0, paramtab->printnode, printflags);
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return 0;
    }

    if (!(((ops)->ind['g'] != 0) || ((ops)->ind['x'] != 0) || ((ops)->ind['m'] != 0)) ||
 ((ops)->ind['g'] & 2) || *name == 'l' ||
 (!(opts[GLOBALEXPORT]) && !((ops)->ind['g'] != 0)))
 on |= (1<<21);

    if (on & (1<<16)) {
 Param apm;
 struct asgment asg0;
 char *oldval = ((void *)0);
 int joinchar;

 if (((ops)->ind['m'] != 0)) {
     zwarnnam(name, "incompatible options for -T");
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 1;
 }
 on &= ~off;
 if (!argv[1] || (argv[2] && argv[3])) {
     zwarnnam(name, "-T requires names of scalar and array");
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 1;
 }





 if (!argv[2])
     joinchar = ':';
 else if (!*argv[2])
     joinchar = 0;
 else if (*argv[2] == ((char) 0x83))
     joinchar = argv[2][1] ^ 32;
 else
     joinchar = *argv[2];

 if (!(asg = getasg(argv[0]))) {
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 1;
 }
 asg0 = *asg;
 if (!(asg = getasg(argv[1]))) {
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 1;
 }
 if (!strcmp(asg0.name, asg->name)) {
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     zerrnam(name, "can't tie a variable to itself: %s", asg0.name);
     return 1;
 }
 if (strchr(asg0.name, '[') || strchr(asg->name, '[')) {
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     zerrnam(name, "can't tie array elements: %s", asg0.name);
     return 1;
 }
// # 2447 "builtin.c"
 if ((pm = (Param) paramtab->getnode(paramtab, asg0.name))
     && !(pm->node.flags & (1<<25))
     && (locallevel == pm->level || !(on & (1<<21)))) {
     if (pm->node.flags & (1<<16)) {
  do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
  zerrnam(name, "can't tie already tied scalar: %s", asg0.name);
  return 1;
     }
     if (!asg0.value && !((pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) & ((1<<0)|(1<<4))))
  oldval = ztrdup(getsparam(asg0.name));
     on |= (pm->node.flags & (1<<12));
 }





 if (!(apm=typeset_single(name, asg->name,
     (Param)paramtab->getnode(paramtab,
         asg->name),
     func, (on | (1<<0)) & ~(1<<12),
     off, roff, asg->value, ((void *)0), ops, 0))) {
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 1;
 }




 if (!(pm=typeset_single(name, asg0.name,
    (Param)paramtab->getnode(paramtab,
        asg0.name),
    func, on, off, roff, asg0.value, apm,
    ops, joinchar))) {
     if (oldval)
  zsfree(oldval);
     unsetparam_pm(apm, 1, 1);
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 1;
 }





 if (pm->ename)
     zsfree(pm->ename);
 pm->ename = ztrdup(asg->name);
 if (apm->ename)
     zsfree(apm->ename);
 apm->ename = ztrdup(asg0.name);
 if (oldval)
     assignsparam(asg0.name,oldval,0);
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);

 return 0;
    }
    if (off & (1<<16)) {
 zerrnam(name, "use unset to remove tied variables");
 return 1;
    }


    if (((ops)->ind['m'] != 0)) {
 if (!((ops)->ind['p'] != 0)) {
     if (!(on|roff))
  printflags |= (1<<1);
     if (!on)
  printflags |= (1<<0);
 }

 while ((asg = getasg(*argv++))) {
     LinkList pmlist = newlinklist();
     LinkNode pmnode;

     tokenize(asg->name);
     if (!(pprog = patcompile(asg->name, 0, ((void *)0)))) {
  untokenize(asg->name);
  zwarnnam(name, "bad pattern : %s", argv[-1]);
  returnval = 1;
  continue;
     }
     if (((ops)->ind['m'] & 2) && !asg->value) {
  scanmatchtable(paramtab, pprog, 1, on|roff, 0,
          paramtab->printnode, printflags);
  continue;
     }
// # 2542 "builtin.c"
     for (i = 0; i < paramtab->hsize; i++) {
  for (pm = (Param) paramtab->nodes[i]; pm;
       pm = (Param) pm->node.next) {
      if (((pm->node.flags & (1<<24)) && (opts[RESTRICTED])) ||
   (pm->node.flags & (1<<25)))
   continue;
      if (pattry(pprog, pm->node.nam))
   insertlinknode(pmlist,((pmlist)->list.last),pm);
  }
     }
     for (pmnode = ((pmlist)->list.first); pmnode; (pmnode = ((pmnode)->next))) {
  pm = (Param) ((pmnode)->dat);
  if (!typeset_single(name, pm->node.nam, pm, func, on, off, roff,
        asg->value, ((void *)0), ops, 0))
      returnval = 1;
     }
 }
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return returnval;
    }


    while ((asg = getasg(*argv++))) {
 HashNode hn = (paramtab == realparamtab ?
         gethashnode2(paramtab, asg->name) :
         paramtab->getnode(paramtab, asg->name));
 if (((ops)->ind['p'] != 0)) {
     if (hn)
  printparamnode(hn, printflags);
     else {
  zwarnnam(name, "no such variable: %s", asg->name);
  returnval = 1;
     }
     continue;
 }
 if (!typeset_single(name, asg->name, (Param)hn,
       func, on, off, roff, asg->value, ((void *)0),
       ops, 0))
     returnval = 1;
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return returnval;
}




int
eval_autoload(Shfunc shf, char *name, Options ops, int func)
{
    if (!(shf->node.flags & (1<<9)))
 return 1;

    if (shf->funcdef) {
 freeeprog(shf->funcdef);
 shf->funcdef = &dummy_eprog;
    }
    if (((ops)->ind['X'] & 1)) {
 char *fargv[3];
 fargv[0] = name;
 fargv[1] = "\"$@\"";
 fargv[2] = 0;
 shf->funcdef = mkautofn(shf);
 return bin_eval(name, fargv, ops, func);
    }

    return !loadautofn(shf, (((ops)->ind['k'] != 0) ? 2 :
        (((ops)->ind['z'] != 0) ? 0 : 1)), 1);
}



static void
listusermathfunc(MathFunc p)
{
    int showargs;

    if (p->module)
 showargs = 3;
    else if (p->maxargs != (p->minargs ? p->minargs : -1))
 showargs = 2;
    else if (p->minargs)
 showargs = 1;
    else
 showargs = 0;

    printf("functions -M %s", p->name);
    if (showargs) {
 printf(" %d", p->minargs);
 showargs--;
    }
    if (showargs) {
 printf(" %d", p->maxargs);
 showargs--;
    }
    if (showargs) {



 putchar(' ');
 quotedzputs(p->module, stdout);
 showargs--;
    }
    putchar('\n');
}







int
bin_functions(char *name, char **argv, Options ops, int func)
{
    Patprog pprog;
    Shfunc shf;
    int i, returnval = 0;
    int on = 0, off = 0, pflags = 0;


    if (((ops)->ind['u'] & 2))
 off |= (1<<9);
    else if (((ops)->ind['u'] & 1) || ((ops)->ind['X'] != 0))
 on |= (1<<9);
    if (((ops)->ind['U'] & 1))
 on |= (1<<13)|(1<<9);
    else if (((ops)->ind['U'] & 2))
 off |= (1<<13);
    if (((ops)->ind['t'] & 1))
 on |= (1<<11);
    else if (((ops)->ind['t'] & 2))
 off |= (1<<11);
    if (((ops)->ind['z'] & 1)) {
 on |= (1<<18);
 off |= (1<<17);
    } else if (((ops)->ind['z'] & 2))
 off |= (1<<18);
    if (((ops)->ind['k'] & 1)) {
 on |= (1<<17);
 off |= (1<<18);
    } else if (((ops)->ind['k'] & 2))
 off |= (1<<17);

    if ((off & (1<<9)) || (((ops)->ind['k'] != 0) && ((ops)->ind['z'] != 0)) ||
 (((ops)->ind['X'] & 1) && (((ops)->ind['m'] != 0) || *argv || !scriptname))) {
 zwarnnam(name, "invalid option(s)");
 return 1;
    }

    if (((ops)->ind['f'] & 2) || ((ops)->ind['+'] != 0))
 pflags |= (1<<0);

    if (((ops)->ind['M'] & 1) || ((ops)->ind['M'] & 2)) {
 MathFunc p, q;



 if (on || off || pflags || ((ops)->ind['X'] != 0) || ((ops)->ind['u'] != 0)
     || ((ops)->ind['U'] != 0) || ((ops)->ind['w'] != 0)) {
     zwarnnam(name, "invalid option(s)");
     return 1;
 }
 if (!*argv) {

     (queueing_enabled++);
     for (p = mathfuncs; p; p = p->next)
  if (p->flags & 4)
      listusermathfunc(p);
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 } else if (((ops)->ind['m'] != 0)) {

     for (; *argv; argv++) {
  tokenize(*argv);
  if ((pprog = patcompile(*argv, 0x0040, 0))) {
      (queueing_enabled++);
      for (p = mathfuncs, q = ((void *)0); p; q = p, p = p->next) {
   MathFunc next;
   do {
       next = ((void *)0);
       if ((p->flags & 4) &&
    pattry(pprog, p->name)) {
    if (((ops)->ind['M'] & 2)) {
        next = p->next;
        removemathfunc(q, p);
        p = next;
    } else
        listusermathfunc(p);
       }

   } while (next);
      }
      do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
  } else {
      untokenize(*argv);
      zwarnnam(name, "bad pattern : %s", *argv);
      returnval = 1;
  }
     }
 } else if (((ops)->ind['M'] & 2)) {

     for (; *argv; argv++) {
  (queueing_enabled++);
  for (p = mathfuncs, q = ((void *)0); p; q = p, p = p->next) {
      if (!strcmp(p->name, *argv)) {
   if (!(p->flags & 4)) {
       zwarnnam(name, "+M %s: is a library function",
         *argv);
       returnval = 1;
       break;
   }
   removemathfunc(q, p);
   break;
      }
  }
  do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     }
 } else {

     int minargs = 0, maxargs = -1;
     char *funcname = *argv++;
     char *modname = ((void *)0);
     char *ptr;

     ptr = itype_end(funcname, (1 << 7), 0);
     if ((typtab[((unsigned char)(*funcname))] & (1 << 0)) || funcname == ptr || *ptr) {
  zwarnnam(name, "-M %s: bad math function name", funcname);
  return 1;
     }

     if (*argv) {
  minargs = (int)zstrtol(*argv, &ptr, 0);
  if (minargs < 0 || *ptr) {
      zwarnnam(name, "-M: invalid min number of arguments: %s",
        *argv);
      return 1;
  }
  maxargs = minargs;
  argv++;
     }
     if (*argv) {
  maxargs = (int)zstrtol(*argv, &ptr, 0);
  if (maxargs < -1 ||
      (maxargs != -1 && maxargs < minargs) ||
      *ptr) {
      zwarnnam(name,
        "-M: invalid max number of arguments: %s",
        *argv);
      return 1;
  }
  argv++;
     }
     if (*argv)
  modname = *argv++;
     if (*argv) {
  zwarnnam(name, "-M: too many arguments");
  return 1;
     }

     p = (MathFunc)zshcalloc(sizeof(struct mathfunc));
     p->name = ztrdup(funcname);
     p->flags = 4;
     p->module = modname ? ztrdup(modname) : ((void *)0);
     p->minargs = minargs;
     p->maxargs = maxargs;

     (queueing_enabled++);
     for (q = mathfuncs; q; q = q->next) {
  if (!strcmp(q->name, funcname)) {
      zwarnnam(name, "-M %s: function already exists",
        funcname);
      zsfree(p->name);
      zsfree(p->module);
      zfree(p, sizeof(struct mathfunc));
      return 1;
  }
     }

     p->next = mathfuncs;
     mathfuncs = p;
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 }

 return returnval;
    }




    if (!*argv) {
 int ret = 0;

 (queueing_enabled++);
 if (((ops)->ind['X'] & 1)) {
     if ((shf = (Shfunc) shfunctab->getnode(shfunctab, scriptname))) {
  ;

     } else {
  shf = (Shfunc) zshcalloc(sizeof *shf);
  shfunctab->addnode(shfunctab, ztrdup(scriptname), shf);
     }
     shf->node.flags = on;
     ret = eval_autoload(shf, scriptname, ops, func);
 } else {
     if (((ops)->ind['U'] != 0) && !((ops)->ind['u'] != 0))
  on &= ~(1<<9);
     scanhashtable(shfunctab, 1, on|off, (1<<0), shfunctab->printnode,
     pflags);
 }
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return ret;
    }


    if (((ops)->ind['m'] != 0)) {
 on &= ~(1<<9);
 for (; *argv; argv++) {

     tokenize(*argv);
     if ((pprog = patcompile(*argv, 0x0040, 0))) {

  (queueing_enabled++);
  if (!(on|off)) {
      scanmatchtable(shfunctab, pprog, 1, 0, (1<<0),
       shfunctab->printnode, pflags);
  } else {

      for (i = 0; i < shfunctab->hsize; i++) {
   for (shf = (Shfunc) shfunctab->nodes[i]; shf;
        shf = (Shfunc) shf->node.next)
       if (pattry(pprog, shf->node.nam) &&
    !(shf->node.flags & (1<<0))) {
    shf->node.flags = (shf->node.flags |
           (on & ~(1<<9))) & ~off;
    if (((ops)->ind['X'] != 0) &&
        eval_autoload(shf, shf->node.nam, ops, func)) {
        returnval = 1;
    }
       }
      }
  }
  do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     } else {
  untokenize(*argv);
  zwarnnam(name, "bad pattern : %s", *argv);
  returnval = 1;
     }
 }
 return returnval;
    }


    (queueing_enabled++);
    for (; *argv; argv++) {
 if (((ops)->ind['w'] != 0))
     returnval = dump_autoload(name, *argv, on, ops, func);
 else if ((shf = (Shfunc) shfunctab->getnode(shfunctab, *argv))) {

     if (on|off) {

  shf->node.flags = (shf->node.flags | (on & ~(1<<9))) & ~off;
  if (((ops)->ind['X'] != 0) &&
      eval_autoload(shf, shf->node.nam, ops, func))
      returnval = 1;
     } else

  shfunctab->printnode(&shf->node, pflags);
 } else if (on & (1<<9)) {
     int signum = -1, ok = 1;

     if (!strncmp(*argv, "TRAP", 4) &&
  (signum = getsignum(*argv + 4)) != -1) {




  removetrapnode(signum);
     }



     shf = (Shfunc) zshcalloc(sizeof *shf);
     shf->node.flags = on;
     shf->funcdef = mkautofn(shf);

     shf->emulation = 0;
     shfunctab->addnode(shfunctab, ztrdup(*argv), shf);

     if (signum != -1) {
  if (settrap(signum, ((void *)0), (1<<2))) {
      shfunctab->removenode(shfunctab, *argv);
      shfunctab->freenode(&shf->node);
      returnval = 1;
      ok = 0;
  }
     }

     if (ok && ((ops)->ind['X'] != 0) &&
  eval_autoload(shf, shf->node.nam, ops, func))
  returnval = 1;
 } else
     returnval = 1;
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return returnval;
}


Eprog
mkautofn(Shfunc shf)
{
    Eprog p;

    p = (Eprog) zalloc(sizeof(*p));
    p->len = 5 * sizeof(wordcode);
    p->prog = (Wordcode) zalloc(p->len);
    p->strs = ((void *)0);
    p->shf = shf;
    p->npats = 0;
    p->nref = 1;
    p->pats = (Patprog *) p->prog;
    p->flags = 1;
    p->dump = ((void *)0);

    p->prog[0] = (((wordcode) (1)) | (((wordcode) (((((1<<1) | (1<<4))) | ((0) << (6))))) << 5));
    p->prog[1] = (((wordcode) (2)) | (((wordcode) (((0) | (0) | ((3) << (5))))) << 5));
    p->prog[2] = (((wordcode) (3)) | (((wordcode) (((0) | ((0) << 1)))) << 5));
    p->prog[3] = (((wordcode) (19)) | (((wordcode) (0)) << 5));
    p->prog[4] = (((wordcode) (0)) | (((wordcode) (0)) << 5));

    return p;
}




int
bin_unset(char *name, char **argv, Options ops, int func)
{
    Param pm, next;
    Patprog pprog;
    char *s;
    int match = 0, returnval = 0;
    int i;


    if (((ops)->ind['f'] != 0))
 return bin_unhash(name, argv, ops, func);


    if (((ops)->ind['m'] != 0)) {
 while ((s = *argv++)) {

     tokenize(s);
     if ((pprog = patcompile(s, 0x0040, ((void *)0)))) {

  (queueing_enabled++);
  for (i = 0; i < paramtab->hsize; i++) {
      for (pm = (Param) paramtab->nodes[i]; pm; pm = next) {

   next = (Param) pm->node.next;
   if ((!(pm->node.flags & (1<<24)) ||
        (!opts[RESTRICTED])) &&
       pattry(pprog, pm->node.nam)) {
       unsetparam_pm(pm, 0, 1);
       match++;
   }
      }
  }
  do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     } else {
  untokenize(s);
  zwarnnam(name, "bad pattern : %s", s);
  returnval = 1;
     }
 }

 if (!match)
     returnval = 1;
 return returnval;
    }


    (queueing_enabled++);
    while ((s = *argv++)) {
 char *ss = strchr(s, '[');
 char *sse = ss;
 if (ss) {
     if (skipparens('[', ']', &sse) || *sse) {
  zerrnam(name, "%s: invalid parameter name", s);
  returnval = 1;
  continue;
     }
     *ss = 0;
 }
 pm = (Param) (paramtab == realparamtab ?
        gethashnode2(paramtab, s) :
        paramtab->getnode(paramtab, s));




 if (!pm)
     continue;
 else if ((pm->node.flags & (1<<24)) && (opts[RESTRICTED])) {
     zerrnam(name, "%s: restricted", pm->node.nam);
     returnval = 1;
 } else if (ss) {
     if ((pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == (1<<4)) {
  HashTable tht = paramtab;
  if ((paramtab = pm->gsu.h->getfn(pm))) {
      *--sse = 0;
      unsetparam(ss+1);
      *sse = ']';
  }
  paramtab = tht;
     } else if ((pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == 0 ||
         (pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == (1<<0)) {
  struct value vbuf;
  vbuf.isarr = ((pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == (1<<0) ?
         (1<<9) : 0);
  vbuf.pm = pm;
  vbuf.flags = 0;
  vbuf.start = 0;
  vbuf.end = -1;
  vbuf.arr = 0;
  *ss = '[';
  if (getindex(&ss, &vbuf, (1<<6)) == 0 &&
      vbuf.pm && !(vbuf.pm->node.flags & (1<<25))) {
      if ((pm->node.flags & (0|(1<<1)|(1<<2)|(1<<3)|(1<<0)|(1<<4))) == 0) {
   setstrvalue(&vbuf, ztrdup(""));
      } else {

   int start = vbuf.start - !!(vbuf.flags & VALFLAG_INV);
   if (start < arrlen(vbuf.pm->u.arr)) {
       char *arr[2];
       arr[0] = "";
       arr[1] = 0;
       setarrvalue(&vbuf, zarrdup(arr));
   }
      }
  }
  returnval = errflag;
  errflag = 0;
     } else {
  zerrnam(name, "%s: invalid element for unset", s);
  returnval = 1;
     }
 } else {
     if (unsetparam_pm(pm, 0, 1))
  returnval = 1;
 }
 if (ss)
     *ss = '[';
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return returnval;
}




int
bin_whence(char *nam, char **argv, Options ops, int func)
{
    HashNode hn;
    Patprog pprog;
    int returnval = 0;
    int printflags = 0;
    int aliasflags;
    int csh, all, v, wd;
    int informed;
    char *cnam;


    csh = ((ops)->ind['c'] != 0);
    v = ((ops)->ind['v'] != 0);
    all = ((ops)->ind['a'] != 0);
    wd = ((ops)->ind['w'] != 0);

    if (((ops)->ind['w'] != 0))
 printflags |= (1<<10);
    else if (((ops)->ind['c'] != 0))
 printflags |= (1<<5);
    else if (((ops)->ind['v'] != 0))
 printflags |= (1<<6);
    else
 printflags |= (1<<7);
    if (((ops)->ind['f'] != 0))
 printflags |= (1<<9);

    if (func == 27)
 if (((ops)->ind['V'] != 0)) {
     printflags = aliasflags = (1<<6);
     v = 1;
 } else {
     aliasflags = (1<<2);
     printflags = (1<<7);
     v = 0;
 }
    else
 aliasflags = printflags;


    if (((ops)->ind['m'] != 0)) {
 for (; *argv; argv++) {

     tokenize(*argv);
     if (!(pprog = patcompile(*argv, 0x0040, ((void *)0)))) {
  untokenize(*argv);
  zwarnnam(nam, "bad pattern : %s", *argv);
  returnval = 1;
  continue;
     }
     (queueing_enabled++);
     if (!((ops)->ind['p'] != 0)) {




  scanmatchtable(aliastab, pprog, 1, 0, (1<<0),
          aliastab->printnode, printflags);


  scanmatchtable(reswdtab, pprog, 1, 0, (1<<0),
          reswdtab->printnode, printflags);


  scanmatchtable(shfunctab, pprog, 1, 0, (1<<0),
          shfunctab->printnode, printflags);


  scanmatchtable(builtintab, pprog, 1, 0, (1<<0),
          builtintab->printnode, printflags);
     }


     cmdnamtab->filltable(cmdnamtab);
     scanmatchtable(cmdnamtab, pprog, 1, 0, 0,
      cmdnamtab->printnode, printflags);

     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 }
 return returnval;
    }


    (queueing_enabled++);
    for (; *argv; argv++) {
 informed = 0;

 if (!((ops)->ind['p'] != 0)) {
     char *suf;


     if ((hn = aliastab->getnode(aliastab, *argv))) {
  aliastab->printnode(hn, aliasflags);
  if (!all)
      continue;
  informed = 1;
     }

     if ((suf = strrchr(*argv, '.')) && suf[1] &&
  suf > *argv && suf[-1] != ((char) 0x83) &&
  (hn = sufaliastab->getnode(sufaliastab, suf+1))) {
  sufaliastab->printnode(hn, printflags);
  if (!all)
      continue;
  informed = 1;
     }

     if ((hn = reswdtab->getnode(reswdtab, *argv))) {
  reswdtab->printnode(hn, printflags);
  if (!all)
      continue;
  informed = 1;
     }

     if ((hn = shfunctab->getnode(shfunctab, *argv))) {
  shfunctab->printnode(hn, printflags);
  if (!all)
      continue;
  informed = 1;
     }

     if ((hn = builtintab->getnode(builtintab, *argv))) {
  builtintab->printnode(hn, printflags);
  if (!all)
      continue;
  informed = 1;
     }


     if ((hn = cmdnamtab->getnode(cmdnamtab, *argv)) && (hn->flags & (1<<1))) {
  cmdnamtab->printnode(hn, printflags);
  if (!all)
      continue;
  informed = 1;
     }
 }



 if (all) {
     char **pp, *buf;

     pushheap();
     for (pp = path; *pp; pp++) {
  if (**pp) {
      buf = zhtricat(*pp, "/", *argv);
  } else buf = ztrdup(*argv);

  if (iscom(buf)) {
      if (wd) {
   printf("%s: command\n", *argv);
      } else {
   if (v && !csh)
       zputs(*argv, stdout), fputs(" is ", stdout);
   zputs(buf, stdout);
   if (((ops)->ind['s'] != 0))
       print_if_link(buf);
   fputc('\n', stdout);
      }
      informed = 1;
  }
     }
     if (!informed && (wd || v || csh)) {
  zputs(*argv, stdout);
  puts(wd ? ": none" : " not found");
  returnval = 1;
     }
     popheap();
 } else if ((cnam = findcmd(*argv, 1))) {

     if (wd) {
  printf("%s: command\n", *argv);
     } else {
  if (v && !csh)
      zputs(*argv, stdout), fputs(" is ", stdout);
  zputs(cnam, stdout);
  if (((ops)->ind['s'] != 0))
      print_if_link(cnam);
  fputc('\n', stdout);
     }
 } else {

     if (v || csh || wd)
  zputs(*argv, stdout), puts(wd ? ": none" : " not found");
     returnval = 1;
 }
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return returnval;
}
// # 3318 "builtin.c"
int
bin_hash(char *name, char **argv, Options ops, int func __attribute__((__unused__)))
{
    HashTable ht;
    Patprog pprog;
    Asgment asg;
    int returnval = 0;
    int printflags = 0;

    if (((ops)->ind['d'] != 0))
 ht = nameddirtab;
    else
 ht = cmdnamtab;

    if (((ops)->ind['r'] != 0) || ((ops)->ind['f'] != 0)) {

 if (*argv) {
     zwarnnam("hash", "too many arguments");
     return 1;
 }


 if (((ops)->ind['r'] != 0))
     ht->emptytable(ht);


 if (((ops)->ind['f'] != 0))
     ht->filltable(ht);

 return 0;
    }

    if (((ops)->ind['L'] != 0)) printflags |= (1<<2);


    if (!*argv) {
 (queueing_enabled++);
 scanhashtable(ht, 1, 0, 0, ht->printnode, printflags);
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return 0;
    }

    (queueing_enabled++);
    for (;*argv;++argv) {
 void *hn;
 if (((ops)->ind['m'] != 0)) {

     tokenize(*argv);
     if ((pprog = patcompile(*argv, 0x0040, ((void *)0)))) {

  scanmatchtable(ht, pprog, 1, 0, 0, ht->printnode, printflags);
     } else {
  untokenize(*argv);
  zwarnnam(name, "bad pattern : %s", *argv);
  returnval = 1;
     }
            continue;
 }
        if (!(asg = getasg(*argv))) {
     zwarnnam(name, "bad assignment");
     returnval = 1;
        } else if (asg->value) {
     if((opts[RESTRICTED])) {
  zwarnnam(name, "restricted: %s", asg->value);
  returnval = 1;
     } else {


  if(((ops)->ind['d'] != 0)) {

      if (*itype_end(asg->name, (1 << 8), 0)) {
   zwarnnam(name,
     "invalid character in directory name: %s",
     asg->name);
   returnval = 1;
   continue;
      } else {
   Nameddir nd = hn = zshcalloc(sizeof *nd);
   nd->node.flags = 0;
   nd->dir = ztrdup(asg->value);
      }
  } else {
      Cmdnam cn = hn = zshcalloc(sizeof *cn);
      cn->node.flags = (1<<1);
      cn->u.cmd = ztrdup(asg->value);
  }
  ht->addnode(ht, ztrdup(asg->name), hn);
  if(((ops)->ind['v'] != 0))
      ht->printnode(hn, 0);
     }
 } else if (!(hn = ht->getnode2(ht, asg->name))) {


     if(((ops)->ind['d'] != 0)) {
  if(!getnameddir(asg->name)) {
      zwarnnam(name, "no such directory name: %s", asg->name);
      returnval = 1;
  }
     } else {
  if (!hashcmd(asg->name, path)) {
      zwarnnam(name, "no such command: %s", asg->name);
      returnval = 1;
  }
     }
     if(((ops)->ind['v'] != 0) && (hn = ht->getnode2(ht, asg->name)))
  ht->printnode(hn, 0);
 } else if(((ops)->ind['v'] != 0))
     ht->printnode(hn, 0);
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return returnval;
}




int
bin_unhash(char *name, char **argv, Options ops, int func __attribute__((__unused__)))
{
    HashTable ht;
    HashNode hn, nhn;
    Patprog pprog;
    int match = 0, returnval = 0;
    int i;


    if (((ops)->ind['d'] != 0))
 ht = nameddirtab;
    else if (((ops)->ind['f'] != 0))
 ht = shfunctab;
    else if (((ops)->ind['s'] != 0))
 ht = sufaliastab;
    else if (((ops)->ind['a'] != 0))
 ht = aliastab;
    else
 ht = cmdnamtab;



    if (((ops)->ind['m'] != 0)) {
 for (; *argv; argv++) {

     tokenize(*argv);
     if ((pprog = patcompile(*argv, 0x0040, ((void *)0)))) {

  (queueing_enabled++);
  for (i = 0; i < ht->hsize; i++) {
      for (hn = ht->nodes[i]; hn; hn = nhn) {

   nhn = hn->next;
   if (pattry(pprog, hn->nam)) {
       ht->freenode(ht->removenode(ht, hn->nam));
       match++;
   }
      }
  }
  do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     } else {
  untokenize(*argv);
  zwarnnam(name, "bad pattern : %s", *argv);
  returnval = 1;
     }
 }

 if (!match)
     returnval = 1;
 return returnval;
    }


    (queueing_enabled++);
    for (; *argv; argv++) {
 if ((hn = ht->removenode(ht, *argv))) {
     ht->freenode(hn);
 } else {
     zwarnnam(name, "no such hash table element: %s", *argv);
     returnval = 1;
 }
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return returnval;
}






int
bin_alias(char *name, char **argv, Options ops, int func __attribute__((__unused__)))
{
    Alias a;
    Patprog pprog;
    Asgment asg;
    int returnval = 0;
    int flags1 = 0, flags2 = (1<<0);
    int printflags = 0;
    int type_opts;
    HashTable ht = aliastab;


    type_opts = ((ops)->ind['r'] != 0) + ((ops)->ind['g'] != 0) +
 ((ops)->ind['s'] != 0);
    if (type_opts) {
 if (type_opts > 1) {
     zwarnnam(name, "illegal combination of options");
     return 1;
 }
 if (((ops)->ind['g'] != 0))
     flags1 |= (1<<1);
 else
     flags2 |= (1<<1);
 if (((ops)->ind['s'] != 0)) {






     flags1 |= (1<<2);
     ht = sufaliastab;
 } else
     flags2 |= (1<<2);
    }

    if (((ops)->ind['L'] != 0))
 printflags |= (1<<2);
    else if (((ops)->ind['g'] & 2) || ((ops)->ind['r'] & 2) || ((ops)->ind['s'] & 2) ||
      ((ops)->ind['m'] & 2) || ((ops)->ind['+'] != 0))
 printflags |= (1<<0);



    if (!*argv) {
 (queueing_enabled++);
 scanhashtable(ht, 1, flags1, flags2, ht->printnode, printflags);
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return 0;
    }



    if (((ops)->ind['m'] != 0)) {
 for (; *argv; argv++) {
     tokenize(*argv);
     if ((pprog = patcompile(*argv, 0x0040, ((void *)0)))) {

  (queueing_enabled++);
  scanmatchtable(ht, pprog, 1, flags1, flags2,
          ht->printnode, printflags);
  do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     } else {
  untokenize(*argv);
  zwarnnam(name, "bad pattern : %s", *argv);
  returnval = 1;
     }
 }
 return returnval;
    }


    (queueing_enabled++);
    while ((asg = getasg(*argv++))) {
 if (asg->value && !((ops)->ind['L'] != 0)) {


     ht->addnode(ht, ztrdup(asg->name),
   createaliasnode(ztrdup(asg->value), flags1));
 } else if ((a = (Alias) ht->getnode(ht, asg->name))) {

     if (!type_opts || ht == sufaliastab ||
  (((ops)->ind['r'] != 0) &&
   !(a->node.flags & ((1<<1)|(1<<2)))) ||
  (((ops)->ind['g'] != 0) && (a->node.flags & (1<<1))))
  ht->printnode(&a->node, printflags);
 } else
     returnval = 1;
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return returnval;
}







int
bin_true(char *name __attribute__((__unused__)), char **argv __attribute__((__unused__)), Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    return 0;
}




int
bin_false(char *name __attribute__((__unused__)), char **argv __attribute__((__unused__)), Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    return 1;
}




 LinkList bufstack;
// # 3643 "builtin.c"
int
bin_print(char *name, char **args, Options ops, int func)
{
    int flen, width, prec, type, argc, n, narg, curlen = 0;
    int nnl = 0, fmttrunc = 0, ret = 0, maxarg = 0;
    int flags[5], *len;
    char *start, *endptr, *c, *d, *flag, *buf, spec[13], *fmt = ((void *)0);
    char **first, **argp, *curarg, *flagch = "0+- #", save = '\0', nullstr = '\0';
    size_t rcount, count = 0;

    size_t mcount;

    FILE *fout = stdout;
    Histent ent;

    mnumber mnumval;
    double doubleval;
    int intval;
    zlong zlongval;
    zulong zulongval;
    char *stringval;

    if (func == 26) {
        if (!strcmp(*args, "--") && !*++args) {
            zwarnnam(name, "not enough arguments");
     return 1;
        }
   fmt = *args++;
    } else if (func == 23 && (opts[BSDECHO]))
 ops->ind['E'] = 1;
    else if (((ops)->ind['f'] > 3))
 fmt = ((ops)->args[((ops)->ind['f'] >> 2) - 1]);
    if (fmt)
 fmt = getkeystring(fmt, &flen, ((ops)->ind['b'] != 0) ? (GETKEY_OCTAL_ESC|GETKEY_EMACS|GETKEY_CTRL) :
      (GETKEY_OCTAL_ESC|GETKEY_BACKSLASH_C|GETKEY_PRINTF_PERCENT), &fmttrunc);

    first = args;



    if (((ops)->ind['m'] != 0)) {
 Patprog pprog;
 char **t, **p;

 if (!*args) {
     zwarnnam(name, "no pattern specified");
     return 1;
 }
 tokenize(*args);
 if (!(pprog = patcompile(*args, 0x0040, ((void *)0)))) {
     untokenize(*args);
     zwarnnam(name, "bad pattern: %s", *args);
     return 1;
 }
 for (t = p = ++args; *p; p++)
     if (pattry(pprog, *p))
  *t++ = *p;
 *t = ((void *)0);
 first = args;
 if (fmt && !*args) return 0;
    }

    argc = arrlen(args);
    len = (int *) hcalloc(argc * sizeof(int));
    for(n = 0; n < argc; n++) {

 if (fmt ||
     (!((ops)->ind['e'] != 0) &&
      (((ops)->ind['R'] != 0) || ((ops)->ind['r'] != 0) || ((ops)->ind['E'] != 0))))
     unmetafy(args[n], &len[n]);
 else {
     int escape_how;
     if (((ops)->ind['b'] != 0))
  escape_how = (GETKEY_OCTAL_ESC|GETKEY_EMACS|GETKEY_CTRL);
     else if (func != 23 && !((ops)->ind['e'] != 0))
  escape_how = (GETKEY_OCTAL_ESC|GETKEY_BACKSLASH_C|GETKEY_EMACS);
     else
  escape_how = (GETKEY_BACKSLASH_C);
     args[n] = getkeystring(args[n], &len[n], escape_how, &nnl);
     if (nnl) {

  argc = n + 1;
  args[argc] = ((void *)0);
     }
 }

 if(((ops)->ind['P'] != 0)) {





     char *str = unmetafy(
  promptexpand(metafy(args[n], len[n], 5),
        0, ((void *)0), ((void *)0), ((void *)0)),
  &len[n]);
     args[n] = dupstrpfx(str, len[n]);
     free(str);
 }

 if(((ops)->ind['D'] != 0)) {
     Nameddir d;

     (queueing_enabled++);

     d = finddir(args[n]);
     if(d) {
  int dirlen = strlen(d->dir);
  char *arg = zhalloc(len[n] - dirlen + strlen(d->node.nam) + 2);
  sprintf(arg, "~%s%s", d->node.nam, args[n] + dirlen);
  args[n] = arg;
  len[n] = strlen(args[n]);
     }
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 }
    }


    if (((ops)->ind['u'] > 3) || ((ops)->ind['p'] != 0)) {
 int fd;

 if (((ops)->ind['p'] != 0)) {
     fd = coprocout;
     if (fd < 0) {
  zwarnnam(name, "-p: no coprocess");
  return 1;
     }
 } else {
     char *argptr = ((ops)->args[((ops)->ind['u'] >> 2) - 1]), *eptr;

     if (!strcmp(argptr, "p")) {
  fd = coprocout;
  if (fd < 0) {
      zwarnnam(name, "-p: no coprocess");
      return 1;
  }
     } else {
  fd = (int)zstrtol(argptr, &eptr, 10);
  if (*eptr) {
      zwarnnam(name, "number expected after -%c: %s", 'u',
        argptr);
      return 1;
  }
     }
 }

 if ((fd = dup(fd)) < 0) {
     zwarnnam(name, "bad file number: %d", fd);
     return 1;
 }
 if ((fout = fdopen(fd, "w")) == 0) {
     close(fd);
     zwarnnam(name, "bad mode on fd %d", fd);
     return 1;
 }
    }


    if (((ops)->ind['o'] != 0) || ((ops)->ind['O'] != 0)) {
 int flags;

 if (fmt && !*args) {
     if (fout != stdout)
         fclose(fout);
     return 0;
 }
 flags = ((ops)->ind['i'] != 0) ? SORTIT_IGNORING_CASE : 0;
 if (((ops)->ind['O'] != 0))
     flags |= SORTIT_BACKWARDS;
 strmetasort(args, flags, len);
    }


    if (!fmt && (((ops)->ind['c'] != 0) || ((ops)->ind['C'] != 0))) {
 int l, nc, nr, sc, n, t, i;

 int *widths;

 if ((opts[MULTIBYTE])) {
     int *wptr;





     wptr = widths = (int *) zhalloc(argc * sizeof(int));
     for (i = 0; i < argc && args[i]; i++, wptr++) {
  int l = len[i], width = 0;
  char *aptr = args[i];
  mbstate_t mbs;

  memset(&mbs, 0, sizeof(mbstate_t));
  while (l > 0) {
      wchar_t wc;
      size_t cnt;
      int wcw;
// # 3850 "builtin.c"
      if (*aptr == '\033' || *aptr == '\233') {
   for (aptr++, l--;
        l && !((*__ctype_b_loc ())[(int) ((((unsigned char)(*aptr))))] & (unsigned short int) _ISalpha);
        aptr++, l--)
       ;
   aptr++;
   l--;
   continue;
      }

      cnt = mbrtowc(&wc, aptr, l, &mbs);

      if (cnt == ((size_t)-2) || cnt == ((size_t)-1))
      {

   width += l;
   break;
      }
      wcw = wcwidth(wc);

      if (wcw > 0)
   width += wcw;

      if (cnt == 0)
   cnt = 1;
      aptr += cnt;
      l -= cnt;
  }
  widths[i] = width;
     }
 }
 else
     widths = len;




 if (((ops)->ind['C'] != 0)) {
     char *eptr, *argptr = ((ops)->args[((ops)->ind['C'] >> 2) - 1]);
     nc = (int)zstrtol(argptr, &eptr, 10);
     if (*eptr) {
  zwarnnam(name, "number expcted after -%c: %s", 'C', argptr);
  return 1;
     }
     if (nc <= 0) {
  zwarnnam(name, "invalid number of columns: %s", argptr);
  return 1;
     }





     n = arrlen(args);
     nr = (n + nc - 1) / nc;
// # 3913 "builtin.c"
     for (i = l = 0; i < argc; i++) {
  if (((ops)->ind['a'] != 0)) {
      if ((i % nc) == nc - 1)
   continue;
  } else {
      if (i >= nr * (nc - 1))
   break;
  }
  if (l < widths[i])
      l = widths[i];
     }
     sc = l + 2;
 }
 else
 {




     for (n = l = 0; n < argc; n++)
  if (l < widths[n])
      l = widths[n];





     sc = l + 2;
     nc = (zterm_columns + 1) / sc;
     if (!nc)
  nc = 1;
     nr = (n + nc - 1) / nc;
 }

 if (((ops)->ind['a'] != 0))
     n = 0;
 for (i = 0; i < nr; i++) {
     if (((ops)->ind['a'] != 0))
     {
  int ic;
  for (ic = 0; ic < nc && n < argc; ic++, n++)
  {
      fwrite(args[n], len[n], 1, fout);
      l = widths[n];
      if (n < argc)
   for (; l < sc; l++)
       fputc(' ', fout);
  }
     }
     else
     {
  n = i;
  do {
      fwrite(args[n], len[n], 1, fout);
      l = widths[n];
      for (t = nr; t && n < argc; t--, n++);
      if (n < argc)
   for (; l < sc; l++)
       fputc(' ', fout);
  } while (n < argc);
     }
     fputc(((ops)->ind['N'] != 0) ? '\0' : '\n', fout);
 }

 if ((fout != stdout) ? (fclose(fout) != 0) :
     (fflush(fout) != 0 && (*__errno_location ()) != 9)) {
            zwarnnam(name, "write error: %e", (*__errno_location ()));
            ret = 1;
 }
 return ret;
    }


    if (!fmt) {
 if (((ops)->ind['z'] != 0) || ((ops)->ind['s'] != 0)) {



     for (n = 0; n < argc; n++)
  metafy(args[n], len[n], 5);
 }


 if (((ops)->ind['z'] != 0)) {
     (queueing_enabled++);
     zinsertlinknode(bufstack,&(bufstack)->node,sepjoin(args, ((void *)0), 0));
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 0;
 }

 if (((ops)->ind['s'] != 0) || ((ops)->ind['S'] != 0)) {
     int nwords = 0, nlen, iwords;
     char **pargs = args;

     (queueing_enabled++);
     while (*pargs++)
  nwords++;
     if (nwords) {
  if (((ops)->ind['S'] != 0)) {
      int wordsize;
      short *words;
      if (nwords > 1) {
   zwarnnam(name, "option -S takes a single argument");
   return 1;
      }
      words = ((void *)0);
      wordsize = 0;
      histsplitwords(*args, &words, &wordsize, &nwords, 1);
      ent = prepnexthistent();
      ent->words = (short *)zalloc(nwords*sizeof(short));
      memcpy(ent->words, words, nwords*sizeof(short));
      free(words);
      ent->nwords = nwords/2;
  } else {
      ent = prepnexthistent();
      ent->words = (short *)zalloc(nwords*2*sizeof(short));
      ent->nwords = nwords;
      nlen = iwords = 0;
      for (pargs = args; *pargs; pargs++) {
   ent->words[iwords++] = nlen;
   nlen += strlen(*pargs);
   ent->words[iwords++] = nlen;
   nlen++;
      }
  }
     } else {
  ent = prepnexthistent();
  ent->words = (short *)((void *)0);
     }
     ent->node.nam = zjoin(args, ' ', 0);
     ent->stim = ent->ftim = time(((void *)0));
     ent->node.flags = 0;
     addhistnode(histtab, ent->node.nam, ent);
     do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
     return 0;
 }

 for (; *args; args++, len++) {
     fwrite(*args, *len, 1, fout);
     if (args[1])
  fputc(((ops)->ind['l'] != 0) ? '\n' :
        ((ops)->ind['N'] != 0) ? '\0' : ' ', fout);
 }
 if (!(((ops)->ind['n'] != 0) || nnl))
     fputc(((ops)->ind['N'] != 0) ? '\0' : '\n', fout);

 if ((fout != stdout) ? (fclose(fout) != 0) :
     (fflush(fout) != 0 && (*__errno_location ()) != 9)) {
            zwarnnam(name, "write error: %e", (*__errno_location ()));
            ret = 1;
 }
 return ret;
    }







    if (((ops)->ind['z'] != 0) || ((ops)->ind['s'] != 0)) {

     if ((fout = open_memstream(&buf, &mcount)) == ((void *)0))
     zwarnnam(name, "open_memstream failed");
// # 4085 "builtin.c"
    }


    *spec = '%';
    argp = args;
    do {
     rcount = count;
     if (maxarg) {
     first += maxarg;
     argc -= maxarg;
         maxarg = 0;
 }
 for (c = fmt; c-fmt < flen; c++) {
     if (*c != '%') {
  _IO_putc (*c, fout);
  ++count;
  continue;
     }

     start = c++;
     if (*c == '%') {
  _IO_putc ('%', fout);
  ++count;
  continue;
     }

     type = prec = -1;
     width = 0;
     curarg = ((void *)0);
     d = spec + 1;

     if (*c >= '1' && *c <= '9') {
      narg = strtoul(c, &endptr, 0);
  if (*endptr == '$') {
      c = endptr + 1;
      ;
      if (narg > argc) {
       zwarnnam(name, "%d: argument specifier out of range",
     narg);
   if (fout != stdout)
       fclose(fout);
   return 1;
      } else {
       if (narg > maxarg) maxarg = narg;
       curarg = *(first + narg - 1);
   curlen = len[first - args + narg - 1];
      }
  }
     }


     memset(flags, 0, sizeof(flags));
     while (*c && (flag = strchr(flagch, *c))) {
      if (!flags[flag - flagch]) {
          flags[flag - flagch] = 1;
      *d++ = *c;
  }
      c++;
     }

     if ((typtab[((unsigned char)(*c))] & (1 << 0))) {
  width = strtoul(c, &endptr, 0);
  c = endptr;
     } else if (*c == '*') {
  if ((typtab[((unsigned char)(*++c))] & (1 << 0))) {
      narg = strtoul(c, &endptr, 0);
      if (*endptr == '$') {
       c = endptr + 1;
   if (narg > argc || narg <= 0) {
           zwarnnam(name,
         "%d: argument specifier out of range",
         narg);
       if (fout != stdout)
    fclose(fout);
       return 1;
   } else {
           if (narg > maxarg) maxarg = narg;
           argp = first + narg - 1;
   }
      }
  }
  if (*argp) {
      width = (int)mathevali(*argp++);
      if (errflag) {
   errflag = 0;
   ret = 1;
      }
  }
     }
     *d++ = '*';

     if (*c == '.') {
  if (*++c == '*') {
      if ((typtab[((unsigned char)(*++c))] & (1 << 0))) {
   narg = strtoul(c, &endptr, 0);
   if (*endptr == '$') {
       c = endptr + 1;
       if (narg > argc || narg <= 0) {
        zwarnnam(name,
      "%d: argument specifier out of range",
      narg);
    if (fout != stdout)
        fclose(fout);
    return 1;
       } else {
        if (narg > maxarg) maxarg = narg;
        argp = first + narg - 1;
       }
   }
      }

      if (*argp) {
   prec = (int)mathevali(*argp++);
   if (errflag) {
       errflag = 0;
       ret = 1;
   }
      }
  } else if ((typtab[((unsigned char)(*c))] & (1 << 0))) {
      prec = strtoul(c, &endptr, 0);
      c = endptr;
  }
  if (prec >= 0) *d++ = '.', *d++ = '*';
     }


     if (*c == 'l' || *c == 'L' || *c == 'h') c++;

     if (!curarg && *argp) {
  curarg = *argp;
  curlen = len[argp++ - args];
     }
     d[1] = '\0';
     switch (*d = *c) {
     case 'c':
  if (curarg)
      intval = *curarg;
  else
      intval = 0;
  if (prec >= 0) count += fprintf(fout, spec, width, prec, intval); else count += fprintf(fout, spec, width, intval);;
  break;
     case 's':
     case 'b':
  if (curarg) {
      char *b, *ptr;
      int lbytes, lchars, lleft;

      mbstate_t mbs;


      if (*c == 'b') {
   b = getkeystring(metafy(curarg, curlen, 1),
      &lbytes,
      ((ops)->ind['b'] != 0) ? (GETKEY_OCTAL_ESC|GETKEY_EMACS|GETKEY_CTRL) :
      (GETKEY_BACKSLASH_C), &nnl);
      } else {
   b = curarg;
   lbytes = curlen;
      }
// # 4254 "builtin.c"
      ptr = b;

      memset(&mbs, 0, sizeof(mbs));


      for (lchars = 0, lleft = lbytes; lleft > 0; lchars++) {
   int chars;

   if (lchars == prec) {

       lbytes = ptr - b;
       break;
   }

   if ((opts[MULTIBYTE])) {
       chars = mbrlen(ptr, lleft, &mbs);
       if (chars < 0) {






    lchars += lleft;
    lbytes = (ptr - b) + lleft;
    break;
       } else if (chars == 0) {

    chars = 1;
       }
   }
   else

       chars = 1;
   lleft -= chars;
   ptr += chars;
      }
      if (width > 0 && flags[2]) width = -width;
      if (width > 0 && lchars < width)
       count += fprintf(fout, "%*c", width - lchars, ' ');
      count += fwrite(b, 1, lbytes, fout);
      if (width < 0 && lchars < -width)
       count += fprintf(fout, "%*c", -width - lchars, ' ');
      if (nnl) {

   flen = c - fmt + 1;
   fmttrunc = 1;
      }
  } else if (width)
      count += fprintf(fout, "%*c", width, ' ');
  break;
     case 'q':
  stringval = curarg ?
      quotestring(curarg, ((void *)0), QT_BACKSLASH_SHOWNULL) : &nullstr;
  *d = 's';
  if (prec >= 0) count += fprintf(fout, spec, width, prec, stringval); else count += fprintf(fout, spec, width, stringval);;
  break;
     case 'd':
     case 'i':
  type=1;
  break;
     case 'e':
     case 'E':
     case 'f':
     case 'g':
     case 'G':
  type=2;
  break;
     case 'o':
     case 'u':
     case 'x':
     case 'X':
  type=3;
  break;
     case 'n':
  if (curarg) setiparam(curarg, count - rcount);
  break;
     default:
         if (*c) {
      save = c[1];
             c[1] = '\0';
  }
  zwarnnam(name, "%s: invalid directive", start);
  if (*c) c[1] = save;

  if ((fout != stdout) ? (fclose(fout) != 0) :
      (fflush(fout) != 0 && (*__errno_location ()) != 9)) {
      zwarnnam(name, "write error: %e", (*__errno_location ()));
  }
  return 1;
     }

     if (type > 0) {
  if (curarg && (*curarg == '\'' || *curarg == '"' )) {
      convchar_t cc;

      if ((opts[MULTIBYTE])) {
   mb_metacharinit();
   (void)mb_metacharlenconv(metafy(curarg+1, curlen-1,
       1), &cc);
      }
      else
   cc = (0xffffffffu);
      if (cc == (0xffffffffu))
   cc = (curlen > 1) ? ((unsigned char)(curarg[1])) : 0;



      if (type == 2) {
   doubleval = cc;
   if (prec >= 0) count += fprintf(fout, spec, width, prec, doubleval); else count += fprintf(fout, spec, width, doubleval);;
      } else {
   intval = cc;
   if (prec >= 0) count += fprintf(fout, spec, width, prec, intval); else count += fprintf(fout, spec, width, intval);;
      }
  } else {
      switch (type) {
      case 1:



       *d++ = 'l', *d++ = *c, *d = '\0';
   zlongval = (curarg) ? mathevali(curarg) : 0;
   if (errflag) {
       zlongval = 0;
       errflag = 0;
       ret = 1;
   }
   if (prec >= 0) count += fprintf(fout, spec, width, prec, zlongval); else count += fprintf(fout, spec, width, zlongval);
       break;
      case 2:
   if (curarg) {
       char *eptr;
// # 4395 "builtin.c"
       doubleval = strtod(curarg, &eptr);




       if (*eptr != '\0') {
    mnumval = matheval(curarg);
    doubleval = (mnumval.type & 2) ?
        mnumval.u.d : (double)mnumval.u.l;
       }
   } else doubleval = 0;
   if (errflag) {
       doubleval = 0;
       errflag = 0;
       ret = 1;
   }
   if (prec >= 0) count += fprintf(fout, spec, width, prec, doubleval); else count += fprintf(fout, spec, width, doubleval);
       break;
      case 3:



       *d++ = 'l', *d++ = *c, *d = '\0';
   zulongval = (curarg) ? mathevali(curarg) : 0;
   if (errflag) {
       zulongval = 0;
       errflag = 0;
       ret = 1;
   }
   if (prec >= 0) count += fprintf(fout, spec, width, prec, zulongval); else count += fprintf(fout, spec, width, zulongval);
      }
  }
     }
     if (maxarg && (argp - first > maxarg))
      maxarg = argp - first;
 }

     if (maxarg) argp = first + maxarg;

    } while (*argp && argp != first && !fmttrunc && !((ops)->ind['r'] != 0));

    if (((ops)->ind['z'] != 0) || ((ops)->ind['s'] != 0)) {

 _IO_putc (0, fout);
 fflush(fout);






 (queueing_enabled++);
 if (((ops)->ind['z'] != 0)) {
     zinsertlinknode(bufstack,&(bufstack)->node,buf);
 } else {
     ent = prepnexthistent();
     ent->node.nam = buf;
     ent->stim = ent->ftim = time(((void *)0));
     ent->node.flags = 0;
     ent->words = (short *)((void *)0);
     addhistnode(histtab, ent->node.nam, ent);
 }
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    }


    if ((fout != stdout) ? (fclose(fout) != 0) :
 (fflush(fout) != 0 && (*__errno_location ()) != 9)) {
 zwarnnam(name, "write error: %e", (*__errno_location ()));
 ret = 1;
    }
    return ret;
}




int
bin_shift(char *name, char **argv, Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    int num = 1, l, ret = 0;
    char **s;


    (queueing_enabled++);
    if (*argv && !getaparam(*argv))
        num = mathevali(*argv++);

    if (num < 0) {
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
        zwarnnam(name, "argument to shift must be non-negative");
        return 1;
    }

    if (*argv) {
        for (; *argv; argv++)
            if ((s = getaparam(*argv))) {
                if (num > arrlen(s)) {
      zwarnnam(name, "shift count must be <= $#");
      ret++;
      continue;
  }
  s = zarrdup(s + num);
                assignaparam(*argv,s,0);
            }
    } else {
        if (num > (l = arrlen(pparams))) {
     zwarnnam(name, "shift count must be <= $#");
     ret = 1;
 } else {
     s = zalloc((l - num + 1) * sizeof(char *));
     memcpy(s, pparams + num, (l - num + 1) * sizeof(char *));
     while (num--)
  zsfree(pparams[num]);
     zfree(pparams, (l + 1) * sizeof(char *));
     pparams = s;
 }
    }
    do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
    return ret;
}


int optcind;




int
bin_getopts(char *name __attribute__((__unused__)), char **argv, Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    int lenstr, lenoptstr, quiet, lenoptbuf;
    char *optstr = unmetafy(*argv++, &lenoptstr), *var = *argv++;
    char **args = (*argv) ? argv : pparams;
    char *str, optbuf[2] = " ", *p, opch;



    if (zoptind < 1) {

 zoptind = 1;
 optcind = 0;
    }
    if(zoptind > arrlen(args))

 return 1;


    quiet = *optstr == ':';
    optstr += quiet;
    lenoptstr -= quiet;


    str = unmetafy(dupstring(args[zoptind - 1]), &lenstr);
    if (!lenstr)
 return 1;
    if(optcind >= lenstr) {
 optcind = 0;
 if(!args[zoptind++])
     return 1;
 str = unmetafy(dupstring(args[zoptind - 1]), &lenstr);
    }
    if(!optcind) {
 if(lenstr < 2 || (*str != '-' && *str != '+'))
     return 1;
 if(lenstr == 2 && str[0] == '-' && str[1] == '-') {
     zoptind++;
     return 1;
 }
 optcind++;
    }
    opch = str[optcind++];
    if(str[0] == '+') {
 optbuf[0] = '+';
 lenoptbuf = 2;
    } else
 lenoptbuf = 1;
    optbuf[lenoptbuf - 1] = opch;


    if(opch == ':' || !(p = memchr(optstr, opch, lenoptstr))) {
 p = "?";
    err:
 zsfree(zoptarg);
 assignsparam(var,ztrdup(p),0);
 if(quiet) {
     zoptarg = metafy(optbuf, lenoptbuf, 3);
 } else {
     zwarn(*p == '?' ? "bad option: -%c" :
    "argument expected after -%c option", opch);
     zoptarg=ztrdup("");
 }
 return 0;
    }


    if(p[1] == ':') {
 if(optcind == lenstr) {
     if(!args[zoptind]) {
  p = ":";
  goto err;
     }
     p = ztrdup(args[zoptind++]);
 } else
     p = metafy(str+optcind, lenstr-optcind, 3);







 optcind = 0;
 zoptind++;
 zsfree(zoptarg);
 zoptarg = p;
    } else {
 zsfree(zoptarg);
 zoptarg = ztrdup("");
    }

    assignsparam(var,metafy(optbuf, lenoptbuf, 3),0);
    return 0;
}



 int
exit_pending;






int
bin_break(char *name, char **argv, Options ops __attribute__((__unused__)), int func)
{
    int num = lastval, nump = 0;


    if (*argv) {
 num = mathevali(*argv++);
 nump = 1;
    }

    if (nump > 0 && (func == 7 || func == 6) && num <= 0) {
 zerrnam(name, "argument is not positive: %d", num);
 return 1;
    }

    switch (func) {
    case 7:
 if (!loops) {
     zerrnam(name, "not in while, until, select, or repeat loop");
     return 1;
 }
 contflag = 1;
    case 6:
 if (!loops) {
     zerrnam(name, "not in while, until, select, or repeat loop");
     return 1;
 }
 breaks = nump ? ((num) < (loops) ? (num) : (loops)) : 1;
 break;
    case 9:
 if (((opts[INTERACTIVE]) && (opts[SHINSTDIN]))
     || locallevel || sourcelevel) {
     retflag = 1;
     breaks = loops;
     lastval = num;
     if (trap_state == TRAP_STATE_PRIMED && trap_return == -2) {
  trap_state = TRAP_STATE_FORCE_RETURN;
  trap_return = lastval;
     }
     return lastval;
 }
 zexit(num, 0);
 break;
    case 19:
 if ((!opts[LOGINSHELL])) {
     zerrnam(name, "not login shell");
     return 1;
 }

    case 8:
 if (locallevel > forklevel) {
// # 4691 "builtin.c"
     if (stopmsg || (zexit(0,2), !stopmsg)) {
  retflag = 1;
  breaks = loops;
  exit_pending = (num << 1) | 1;
     }
 } else
     zexit(num, 0);
 break;
    }
    return 0;
}




 int stopmsg;




static void
checkjobs(void)
{
    int i;

    for (i = 1; i <= maxjob; i++)
 if (i != thisjob && (jobtab[i].stat & (0x0010)) &&
     !(jobtab[i].stat & (0x0020)))
     break;
    if (i <= maxjob) {
 if (jobtab[i].stat & (0x0002)) {


     zerr("you have suspended jobs.");




 } else
     zerr("you have running jobs.");
 stopmsg = 1;
    }
}
// # 4743 "builtin.c"
 void
zexit(int val, int from_where)
{
    static int in_exit;


    if (in_exit == -1)
 return;

    if ((opts[MONITOR]) && !stopmsg && from_where != 1) {
 scanjobs();
 if ((opts[CHECKJOBS]))
     checkjobs();
 if (stopmsg) {
     stopmsg = 2;
     return;
 }
    }

    if (from_where == 2 || (in_exit++ && from_where))
 return;





    in_exit = -1;




    errflag = 0;

    if ((opts[MONITOR])) {

 killrunjobs(from_where == 1);
    }
    if ((opts[RCS]) && ((opts[INTERACTIVE]))) {
 if (!nohistsave) {
     int writeflags = 0x8000;
     if (from_where == 1)
  writeflags |= 0x0020;
     saveandpophiststack(1, writeflags);
     savehistfile(((void *)0), 1, writeflags);
 }
 if (((opts[LOGINSHELL])) && !subsh) {
     sourcehome(".zlogout");

     if ((opts[RCS]) && (opts[GLOBALRCS]))
  source("/etc/zlogout");

 }
    }
    lastval = val;
    if (sigtrapped[0])
 dotrap(0);
    callhookfunc("zshexit", ((void *)0), 1, ((void *)0));
    runhookdef((zshhooks + 0), ((void *)0));
    if (opts[MONITOR] && ((opts[INTERACTIVE])) && (SHTTY != -1)) {
       release_pgrp();
    }
    if (mypid != getpid())
 _exit(val);
    else
 exit(val);
}




int
bin_dot(char *name, char **argv, Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    char **old, *old0 = ((void *)0);
    int diddot = 0, dotdot = 0;
    char *s, **t, *enam, *arg0, *buf;
    struct stat st;
    enum source_return ret;

    if (!*argv)
 return 0;
    old = pparams;

    if (argv[1])
 pparams = zarrdup(argv + 1);

    enam = arg0 = ztrdup(*argv);
    if ((opts[FUNCTIONARGZERO])) {
 old0 = argzero;
 argzero = ztrdup(arg0);
    }
    s = unmeta(enam);
    (*__errno_location ()) = 2;
    ret = SOURCE_NOT_FOUND;

    if (*name != '.' && access(s, 0) == 0
 && stat(s, &st) >= 0 && !((((st.st_mode)) & 0170000) == (0040000))) {
 diddot = 1;
 ret = source(enam);
    }
    if (ret == SOURCE_NOT_FOUND) {

 for (s = arg0; *s; s++)
     if (*s == '/') {
  if (*arg0 == '.') {
      if (arg0 + 1 == s)
   ++diddot;
      else if (arg0[1] == '.' && arg0 + 2 == s)
   ++dotdot;
  }
  ret = source(arg0);
  break;
     }
 if (!*s || (ret == SOURCE_NOT_FOUND &&
      (opts[PATHDIRS]) && diddot < 2 && dotdot == 0)) {
     pushheap();

     for (t = path; *t; t++) {
  if (!(*t)[0] || ((*t)[0] == '.' && !(*t)[1])) {
      if (diddot)
   continue;
      diddot = 1;
      buf = dupstring(arg0);
  } else
      buf = zhtricat(*t, "/", arg0);

  s = unmeta(buf);
  if (access(s, 0) == 0 && stat(s, &st) >= 0
      && !((((st.st_mode)) & 0170000) == (0040000))) {
      ret = source(enam = buf);
      break;
  }
     }
     popheap();
 }
    }

    if (argv[1]) {
 freearray(pparams);
 pparams = old;
    }
    if (ret == SOURCE_NOT_FOUND) {
 if ((opts[POSIXBUILTINS])) {

     zerrnam(name, "%e: %s", (*__errno_location ()), enam);
 } else {
     zwarnnam(name, "%e: %s", (*__errno_location ()), enam);
 }
    }
    zsfree(arg0);
    if (old0) {
 zsfree(argzero);
 argzero = old0;
    }
    return ret == SOURCE_OK ? lastval : 128 - ret;
}





static int
eval(char **argv)
{
    Eprog prog;
    char *oscriptname = scriptname;
    int oineval = ineval, fpushed;
    struct funcstack fstack;






    ineval = !(opts[EVALLINENO]);
    if (!ineval) {
 scriptname = "(eval)";
 fstack.prev = funcstack;
 fstack.name = scriptname;
 fstack.caller = funcstack ? funcstack->name : dupstring(argzero);
 fstack.lineno = lineno;
 fstack.tp = FS_EVAL;
// # 4936 "builtin.c"
 if (!funcstack || funcstack->tp == FS_SOURCE) {
     fstack.flineno = fstack.lineno;
     fstack.filename = fstack.caller;
 } else {
     fstack.flineno = funcstack->flineno + lineno;




     if (funcstack->tp == FS_EVAL)
  fstack.flineno--;
     fstack.filename = funcstack->filename;
     if (!fstack.filename)
  fstack.filename = "";
 }
 funcstack = &fstack;

 fpushed = 1;
    } else
 fpushed = 0;

    prog = parse_string(zjoin(argv, ' ', 1), 1);
    if (prog) {
 if (((*prog->prog) & ((wordcode) ((1 << 5) - 1))) != 1) {

     lastval = 0;
 } else {
     execode(prog, 1, 0, "eval");

     if (errflag && !lastval)
  lastval = errflag;
 }
    } else {
 lastval = 1;
    }

    if (fpushed)
 funcstack = funcstack->prev;

    errflag = 0;
    scriptname = oscriptname;
    ineval = oineval;

    return lastval;
}




int
bin_emulate(char *nam __attribute__((__unused__)), char **argv, Options ops, int func __attribute__((__unused__)))
{
    int opt_L = ((ops)->ind['L'] != 0);
    int opt_R = ((ops)->ind['R'] != 0);
    int saveemulation, savesticky_emulation, savehackchar;
    int ret = 1;
    char saveopts[OPT_SIZE];
    char *cmd = 0;
    const char *shname = *argv;


    if (!shname) {
 if (opt_L || opt_R) {
     zwarnnam("emulate", "not enough arguments");
     return 1;
 }

 switch((emulation & ((1<<5)-1))) {
 case (1<<1):
     shname = "csh";
     break;

 case (1<<2):
     shname = "ksh";
     break;

 case (1<<3):
     shname = "sh";
     break;

 default:
     shname = "zsh";
     break;
 }

 printf("%s\n", shname);
 return 0;
    }


    if (!argv[1]) {
 emulate(shname, ((ops)->ind['R'] != 0));
 if (((ops)->ind['L'] != 0))
     opts[LOCALOPTIONS] = opts[LOCALTRAPS] = 1;
 return 0;
    }

    argv++;
    memcpy(saveopts, opts, sizeof(opts));
    savehackchar = keyboardhackchar;
    cmd = parseopts("emulate", &argv);


    if (*argv) {
 zwarnnam("emulate", "unknown argument %s", *argv);
 goto restore;
    }




    if (cmd) {
 if (opt_L) {
     zwarnnam("emulate", "option -L incompatible with -c");
     goto restore;
 }
 *--argv = cmd;
    } else
 return 0;

    saveemulation = emulation;
    savesticky_emulation = sticky_emulation;
    emulate(shname, ((ops)->ind['R'] != 0));
    sticky_emulation = emulation;
    ret = eval(argv);
    sticky_emulation = savesticky_emulation;
    emulation = saveemulation;
 restore:
    memcpy(opts, saveopts, sizeof(opts));
    keyboardhackchar = savehackchar;
    inittyptab();
    return ret;
}




 int ineval;


int
bin_eval(char *nam __attribute__((__unused__)), char **argv, Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    return eval(argv);
}

static char *zbuf;
static int readfd;
// # 5095 "builtin.c"
int
bin_read(char *name, char **args, Options ops, int func __attribute__((__unused__)))
{
    char *reply, *readpmpt;
    int bsiz, c = 0, gotnl = 0, al = 0, first, nchars = 1, bslash, keys = 0;
    int haso = 0;
    int isem = !strcmp(term, "emacs"), izle = zleactive;
    char *buf, *bptr, *firstarg, *zbuforig;
    LinkList readll = newlinklist();
    FILE *oshout = ((void *)0);
    int readchar = -1, val, resettty = 0;
    struct ttyinfo saveti;
    char d;
    long izle_timeout = 0;

    wchar_t delim = L'\n', wc;
    mbstate_t mbs;
    char *laststart;
    size_t ret;




    if (((ops)->ind[c='k'] > 3)) {
 char *eptr, *optarg = ((ops)->args[((ops)->ind[c] >> 2) - 1]);
 nchars = (int)zstrtol(optarg, &eptr, 10);
 if (*eptr) {
     zwarnnam(name, "number expected after -%c: %s", c, optarg);
     return 1;
 }
    }


    firstarg = (*args && **args == '?' ? *args++ : *args);
    reply = *args ? *args++ : ((ops)->ind['A'] != 0) ? "reply" : "REPLY";

    if (((ops)->ind['A'] != 0) && *args) {
 zwarnnam(name, "only one array argument allowed");
 return 1;
    }


    if(((ops)->ind['l'] != 0) || ((ops)->ind['c'] != 0))
 return compctlreadptr(name, args, ops, reply);

    if ((((ops)->ind['k'] != 0) || ((ops)->ind['q'] != 0)) &&
 !((ops)->ind['u'] != 0) && !((ops)->ind['p'] != 0)) {
 if (!zleactive) {
     if (SHTTY == -1) {

  if ((SHTTY = open("/dev/tty", 02|0400)) != -1) {
      haso = 1;
      oshout = shout;
      init_shout();
  }
     } else if (!shout) {

  init_shout();
     }

     if (SHTTY == -1) {

  fprintf(stderr, "not interactive and can't open terminal\n");
  fflush(stderr);
  return 1;
     }
     if ((!opts[INTERACTIVE]))
  gettyinfo(&shttyinfo);

     attachtty(mypgrp);
     if (!isem)
  setcbreak();
     readfd = SHTTY;
 }
 keys = 1;
    } else if (((ops)->ind['u'] > 3) && !((ops)->ind['p'] != 0)) {

 char *eptr, *argptr = ((ops)->args[((ops)->ind['u'] >> 2) - 1]);

 if (!strcmp(argptr, "p")) {
     readfd = coprocin;
     if (readfd < 0) {
  zwarnnam(name, "-p: no coprocess");
  return 1;
     }
 } else {
     readfd = (int)zstrtol(argptr, &eptr, 10);
     if (*eptr) {
  zwarnnam(name, "number expected after -%c: %s", 'u', argptr);
  return 1;
     }
 }




 izle = 0;
    } else if (((ops)->ind['p'] != 0)) {
 readfd = coprocin;
 if (readfd < 0) {
     zwarnnam(name, "-p: no coprocess");
     return 1;
 }
 izle = 0;
    } else
 readfd = izle = 0;

    if (((ops)->ind['s'] != 0) && SHTTY != -1) {
 struct ttyinfo ti;
 gettyinfo(&ti);
 saveti = ti;
 resettty = 1;

 ti.tio.c_lflag &= ~0000010;



 settyinfo(&ti);
    }


    if (firstarg) {
 for (readpmpt = firstarg;
      *readpmpt && *readpmpt != '?'; readpmpt++);
 if (*readpmpt++) {
     if (keys || isatty(0)) {
  zputs(readpmpt, (shout ? shout : stderr));
  fflush(shout ? shout : stderr);
     }
     readpmpt[-1] = '\0';
 }
    }

    if (((ops)->ind['d'] != 0)) {
 char *delimstr = ((ops)->args[((ops)->ind['d'] >> 2) - 1]);

 wint_t wi;

 if ((opts[MULTIBYTE])) {
     mb_metacharinit();
     (void)mb_metacharlenconv(delimstr, &wi);
 }
 else
     wi = (0xffffffffu);
 if (wi != (0xffffffffu))
     delim = (wchar_t)wi;
 else
     delim = (wchar_t)((delimstr[0] == ((char) 0x83)) ?
         delimstr[1] ^ 32 : delimstr[0]);



 if (SHTTY != -1) {
     struct ttyinfo ti;
     gettyinfo(&ti);
     if (! resettty) {
       saveti = ti;
       resettty = 1;
     }

     ti.tio.c_lflag &= ~0000002;
     ti.tio.c_cc[6] = 1;
     ti.tio.c_cc[5] = 0;



     settyinfo(&ti);
 }
    }
    if (((ops)->ind['t'] != 0)) {
 zlong timeout = 0;
 if (((ops)->ind['t'] > 3)) {
     mnumber mn = zero_mnumber;
     mn = matheval(((ops)->args[((ops)->ind['t'] >> 2) - 1]));
     if (errflag)
  return 1;
     if (mn.type == 2) {
  mn.u.d *= 1e6;
  timeout = (zlong)mn.u.d;
     } else {
  timeout = (zlong)mn.u.l * (zlong)1000000;
     }
 }
 if (izle) {




     timeout = -(timeout/(zlong)10000 + 1L);
     izle_timeout = (long)timeout;


     if ((zlong)izle_timeout != timeout)
  izle_timeout = 9223372036854775807L;

 } else {
     if (readfd == -1 ||
  !read_poll(readfd, &readchar, keys && !zleactive,
      timeout)) {
  if (keys && !zleactive && !isem)
      settyinfo(&shttyinfo);
  else if (resettty && SHTTY != -1)
      settyinfo(&saveti);
  if (haso) {
      fclose(shout);
      shout = oshout;
      SHTTY = -1;
  }
  return ((ops)->ind['q'] != 0) ? 2 : 1;
     }
 }
    }


    memset(&mbs, 0, sizeof(mbs));






    if (((ops)->ind['k'] != 0) || ((ops)->ind['q'] != 0)) {
 int eof = 0;


 bptr = buf = (char *)zalloc(nchars*(__ctype_get_mb_cur_max ())+1);




 do {
     if (izle) {
  zleentry(ZLE_CMD_GET_KEY, izle_timeout, ((void *)0), &val);
  if (val < 0) {
      eof = 1;
      break;
  }
  *bptr = (char) val;

  if ((opts[MULTIBYTE])) {
      ret = mbrlen(bptr++, 1, &mbs);
      if (ret == ((size_t)-1))
   memset(&mbs, 0, sizeof(mbs));

      if (ret != ((size_t)-2))
   nchars--;
      continue;
  } else {
      bptr++;
      nchars--;
  }




     } else {

  if (readchar >= 0) {
      *bptr = readchar;
      val = 1;
      readchar = -1;
  } else {
      while ((val = read(readfd, bptr, nchars)) < 0) {
   if ((*__errno_location ()) != 4 ||
       errflag || retflag || breaks || contflag)
       break;
      }
      if (val <= 0) {
   eof = 1;
   break;
      }
  }


  if ((opts[MULTIBYTE])) {
      while (val > 0) {
   ret = mbrlen(bptr, val, &mbs);
   if (ret == ((size_t)-2)) {
       bptr += val;
       break;
   } else {
       if (ret == ((size_t)-1)) {
    memset(&mbs, 0, sizeof(mbs));

    ret = 1;
       }
       else if (ret == 0)
    ret = 1;
       else if (ret > (size_t)val) {

    ret = val;
       }
       nchars--;
       val -= ret;
       bptr += ret;
   }
      }
      continue;
  }


  nchars -= val;


  bptr += val;
     }
 } while (nchars > 0);

 if (!izle && !((ops)->ind['u'] != 0) && !((ops)->ind['p'] != 0)) {

     if (isem)
  while (val > 0 && read(SHTTY, &d, 1) == 1 && d != '\n');
     else {
  settyinfo(&shttyinfo);
  resettty = 0;
     }
     if (haso) {
  fclose(shout);
  shout = oshout;
  SHTTY = -1;
     }
 }

 if (((ops)->ind['q'] != 0))
 {




     if (eof)
  eof = 2;
     else
  eof = (bptr - buf != 1 || (buf[0] != 'y' && buf[0] != 'Y'));
 }
 if (((ops)->ind['e'] != 0) || ((ops)->ind['E'] != 0))
     fwrite(buf, bptr - buf, 1, stdout);
 if (!((ops)->ind['e'] != 0))
     assignsparam(reply,metafy(buf, bptr - buf, 0),0);
 else
     zfree(buf, bptr - buf + 1);
 if (resettty && SHTTY != -1)
     settyinfo(&saveti);
 return eof;
    }






    zbuforig = zbuf = (!((ops)->ind['z'] != 0)) ? ((void *)0) :
 ((((bufstack)->list.first) != ((void *)0))) ? (char *) getlinknode(bufstack) : ztrdup("");
    first = 1;
    bslash = 0;
    while (*args || (((ops)->ind['A'] != 0) && !gotnl)) {
 sigset_t s = signal_unblock(sigchld_mask);
 buf = bptr = (char *)zalloc(bsiz = 64);

 laststart = buf;
 ret = ((size_t)-2);


 while (!gotnl) {
     c = zread(izle, &readchar, izle_timeout);



     if (c == (-1)) {

  ret = 0;
  break;
     }
     *bptr = (char)c;
     if ((opts[MULTIBYTE])) {
  ret = mbrtowc(&wc, bptr, 1, &mbs);
  if (!ret)
      ret = 1;
     } else {
  ret = 1;
  wc = (wchar_t)c;
     }
     if (ret != ((size_t)-2)) {
  if (ret == ((size_t)-1)) {
      memset(&mbs, 0, sizeof(mbs));

      wc = (wchar_t)c;
      laststart = bptr;
  }
  if (bslash && wc == delim) {
      bslash = 0;
      continue;
  }
  if (wc == delim)
      break;
// # 5498 "builtin.c"
  if (!bslash && wcsitype(wc, (1 << 5))) {
      if (bptr != buf ||
   (!(c < 128 && (typtab[((unsigned char)(c))] & (1 << 13))) && first)) {
   first |= !(c < 128 && (typtab[((unsigned char)(c))] & (1 << 13)));
   break;
      }
      first |= !(c < 128 && (typtab[((unsigned char)(c))] & (1 << 13)));
      continue;
  }
  bslash = (wc == L'\\' && !bslash && !((ops)->ind['r'] != 0));
  if (bslash)
      continue;
  first = 0;
     }
     if ((typtab[((unsigned char)(((unsigned char)(*bptr))))] & (1 << 12))) {
  bptr[1] = bptr[0] ^ 32;
  bptr[0] = ((char) 0x83);
  bptr += 2;
     }
     else
  bptr++;
     if (ret != ((size_t)-2))
  laststart = bptr;
// # 5558 "builtin.c"
     if (bptr >= buf + bsiz - 1) {
  int blen = bptr - buf;

  int llen = laststart - buf;


  buf = realloc(buf, bsiz *= 2);
  bptr = buf + blen;

  laststart = buf + llen;

     }
 }
 signal_setmask(s);

 if (c == (-1)) {
     gotnl = 1;
     *bptr = '\0';
 } else if (ret == ((size_t)-2)) {





     *bptr = '\0';
 } else {
     if (wc == delim)
  gotnl = 1;
     *laststart = '\0';
 }






 if (((ops)->ind['e'] != 0) ||






     (((ops)->ind['E'] != 0) && !((ops)->ind['A'] != 0))) {
     zputs(buf, stdout);
     putchar('\n');
 }
 if (!((ops)->ind['e'] != 0) && (*buf || first)) {
     if (((ops)->ind['A'] != 0)) {
  insertlinknode(readll,((readll)->list.last),buf);
  al++;
     } else
  assignsparam(reply,buf,0);
 } else
     free(buf);
 if (!((ops)->ind['A'] != 0))
     reply = *args++;
    }

    if (c == (-1)) {
 if (readfd == coprocin) {
     close(coprocin);
     close(coprocout);
     coprocin = coprocout = -1;
 }
    }

    if (((ops)->ind['A'] != 0)) {
 char **pp, **p = ((void *)0);
 LinkNode n;

 p = (((ops)->ind['e'] != 0) ? (char **)((void *)0)
      : (char **)zalloc((al + 1) * sizeof(char *)));

 for (pp = p, n = ((readll)->list.first); n; (n = ((n)->next))) {
     if (((ops)->ind['E'] != 0)) {
  zputs((char *) ((n)->dat), stdout);
  putchar('\n');
     }
     if (p)
  *pp++ = (char *)((n)->dat);
     else
  zsfree(((n)->dat));
 }
 if (p) {
     *pp++ = ((void *)0);
     assignaparam(reply,p,0);
 }
 if (resettty && SHTTY != -1)
     settyinfo(&saveti);
 return c == (-1);
    }
    buf = bptr = (char *)zalloc(bsiz = 64);

    laststart = buf;
    ret = ((size_t)-2);


    bslash = 0;
    if (!gotnl) {
 sigset_t s = signal_unblock(sigchld_mask);
 for (;;) {
     c = zread(izle, &readchar, izle_timeout);

     if (c == (-1)) {

  ret = 0;
  break;
     }
     *bptr = (char)c;
     if ((opts[MULTIBYTE])) {
  ret = mbrtowc(&wc, bptr, 1, &mbs);
  if (!ret)
      ret = 1;
     } else {
  ret = 1;
  wc = (wchar_t)c;
     }
     if (ret != ((size_t)-2)) {
  if (ret == ((size_t)-1)) {
      memset(&mbs, 0, sizeof(mbs));

      wc = (wchar_t)c;
      laststart = bptr;
  }




  if (bslash && wc == delim) {
      bslash = 0;
      continue;
  }
  if (wc == delim && !zbuf)
      break;
  if (!bslash && bptr == buf && wcsitype(wc, (1 << 5))) {
      if (c < 128 && (typtab[((unsigned char)(c))] & (1 << 13)))
   continue;
      else if (!first) {
   first = 1;
   continue;
      }
  }
  bslash = (wc == L'\\' && !bslash && !((ops)->ind['r'] != 0));
  if (bslash)
      continue;
     }
     if ((typtab[((unsigned char)(((unsigned char)(*bptr))))] & (1 << 12))) {
  bptr[1] = bptr[0] ^ 32;
  bptr[0] = ((char) 0x83);
  bptr += 2;
     }
     else
  bptr++;
     if (ret != ((size_t)-2))
  laststart = bptr;
// # 5741 "builtin.c"
     if (bptr >= buf + bsiz - 1) {
  int blen = bptr - buf;

  int llen = laststart - buf;


  buf = realloc(buf, bsiz *= 2);
  bptr = buf + blen;

  laststart = buf + llen;

     }
 }
 signal_setmask(s);
    }

    if (ret != ((size_t)-2))
 bptr = laststart;






    while (bptr > buf) {
 if (bptr > buf + 1 && bptr[-2] == ((char) 0x83)) {

     break;
 } else if ((typtab[((unsigned char)(bptr[-1]))] & (1 << 13)))
     bptr--;
 else
     break;
    }
    *bptr = '\0';
    if (resettty && SHTTY != -1)
 settyinfo(&saveti);

    if (((ops)->ind['e'] != 0) || ((ops)->ind['E'] != 0)) {
 zputs(buf, stdout);
 putchar('\n');
    }
    if (!((ops)->ind['e'] != 0))
 assignsparam(reply,buf,0);
    else
 zsfree(buf);
    if (zbuforig) {
 char first = *zbuforig;

 zsfree(zbuforig);
 if (!first)
     return 1;
    } else if (c == (-1)) {
 if (readfd == coprocin) {
     close(coprocin);
     close(coprocout);
     coprocin = coprocout = -1;
 }
 return 1;
    }





    return errflag;
}


static int
zread(int izle, int *readchar, long izle_timeout)
{
    char cc, retry = 0;
    int ret;

    if (izle) {
 int c;
 zleentry(ZLE_CMD_GET_KEY, izle_timeout, ((void *)0), &c);

 return (c < 0 ? (-1) : c);
    }

    if (zbuf) {



 if (*zbuf == ((char) 0x83))
     return zbuf++, ((unsigned char)(*zbuf++ ^ 32));
 else
     return (*zbuf) ? ((unsigned char)(*zbuf++)) : (-1);
    }
    if (*readchar >= 0) {
 cc = *readchar;
 *readchar = -1;
 return ((unsigned char)(cc));
    }
    for (;;) {

 ret = read(readfd, &cc, 1);
 switch (ret) {
 case 1:

     return ((unsigned char)(cc));
 case -1:

     if (!retry && readfd == 0 && (

  (*__errno_location ()) == 11

  ||



  (*__errno_location ()) == 11

  ) && setblock_stdin()) {
  retry = 1;
  continue;
     } else

  if ((*__errno_location ()) == 4 && !(errflag || retflag || breaks || contflag))
      continue;
     break;
 }
 return (-1);
    }
}



char **testargs, **curtestarg;




void
testlex(void)
{
    if (tok == LEXERR)
 return;

    tokstr = *(curtestarg = testargs);
    if (!*testargs) {

 tok = tok ? NULLTOK : LEXERR;
 return;
    } else if (!strcmp(*testargs, "-o"))
 tok = DBAR;
    else if (!strcmp(*testargs, "-a"))
 tok = DAMPER;
    else if (!strcmp(*testargs, "!"))
 tok = BANG;
    else if (!strcmp(*testargs, "("))
 tok = INPAR;
    else if (!strcmp(*testargs, ")"))
 tok = OUTPAR;
    else
 tok = STRING;
    testargs++;
}


int
bin_test(char *name, char **argv, Options ops __attribute__((__unused__)), int func)
{
    char **s;
    Eprog prog;
    struct estate state;
    int nargs;



    if (func == 21) {
 for (s = argv; *s; s++);
 if (s == argv || strcmp(s[-1], "]")) {
     zwarnnam(name, "']' expected");
     return 1;
 }
 s[-1] = ((void *)0);
    }

    if (!*argv)
 return 1;






    nargs = arrlen(argv);
    if (nargs == 3 || nargs == 4)
    {
 if (*argv[0] == '(' && *argv[nargs-1] == ')') {
     argv[nargs-1] = ((void *)0);
     argv++;
 }
    }

    lexsave();
    testargs = argv;
    tok = NULLTOK;
    condlex = testlex;
    testlex();
    prog = parse_cond();
    condlex = zshlex;

    if (errflag) {
 errflag = 0;
 lexrestore();
 return 1;
    }

    if (!prog || tok == LEXERR) {
 zwarnnam(name, tokstr ? "parse error" : "argument expected");
 lexrestore();
 return 1;
    }
    lexrestore();

    if (*curtestarg) {
 zwarnnam(name, "too many arguments");
 return 1;
    }



    state.prog = prog;
    state.pc = prog->prog;
    state.strs = prog->strs;


    return evalcond(&state, name);
}
// # 5981 "builtin.c"
int
bin_times(char *name __attribute__((__unused__)), char **argv __attribute__((__unused__)), Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    struct tms buf;


    if (times(&buf) == -1)
 return 1;
    printf("%ldm%ld.%02lds",((long) (buf.tms_utime))/3600, ((long) (buf.tms_utime))/60%60,((long) (buf.tms_utime))*100/60%100);
    putchar(' ');
    printf("%ldm%ld.%02lds",((long) (buf.tms_stime))/3600, ((long) (buf.tms_stime))/60%60,((long) (buf.tms_stime))*100/60%100);
    putchar('\n');
    printf("%ldm%ld.%02lds",((long) (buf.tms_cutime))/3600, ((long) (buf.tms_cutime))/60%60,((long) (buf.tms_cutime))*100/60%100);
    putchar(' ');
    printf("%ldm%ld.%02lds",((long) (buf.tms_cstime))/3600, ((long) (buf.tms_cstime))/60%60,((long) (buf.tms_cstime))*100/60%100);
    putchar('\n');
    return 0;
}




int
bin_trap(char *name, char **argv, Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    Eprog prog;
    char *arg, *s;
    int sig;

    if (*argv && !strcmp(*argv, "--"))
 argv++;


    if (!*argv) {
 (queueing_enabled++);
 for (sig = 0; sig < (31 +3); sig++) {
     if (sigtrapped[sig] & (1<<2)) {
  HashNode hn;

  if ((hn = gettrapnode(sig, 0)))
      shfunctab->printnode(hn, 0);
  ;
     } else if (sigtrapped[sig]) {
  const char *name = getsigname(sig);
  if (!siglists[sig])
      printf("trap -- '' %s\n", name);
  else {
      s = getpermtext(siglists[sig], ((void *)0), 0);
      printf("trap -- ");
      quotedzputs(s, stdout);
      printf(" %s\n", name);
      zsfree(s);
  }
     }
 }
 do { ; if (!--queueing_enabled) do { while (queue_front != queue_rear) { sigset_t oset; queue_front = (queue_front + 1) % 128; oset = signal_setmask(signal_mask_queue[queue_front]); zhandler(signal_queue[queue_front]); signal_setmask(oset); } } while (0); } while (0);
 return 0;
    }



    if ((getsignum(*argv) != -1) || (!strcmp(*argv, "-") && argv++)) {
 if (!*argv) {
     for (sig = 0; sig < (31 +3); sig++)
  unsettrap(sig);
 } else {
     for (; *argv; argv++) {
  sig = getsignum(*argv);
  if (sig == -1) {
      zwarnnam(name, "undefined signal: %s", *argv);
      break;
  }
  unsettrap(sig);
     }
 }
 return *argv != ((void *)0);
    }


    arg = *argv++;
    if (!*arg)
 prog = &dummy_eprog;
    else if (!(prog = parse_string(arg, 1))) {
 zwarnnam(name, "couldn't parse trap command");
 return 1;
    }


    for (; *argv; argv++) {
 Eprog t;
 int flags;

 sig = getsignum(*argv);
 if (sig == -1) {
     zwarnnam(name, "undefined signal: %s", *argv);
     break;
 }
 if (!strcmp(sigs[sig], *argv))
     flags = 0;
 else {





     flags = (1<<3);
 }
 t = dupeprog(prog, 0);
 if (settrap(sig, t, flags))
     freeeprog(t);
    }
    return *argv != ((void *)0);
}


int
bin_ttyctl(char *name __attribute__((__unused__)), char **argv __attribute__((__unused__)), Options ops, int func __attribute__((__unused__)))
{
    if (((ops)->ind['f'] != 0))
 ttyfrozen = 1;
    else if (((ops)->ind['u'] != 0))
 ttyfrozen = 0;
    else
 printf("tty is %sfrozen\n", ttyfrozen ? "" : "not ");
    return 0;
}




int
bin_let(char *name __attribute__((__unused__)), char **argv, Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    mnumber val = zero_mnumber;

    while (*argv)
 val = matheval(*argv++);

    errflag = 0;

    return (val.type == 1) ? val.u.l == 0 : val.u.d == 0.0;
}







int
bin_umask(char *nam, char **args, Options ops, int func __attribute__((__unused__)))
{
    mode_t um;
    char *s = *args;


    um = umask(0);
    umask(um);

    if (!s) {
 if (((ops)->ind['S'] != 0)) {
     char *who = "ugo";

     while (*who) {
  char *what = "rwx";
  printf("%c=", *who++);
  while (*what) {
      if (!(um & 0400))
   putchar(*what);
      um <<= 1;
      what++;
  }
  putchar(*who ? ',' : '\n');
     }
 } else {
     if (um & 0700)
  putchar('0');
     printf("%03o\n", (unsigned)um);
 }
 return 0;
    }

    if ((typtab[((unsigned char)(*s))] & (1 << 0))) {

 um = zstrtol(s, &s, 8);
 if (*s) {
     zwarnnam(nam, "bad umask");
     return 1;
 }
    } else {

 int whomask, umaskop, mask;



 for (;;) {


     whomask = 0;
     while (*s == 'u' || *s == 'g' || *s == 'o' || *s == 'a')
  if (*s == 'u')
      s++, whomask |= 0700;
  else if (*s == 'g')
      s++, whomask |= 0070;
  else if (*s == 'o')
      s++, whomask |= 0007;
  else if (*s == 'a')
      s++, whomask |= 0777;

     if (!whomask)
  whomask = 0777;

     umaskop = (int)*s;
     if (!(umaskop == '+' || umaskop == '-' || umaskop == '=')) {
  if (umaskop)
      zwarnnam(nam, "bad symbolic mode operator: %c", umaskop);
  else
      zwarnnam(nam, "bad umask");
  return 1;
     }

     mask = 0;
     while (*++s && *s != ',')
  if (*s == 'r')
      mask |= 0444 & whomask;
  else if (*s == 'w')
      mask |= 0222 & whomask;
  else if (*s == 'x')
      mask |= 0111 & whomask;
  else {
      zwarnnam(nam, "bad symbolic mode permission: %c", *s);
      return 1;
  }

     if (umaskop == '+')
  um &= ~mask;
     else if (umaskop == '-')
  um |= mask;
     else
  um = (um | (whomask)) & ~mask;
     if (*s == ',')
  s++;
     else
  break;
 }
 if (*s) {
     zwarnnam(nam, "bad character in symbolic mode: %c", *s);
     return 1;
 }
    }


    umask(um);
    return 0;
}




 int
bin_notavail(char *nam, char **argv __attribute__((__unused__)), Options ops __attribute__((__unused__)), int func __attribute__((__unused__)))
{
    zwarnnam(nam, "not available on this system");
    return 1;
}
