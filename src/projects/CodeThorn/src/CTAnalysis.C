/*************************************************************
 * Author   : Markus Schordan                                *
 *************************************************************/

#include "sage3basic.h"
#include "Labeler.h"
#include "ClassHierarchyGraph.h"
#include "CTAnalysis.h"
#include "CodeThornCommandLineOptions.h"
#include "Miscellaneous.h"
#include "Miscellaneous2.h"
#include "AstUtility.h"
#include "SvcompWitness.h"
#include "CodeThornException.h"

#include <unordered_set>
#include <boost/bind.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/classification.hpp>

#include "TimeMeasurement.h"
#include "CollectionOperators.h"
#include "RersSpecialization.h"
#include "RERS_empty_specialization.h"
#include "CodeThornLib.h"
#include "TopologicalSort.h"

using namespace std;
using namespace Sawyer::Message;

Sawyer::Message::Facility CodeThorn::CTAnalysis::logger;

CodeThorn::CTAnalysis::CTAnalysis():
  _startFunRoot(0),
  //cfanalyzer(0),
  _globalTopifyMode(GTM_IO),
  _stgReducer(&estateSet, &transitionGraph),
  _counterexampleGenerator(&transitionGraph),
  _displayDiff(10000),
  _resourceLimitDiff(10000),
  _numberOfThreadsToUse(1),
  //  _solver(nullptr),
  _analyzerMode(AM_ALL_STATES),
  _maxTransitions(-1),
  _maxIterations(-1),
  _maxBytes(-1),
  _maxSeconds(-1),
  _maxTransitionsForcedTop(-1),
  _maxIterationsForcedTop(-1),
  _maxBytesForcedTop(-1),
  _maxSecondsForcedTop(-1),
  _treatStdErrLikeFailedAssert(false),
  _skipSelectedFunctionCalls(false),
  _explorationMode(EXPL_BREADTH_FIRST),
  _topifyModeActive(false),
  _iterations(0),
  _approximated_iterations(0),
  _curr_iteration_cnt(0),
  _next_iteration_cnt(0),
  _svCompFunctionSemantics(false),
  _contextSensitiveAnalysis(false)
{
  initDiagnostics();
  //variableIdMapping=new VariableIdMappingExtended();
  //variableIdMapping->setModeVariableIdForEachArrayElement(true);
  for(int i=0;i<100;i++) {
    binaryBindingAssert.push_back(false);
  }
  estateSet.max_load_factor(0.7);
  pstateSet.max_load_factor(0.7);
  constraintSetMaintainer.max_load_factor(0.7);
  resetInputSequenceIterator();
  exprAnalyzer.setAnalyzer(this);
  ROSE_ASSERT(_estateTransferFunctions==nullptr);
  _estateTransferFunctions=new EStateTransferFunctions();
  _estateTransferFunctions->setAnalyzer(this);
}

// override
void CodeThorn::CTAnalysis::initializeSolver() {
  EStateTransferFunctions* etf=new EStateTransferFunctions();
  etf->setAnalyzer(this);
  _transferFunctions=etf;
}

// override
void CodeThorn::CTAnalysis::run() {
  runSolver();
}

// override
void CodeThorn::CTAnalysis::initializeAnalyzerDataInfo() {
  // will be changed for added context
  SAWYER_MESG(logger[INFO])<<"INFO: CTAnalysis::initializeAnalyzerDataInfo (empty)."<<endl;
}

#if 0
Lattice* CodeThorn::CTAnalysis::getPreInfo(Label lab) {
  // will be changed for added context
  ROSE_ASSERT(false);
}
Lattice* CodeThorn::CTAnalysis::getPostInfo(Label lab) {
  // will be changed for added context
  ROSE_ASSERT(false);
}

void CodeThorn::CTAnalysis::setPostInfo(Label lab,Lattice*) {
  // will be changed for added context
  ROSE_ASSERT(false);

}
#endif

void CodeThorn::CTAnalysis::insertInputVarValue(int i) {
  _inputVarValues.insert(i);
}

std::set<int> CodeThorn::CTAnalysis::getInputVarValues() {
  return _inputVarValues;
}

// also sets inputvarvalues
void CodeThorn::CTAnalysis::setLtlRersMapping(CodeThorn::LtlRersMapping m) {
  _ltlRersMapping=m;
}
CodeThorn::LtlRersMapping CodeThorn::CTAnalysis::getLtlRersMapping() {
  return _ltlRersMapping;
}

void CodeThorn::CTAnalysis::deleteWorkLists() {
  if(estateWorkListCurrent) {
    delete estateWorkListCurrent;
  }
  if(estateWorkListNext) {
    delete estateWorkListNext;
  }
}

void CodeThorn::CTAnalysis::setWorkLists(ExplorationMode explorationMode) {
  deleteWorkLists();
  switch(_explorationMode) {
  case EXPL_UNDEFINED:
    cerr<<"Error: undefined exploration mode in constructing of CTAnalysis."<<endl;
    exit(1);
  case EXPL_DEPTH_FIRST:
  case EXPL_BREADTH_FIRST:
  case EXPL_LOOP_AWARE:
  case EXPL_LOOP_AWARE_SYNC:
  case EXPL_RANDOM_MODE1:
    estateWorkListCurrent=new EStateWorkList();
    estateWorkListNext=new EStateWorkList();
    break;
  case EXPL_TOPOLOGIC_SORT: {
    ROSE_ASSERT(getLabeler());
    if(getFlow()->getStartLabelSet().size()>0) {
      TopologicalSort topSort(*getLabeler(),*getFlow());
      std::list<Label> labelList=topSort.topologicallySortedLabelList();
#if 0
      cout<<"Topologic Sort:";
      for(auto label : labelList) {
        cout<<label.toString()<<" ";
      }
      cout<<endl;
#endif
      TopologicalSort::LabelToPriorityMap map=topSort.labelToPriorityMap();
      ROSE_ASSERT(map.size()>0);
      estateWorkListCurrent = new EStatePriorityWorkList(map);
      estateWorkListNext = new EStatePriorityWorkList(map); // only used in loop aware mode
      SAWYER_MESG(logger[INFO])<<"STATUS: using topologic worklist."<<endl;
      break;
    } else {
      // for empty flow initialize with empty workslists
      TopologicalSort::LabelToPriorityMap map;
      estateWorkListCurrent = new EStatePriorityWorkList(map);
      estateWorkListNext = new EStatePriorityWorkList(map); // only used in loop aware mode
      SAWYER_MESG(logger[INFO])<<"STATUS: using empty topologic worklist (because of empty control flow graph)."<<endl;
    }
  }
  } // end switch
}

void CodeThorn::CTAnalysis::setExplorationMode(ExplorationMode em) {
  _explorationMode=em;
}

ExplorationMode CodeThorn::CTAnalysis::getExplorationMode() {
  return _explorationMode;
}

CodeThorn::CTAnalysis::~CTAnalysis() {
  if(_estateTransferFunctions)
    delete _estateTransferFunctions;
  deleteWorkLists();
}

CodeThorn::CTAnalysis::SubSolverResultType CodeThorn::CTAnalysis::subSolver(const CodeThorn::EState* currentEStatePtr) {
  // start the timer if not yet done
  startAnalysisTimer();

  // first, check size of global EStateSet and print status or switch to topify/terminate analysis accordingly.
  unsigned long estateSetSize;
  bool earlyTermination = false;
  int threadNum = 0; //subSolver currently does not support multiple threads.
  // print status message if required
  if (_ctOpt.status && _displayDiff) {
#pragma omp critical(HASHSET)
    {
      estateSetSize = estateSet.size();
    }
    if(threadNum==0 && (estateSetSize>(_prevStateSetSizeDisplay+_displayDiff))) {
      printStatusMessage(true);
      _prevStateSetSizeDisplay=estateSetSize;
    }
  }
  // switch to topify mode or terminate analysis if resource limits are exceeded
  if (_maxBytes != -1 || _maxBytesForcedTop != -1 || _maxSeconds != -1 || _maxSecondsForcedTop != -1
      || _maxTransitions != -1 || _maxTransitionsForcedTop != -1 || _maxIterations != -1 || _maxIterationsForcedTop != -1) {
#pragma omp critical(HASHSET)
    {
      estateSetSize = estateSet.size();
    }
    if(threadNum==0 && _resourceLimitDiff && (estateSetSize>(_prevStateSetSizeResource+_resourceLimitDiff))) {
      if (isIncompleteSTGReady()) {
#pragma omp critical(ESTATEWL)
        {
          earlyTermination = true;
        }
      }
      isActiveGlobalTopify(); // Checks if a switch to topify is necessary. If yes, it changes the analyzer state.
      _prevStateSetSizeResource=estateSetSize;
    }
  }
  EStateWorkList deferedWorkList;
  std::set<const EState*> existingEStateSet;
  if (earlyTermination) {
    if(_ctOpt.status) {
      cout << "STATUS: Early termination within subSolver (resource limit reached)." << endl;
    }
    transitionGraph.setForceQuitExploration(true);
  } else {
    // run the actual sub-solver
    EStateWorkList localWorkList;
    localWorkList.push_back(currentEStatePtr);
    while(!localWorkList.empty()) {
      // logger[DEBUG]<<"local work list size: "<<localWorkList.size()<<endl;
      const EState* currentEStatePtr=localWorkList.front();
      localWorkList.pop_front();
      if(isFailedAssertEState(currentEStatePtr)) {
        // ensure we do not compute any successors of a failed assert state
        continue;
      }
      Flow edgeSet=getFlow()->outEdges(currentEStatePtr->label());
      for(Flow::iterator i=edgeSet.begin();i!=edgeSet.end();++i) {
        Edge e=*i;
        list<EState> newEStateList;
        newEStateList=transferEdgeEState(e,currentEStatePtr);
        for(list<EState>::iterator nesListIter=newEStateList.begin();
            nesListIter!=newEStateList.end();
            ++nesListIter) {
          // newEstate is passed by value (not created yet)
          EState newEState=*nesListIter;
          ROSE_ASSERT(newEState.label()!=Labeler::NO_LABEL);

          if((!newEState.constraints()->disequalityExists()) &&(!isFailedAssertEState(&newEState)&&!isVerificationErrorEState(&newEState))) {
            HSetMaintainer<EState,EStateHashFun,EStateEqualToPred>::ProcessingResult pres=process(newEState);
            const EState* newEStatePtr=pres.second;
            ROSE_ASSERT(newEStatePtr);
            if(pres.first==true) {
              if(isLTLRelevantEState(newEStatePtr)) {
                deferedWorkList.push_back(newEStatePtr);
              } else {
                localWorkList.push_back(newEStatePtr);
              }
            } else {
              // we have found an existing state, but need to make also sure it's a relevent one
              if(isLTLRelevantEState(newEStatePtr)) {
                ROSE_ASSERT(newEStatePtr!=nullptr);
                existingEStateSet.insert(const_cast<EState*>(newEStatePtr));
              } else {
                // TODO: use a unique list
                localWorkList.push_back(newEStatePtr);
              }
            }
            // TODO: create reduced transition set at end of this function
            if(!getModeLTLDriven()) {
              recordTransition(currentEStatePtr,e,newEStatePtr);
            }
          }
          if((!newEState.constraints()->disequalityExists()) && ((isFailedAssertEState(&newEState))||isVerificationErrorEState(&newEState))) {
            // failed-assert end-state: do not add to work list but do add it to the transition graph
            const EState* newEStatePtr;
            newEStatePtr=processNewOrExisting(newEState);
            // TODO: create reduced transition set at end of this function
            if(!getModeLTLDriven()) {
              recordTransition(currentEStatePtr,e,newEStatePtr);
            }
            deferedWorkList.push_back(newEStatePtr);
            if(isVerificationErrorEState(&newEState)) {
              SAWYER_MESG(logger[TRACE])<<"STATUS: detected verification error state ... terminating early"<<endl;
              // set flag for terminating early
              reachabilityResults.reachable(0);
              _firstAssertionOccurences.push_back(pair<int, const EState*>(0, newEStatePtr));
              EStateWorkList emptyWorkList;
              EStatePtrSet emptyExistingStateSet;
              return make_pair(emptyWorkList,emptyExistingStateSet);
            } else if(isFailedAssertEState(&newEState)) {
              // record failed assert
              int assertCode;
              if(_ctOpt.rers.rersBinary) {
                assertCode=reachabilityAssertCode(newEStatePtr);
              } else {
                assertCode=reachabilityAssertCode(currentEStatePtr);
              }
              /* if a property table is created for reachability we can also
                 collect on the fly reachability results in LTL-driven mode
                 but for now, we don't
              */
              if(!getModeLTLDriven()) {
                if(assertCode>=0) {
                  if(_ltlOpt.withCounterExamples || _ltlOpt.withAssertCounterExamples) {
                    //if this particular assertion was never reached before, compute and update counterexample
                    if (reachabilityResults.getPropertyValue(assertCode) != PROPERTY_VALUE_YES) {
                      _firstAssertionOccurences.push_back(pair<int, const EState*>(assertCode, newEStatePtr));
                    }
                  }
                  reachabilityResults.reachable(assertCode);
                }	    // record failed assert
              }
            } // end of failed assert handling
          } // end of if (no disequality (= no infeasable path))
        } // end of loop on transfer function return-estates
      } // edge set iterator
    }
  }
  return make_pair(deferedWorkList,existingEStateSet);
}

std::string CodeThorn::CTAnalysis::programPositionInfo(CodeThorn::Label lab) {
  SgNode* node=getLabeler()->getNode(lab);
  return SgNodeHelper::lineColumnNodeToString(node);
}

bool CodeThorn::CTAnalysis::isApproximatedBy(const EState* es1, const EState* es2) {
  return es1->isApproximatedBy(es2);
}

void CodeThorn::CTAnalysis::setOptionOutputWarnings(bool flag) {
  exprAnalyzer.setOptionOutputWarnings(flag);
}
bool CodeThorn::CTAnalysis::getOptionOutputWarnings() {
  return exprAnalyzer.getOptionOutputWarnings();
}

EState CodeThorn::CTAnalysis::combine(const EState* es1, const EState* es2) {
  ROSE_ASSERT(es1->label()==es2->label());
  ROSE_ASSERT(es1->constraints()==es2->constraints()); // pointer equality
  if(es1->callString!=es2->callString) {
    if(getOptionOutputWarnings()) {
      SAWYER_MESG(logger[WARN])<<"combining estates with different callstrings at label:"<<es1->label().toString()<<endl;
      SAWYER_MESG(logger[WARN])<<"cs1: "<<es1->callString.toString()<<endl;
      SAWYER_MESG(logger[WARN])<<"cs2: "<<es2->callString.toString()<<endl;
    }
  }
  PState ps1=*es1->pstate();
  PState ps2=*es2->pstate();

  InputOutput io;
  if(es1->io.isBot()) {
    io=es2->io;
  } else if(es2->io.isBot()) {
    io=es1->io;
  } else {
    ROSE_ASSERT(es1->io==es2->io);
    io=es1->io;
  }

  return createEState(es1->label(),es1->callString,PState::combine(ps1,ps2),*es1->constraints(),io);
}

size_t CodeThorn::CTAnalysis::getSummaryStateMapSize() {
  return _summaryCSStateMap.size();
}

Lattice* CodeThorn::CTAnalysis::getPreInfo(Label lab, CallString context) {
  return const_cast<EState*>(getSummaryState(lab,context));
}

Lattice* CodeThorn::CTAnalysis::getPostInfo(Label lab, CallString context) {
  ROSE_ASSERT(0);
}

void CodeThorn::CTAnalysis::setPreInfo(Label lab, CallString context, Lattice* el) {
  setSummaryState(lab,context,dynamic_cast<CodeThorn::EState const*>(el));
}

void CodeThorn::CTAnalysis::setPostInfo(Label lab, CallString context, Lattice*) {
  ROSE_ASSERT(0);
}

const CodeThorn::EState* CodeThorn::CTAnalysis::getSummaryState(CodeThorn::Label lab, CodeThorn::CallString cs) {
  // cs not used yet
  //return _summaryStateMap[lab.getId()];
  pair<int,CallString> p(lab.getId(),cs);
  auto iter=_summaryCSStateMap.find(p);
  if(iter==_summaryCSStateMap.end()) {
    return getBottomSummaryState(lab,cs);
  } else {
    return (*iter).second;
  }
}

void CodeThorn::CTAnalysis::setSummaryState(CodeThorn::Label lab, CodeThorn::CallString cs, CodeThorn::EState const* estate) {
  ROSE_ASSERT(lab==estate->label());
  ROSE_ASSERT(cs==estate->callString);
  ROSE_ASSERT(estate);
  pair<int,CallString> p(lab.getId(),cs);
  _summaryCSStateMap[p]=estate;
}


const EState* CodeThorn::CTAnalysis::getBottomSummaryState(Label lab, CallString cs) {
  InputOutput io;
  io.recordBot();
  ROSE_ASSERT(_initialPStateStored);
  ROSE_ASSERT(_emptycsetstored);
  EState estate(lab,cs,_initialPStateStored,_emptycsetstored,io);
  const EState* bottomElement=processNewOrExisting(estate);
  return bottomElement;
}

void CodeThorn::CTAnalysis::initializeSummaryStates(const CodeThorn::PState* initialPStateStored,
                                                  const CodeThorn::ConstraintSet* emptycsetstored) {
  _initialPStateStored=initialPStateStored;
  _emptycsetstored=emptycsetstored;
#if 0
  for(auto label:*getLabeler()) {
    // create bottom elements for each label
    InputOutput io;
    io.recordBot();
    CallString cs; // empty callstring
    EState estate(label,cs,initialPStateStored,emptycsetstored,io); // implicitly empty cs
    const EState* bottomElement=processNewOrExisting(getBottomSummaryState());
    setSummaryState(label,estate.callString,bottomElement);
  }
#endif
}

bool CodeThorn::CTAnalysis::getPrintDetectedViolations() {
  return exprAnalyzer.getPrintDetectedViolations();
}

void CodeThorn::CTAnalysis::setPrintDetectedViolations(bool flag) {
  exprAnalyzer.setPrintDetectedViolations(flag);
}

void CodeThorn::CTAnalysis::setIgnoreFunctionPointers(bool skip) {
  exprAnalyzer.setIgnoreFunctionPointers(skip);
}

bool CodeThorn::CTAnalysis::getIgnoreFunctionPointers() {
  return exprAnalyzer.getIgnoreFunctionPointers();
}

void CodeThorn::CTAnalysis::setInterpreterMode(CodeThorn::InterpreterMode mode) {
  exprAnalyzer.setInterpreterMode(mode);
}

CodeThorn::InterpreterMode CodeThorn::CTAnalysis::getInterpreterMode() {
  return exprAnalyzer.getInterpreterMode();
}

void CodeThorn::CTAnalysis::setInterpreterModeOutputFileName(string fileName) {
  exprAnalyzer.setInterpreterModeFileName(fileName);
}

string CodeThorn::CTAnalysis::getInterpreterModeOutputFileName() {
  return exprAnalyzer.getInterpreterModeFileName();
}

void CodeThorn::CTAnalysis::setOptionContextSensitiveAnalysis(bool flag) {
  _contextSensitiveAnalysis=flag;
}

bool CodeThorn::CTAnalysis::getOptionContextSensitiveAnalysis() {
  return _contextSensitiveAnalysis;
}

void CodeThorn::CTAnalysis::printStatusMessage(string s, bool newLineFlag) {
#pragma omp critical (STATUS_MESSAGES)
  {
    if(_ctOpt.status) {
      cout<<s;
      if(newLineFlag) {
        cout<<endl; // status output
      }
    }
  }
}

void CodeThorn::CTAnalysis::printStatusMessage(string s) {
  printStatusMessage(s,false);
}

void CodeThorn::CTAnalysis::printStatusMessageLine(string s) {
  printStatusMessage(s,true);
}

void CodeThorn::CTAnalysis::initDiagnostics() {
  static bool initialized = false;
  if (!initialized) {
    initialized = true;
    logger = Sawyer::Message::Facility("CodeThorn::CTAnalysis", Rose::Diagnostics::destination);
    Rose::Diagnostics::mfacilities.insertAndAdjust(logger);
  }
}

void CodeThorn::CTAnalysis::enableSVCompFunctionSemantics() {
  _svCompFunctionSemantics=true;
  exprAnalyzer.setSVCompFunctionSemantics(true);
  _externalErrorFunctionName="__VERIFIER_error";
  _externalNonDetIntFunctionName="__VERIFIER_nondet_int";
  _externalNonDetLongFunctionName="__VERIFIER_nondet_long";
  _externalExitFunctionName="exit";
}

void CodeThorn::CTAnalysis::disableSVCompFunctionSemantics() {
  _svCompFunctionSemantics=false;
  exprAnalyzer.setSVCompFunctionSemantics(false);
  _externalErrorFunctionName="";
  _externalNonDetIntFunctionName="";
  _externalNonDetLongFunctionName="";
  _externalExitFunctionName="";
  ROSE_ASSERT(getLabeler());
  getLabeler()->setExternalNonDetIntFunctionName(_externalNonDetIntFunctionName);
  getLabeler()->setExternalNonDetLongFunctionName(_externalNonDetLongFunctionName);
}

bool CodeThorn::CTAnalysis::svCompFunctionSemantics() { return _svCompFunctionSemantics; }
bool CodeThorn::CTAnalysis::getStdFunctionSemantics() { return exprAnalyzer.getStdFunctionSemantics(); }
void CodeThorn::CTAnalysis::setStdFunctionSemantics(bool flag) { exprAnalyzer.setStdFunctionSemantics(flag); }

// TODO: move to flow analyzer (reports label,init,final sets)
string CodeThorn::CTAnalysis::astNodeInfoAttributeAndNodeToString(SgNode* node) {
  string textual;
  if(node->attributeExists("info"))
    textual=node->getAttribute("info")->toString()+":";
  return textual+SgNodeHelper::nodeToString(node);
}

bool CodeThorn::CTAnalysis::isFunctionCallWithAssignment(Label lab,VariableId* varIdPtr){
  //return _labeler->isFunctionCallWithAssignment(lab,varIdPtr);
  SgNode* node=getLabeler()->getNode(lab);
  if(getLabeler()->isFunctionCallLabel(lab)) {
    std::pair<SgVarRefExp*,SgFunctionCallExp*> p=SgNodeHelper::Pattern::matchExprStmtAssignOpVarRefExpFunctionCallExp2(node);
    if(p.first) {
      if(varIdPtr) {
        *varIdPtr=getVariableIdMapping()->variableId(p.first);
      }
      return true;
    }
  }
  return false;
}

void CodeThorn::CTAnalysis::writeWitnessToFile(string filename) {
  _counterexampleGenerator.setType(CounterexampleGenerator::TRACE_TYPE_SVCOMP_WITNESS);
  ROSE_ASSERT(_firstAssertionOccurences.size() == 1); //SV-COMP: Expecting exactly one reachability property
  list<pair<int, const EState*> >::iterator iter = _firstAssertionOccurences.begin();
  ExecutionTrace* trace =
    _counterexampleGenerator.traceLeadingTo((*iter).second);
  if(SvcompWitness* witness = dynamic_cast<SvcompWitness*>(trace)) {
    witness->writeErrorAutomatonToFile(filename);
    delete witness;
    witness = nullptr;
  } else {
    throw CodeThorn::Exception("Downcast to SvcompWitness unsuccessful.");
  }
}


size_t CodeThorn::CTAnalysis::getNumberOfErrorLabels() {
  return _assertNodes.size();
}

string CodeThorn::CTAnalysis::labelNameOfAssertLabel(Label lab) {
  string labelName;
  for(list<pair<SgLabelStatement*,SgNode*> >::iterator i=_assertNodes.begin();i!=_assertNodes.end();++i)
    if(lab==getLabeler()->getLabel((*i).second))
      labelName=SgNodeHelper::getLabelName((*i).first);
  //assert(labelName.size()>0);
  return labelName;
}

bool CodeThorn::CTAnalysis::isCppLabeledAssertLabel(Label lab) {
  return labelNameOfAssertLabel(lab).size()>0;
}


void CodeThorn::CTAnalysis::setGlobalTopifyMode(GlobalTopifyMode mode) {
  _globalTopifyMode=mode;
}

void CodeThorn::CTAnalysis::setExternalErrorFunctionName(std::string externalErrorFunctionName) {
  _externalErrorFunctionName=externalErrorFunctionName;
}

bool CodeThorn::CTAnalysis::isPrecise() {
  // MS 05/20/20: removed (eliminated explicitArrays mode)
  //if (_ctOpt.arraysNotInState==true && !_ctOpt.rers.rersBinary) {
  //  return false;
  //}
  // analysis is precise if it is not in any abstraction mode
  return !(isActiveGlobalTopify()||_ctOpt.abstractionMode>0);
}

// only relevant for maximum values (independent of topify mode)
bool CodeThorn::CTAnalysis::isIncompleteSTGReady() {
  if(_maxTransitions==-1 && _maxIterations==-1 && _maxBytes==-1 && _maxSeconds==-1)
    return false;
  if ((_maxTransitions!=-1) && ((long int) transitionGraph.size()>=_maxTransitions))
    return true;
  if ((_maxIterations!=-1) && ((long int) getIterations() > _maxIterations))
    return true;
  if ((_maxBytes!=-1) && ((long int) getPhysicalMemorySize() > _maxBytes))
    return true;
  if ((_maxSeconds!=-1) && ((long int) analysisRunTimeInSeconds() > _maxSeconds)) {
    return true;
  }
  // at least one maximum mode is active, but the corresponding limit has not yet been reached
  return false;
}

CodeThorn::ExprAnalyzer* CodeThorn::CTAnalysis::getExprAnalyzer() {
  return &exprAnalyzer;
}

void CodeThorn::CTAnalysis::setSolver(Solver* solver) {
  _solver=solver;
  solver->setAnalyzer(this);
}

Solver* CodeThorn::CTAnalysis::getSolver() {
  CodeThorn::Solver* ctSolver=dynamic_cast<CodeThorn::Solver*>(_solver);
  ROSE_ASSERT(ctSolver);
  return ctSolver;
}

void CodeThorn::CTAnalysis::runSolver() {
  startAnalysisTimer();
  CodeThorn::Solver* ctSolver=dynamic_cast<CodeThorn::Solver*>(_solver);
  ROSE_ASSERT(ctSolver);
  //_solver->run();
  ctSolver->run();
  stopAnalysisTimer();
}

set<string> CodeThorn::CTAnalysis::variableIdsToVariableNames(CodeThorn::VariableIdSet s) {
  set<string> res;
  for(CodeThorn::VariableIdSet::iterator i=s.begin();i!=s.end();++i) {
    res.insert((AbstractValue(*i)).toString(getVariableIdMapping()));
  }
  return res;
}

CodeThorn::CTAnalysis::VariableDeclarationList CodeThorn::CTAnalysis::computeUnusedGlobalVariableDeclarationList(SgProject* root) {
  list<SgVariableDeclaration*> globalVars=SgNodeHelper::listOfGlobalVars(root);
  CodeThorn::CTAnalysis::VariableDeclarationList usedGlobalVars=computeUsedGlobalVariableDeclarationList(root);
  for(CodeThorn::CTAnalysis::VariableDeclarationList::iterator i=usedGlobalVars.begin();i!=usedGlobalVars.end();++i) {
    globalVars.remove(*i);
  }
  return globalVars;
}

#define DO_NOT_FILTER_VARS
CodeThorn::CTAnalysis::VariableDeclarationList CodeThorn::CTAnalysis::computeUsedGlobalVariableDeclarationList(SgProject* root) {
  if(SgProject* project=isSgProject(root)) {
    CodeThorn::CTAnalysis::VariableDeclarationList usedGlobalVariableDeclarationList;
    list<SgVariableDeclaration*> globalVars=SgNodeHelper::listOfGlobalVars(project);
#ifdef DO_NOT_FILTER_VARS
    VariableIdSet setOfUsedVars=AstUtility::usedVariablesInsideFunctions(project,getVariableIdMapping());
#endif
    int filteredVars=0;
    for(list<SgVariableDeclaration*>::iterator i=globalVars.begin();i!=globalVars.end();++i) {
      VariableId globalVarId=getVariableIdMapping()->variableId(*i);
      // do not filter
      usedGlobalVariableDeclarationList.push_back(*i);
#ifdef DO_NOT_FILTER_VARS
      if(true || setOfUsedVars.find(globalVarId)!=setOfUsedVars.end()) {
        usedGlobalVariableDeclarationList.push_back(*i);
      } else {
        filteredVars++;
      }
#else
      if(setOfUsedVars.find(globalVarId)!=setOfUsedVars.end()) {
        usedGlobalVariableDeclarationList.push_back(*i);
      } else {
        filteredVars++;
      }
#endif
    }
    return usedGlobalVariableDeclarationList;
  } else {
    SAWYER_MESG(logger[ERROR]) << "no global scope.";
    exit(1);
  }
}

void CodeThorn::CTAnalysis::setStgTraceFileName(string filename) {
  _stg_trace_filename=filename;
  ofstream fout;
  fout.open(_stg_trace_filename.c_str());    // create new file/overwrite existing file
  fout<<"START"<<endl;
  fout.close();    // close. Will be used with append.
}

void CodeThorn::CTAnalysis::recordTransition(const EState* sourceState, Edge e, const EState* targetState) {
  transitionGraph.add(Transition(sourceState,e,targetState));
}

void CodeThorn::CTAnalysis::printStatusMessage(bool forceDisplay) {
  // forceDisplay currently only turns on or off

  // report we are alive
  stringstream ss;
  if(forceDisplay) {
    long pstateSetSize;
    long estateSetSize;
    long transitionGraphSize;
    long constraintSetMaintainerSize;
    long estateWorkListCurrentSize;
#pragma omp critical(HASHSET)
    {
      pstateSetSize = pstateSet.size();
      estateSetSize = estateSet.size();
      transitionGraphSize = getTransitionGraph()->size();
      constraintSetMaintainerSize = constraintSetMaintainer.size();
    }
#pragma omp critical(ESTATEWL)
    {
      estateWorkListCurrentSize = estateWorkListCurrent->size();
    }
    ss <<color("white")<<"Number of pstates/estates/trans/c/wl/iter/time/mem: ";
    ss <<color("magenta")<<pstateSetSize
       <<color("white")<<"/"
       <<color("cyan")<<estateSetSize
       <<color("white")<<"/"
       <<color("blue")<<transitionGraphSize
       <<color("white")<<"/"
       <<color("yellow")<<constraintSetMaintainerSize
       <<color("white")<<"/"
       <<estateWorkListCurrentSize
       <<"/"<<getIterations()<<"-"<<getApproximatedIterations()
       <<"/"<<analysisRunTimeInSeconds()<<"<"<<(_maxSeconds!=-1?std::to_string(_maxSeconds)+"s"     :"inf")
       <<"/"<<getPhysicalMemorySize()/(1024*1024) <<"<"<<(_maxBytes  !=-1?std::to_string(_maxBytes/(1024*1024))  +" MiB":"inf")
       <<"/"<<color("normal")<<analyzerStateToString()
       <<endl
    ;
    printStatusMessage(ss.str());
  }
}

string CodeThorn::CTAnalysis::analyzerStateToString() {
  stringstream ss;
  ss<<"[P:"<<isPrecise();
  ss<<" ";
  ss<<"T:"<<_globalTopifyMode;
  ss<<" ";
  ss<<"B:"<<_ctOpt.rers.rersBinary;
  ss<<" ";
  ss<<"R:"<<isIncompleteSTGReady();
  ss<<"]";
  return ss.str();
}

void CodeThorn::CTAnalysis::incIterations() {
  if(isPrecise()) {
#pragma omp atomic
    _iterations+=1;
  } else {
#pragma omp atomic
    _approximated_iterations+=1;
  }
}

bool CodeThorn::CTAnalysis::isLoopCondLabel(Label lab) {
  SgNode* node=getLabeler()->getNode(lab);
  return SgNodeHelper::isLoopCond(node);
}

void CodeThorn::CTAnalysis::addToWorkList(const EState* estate) {
  ROSE_ASSERT(estate);
  ROSE_ASSERT(estateWorkListCurrent);
#pragma omp critical(ESTATEWL)
  {
    if(!estate) {
      SAWYER_MESG(logger[ERROR])<<"INTERNAL: null pointer added to work list."<<endl;
      exit(1);
    }
    switch(_explorationMode) {
    case EXPL_UNDEFINED:
      cerr<<"Error: undefined state exploration mode. Bailing out."<<endl;
      exit(1);
    case EXPL_DEPTH_FIRST: estateWorkListCurrent->push_front(estate);break;
    case EXPL_BREADTH_FIRST: estateWorkListCurrent->push_back(estate);break;
    case EXPL_RANDOM_MODE1: {
      int perc=4; // 25%-chance depth-first
      int num=rand();
      int sel=num%perc;
      if(sel==0) {
        estateWorkListCurrent->push_front(estate);
      } else {
        estateWorkListCurrent->push_back(estate);
      }
      break;
    }
    case EXPL_LOOP_AWARE: {
      if(isLoopCondLabel(estate->label())) {
        estateWorkListCurrent->push_back(estate);
        // logger[DEBUG] << "push to WorkList: "<<_curr_iteration_cnt<<","<<_next_iteration_cnt<<":"<<_iterations<<endl;
        _next_iteration_cnt++;
      } else {
        estateWorkListCurrent->push_front(estate);
      }
      break;
    }
    case EXPL_LOOP_AWARE_SYNC: {
      if(isLoopCondLabel(estate->label())) {
        estateWorkListNext->push_back(estate);
      } else {
        estateWorkListCurrent->push_back(estate);
      }
      break;
    }
    case EXPL_TOPOLOGIC_SORT:
      // must be estatePriorityWorkList
      ROSE_ASSERT(dynamic_cast<EStatePriorityWorkList*>(estateWorkListCurrent));
      estateWorkListCurrent->push_front(estate);
      break;
    default:
      SAWYER_MESG(logger[ERROR])<<"unknown exploration mode."<<endl;
      exit(1);
    }
  }
}

bool CodeThorn::CTAnalysis::isActiveGlobalTopify() {
  if(_maxTransitionsForcedTop==-1 && _maxIterationsForcedTop==-1 && _maxBytesForcedTop==-1 && _maxSecondsForcedTop==-1)
    return false;
  if(_topifyModeActive)
    return true;
  // TODO: add a critical section that guards "transitionGraph.size()"
  if( (_maxTransitionsForcedTop!=-1 && (long int)transitionGraph.size()>=_maxTransitionsForcedTop)
      || (_maxIterationsForcedTop!=-1 && getIterations() > _maxIterationsForcedTop)
      || (_maxBytesForcedTop!=-1 && getPhysicalMemorySize() > _maxBytesForcedTop)
      || (_maxSecondsForcedTop!=-1 && analysisRunTimeInSeconds() > _maxSecondsForcedTop) ) {
#pragma omp critical(ACTIVATE_TOPIFY_MODE)
    {
      if (!_topifyModeActive) {
        _topifyModeActive=true;
        eventGlobalTopifyTurnedOn();
        _ctOpt.rers.rersBinary=false;
      }
    }
    return true;
  }
  return false;
}

void CodeThorn::CTAnalysis::eventGlobalTopifyTurnedOn() {
  stringstream ss;
  ss << "STATUS: mode global-topify activated:"<<endl
     << "Transitions  : "<<(long int)transitionGraph.size()<<","<<_maxTransitionsForcedTop<<endl
     << "Iterations   : "<<getIterations()<<":"<< _maxIterationsForcedTop<<endl
     << "Memory(bytes): "<<getPhysicalMemorySize()<<":"<< _maxBytesForcedTop<<endl
     << "Runtime(s)   : "<<analysisRunTimeInSeconds() <<":"<< _maxSecondsForcedTop<<endl;
  printStatusMessage(ss.str());

  AbstractValueSet vset=variableValueMonitor.getVariables();
  int n=0;
  int nt=0;
  for(AbstractValueSet::iterator i=vset.begin();i!=vset.end();++i) {
    string name=(*i).toLhsString(getVariableIdMapping());
    bool isCompoundIncVar=(_compoundIncVarsSet.find(*i)!=_compoundIncVarsSet.end());
    bool isSmallActivityVar=(_smallActivityVarsSet.find(*i)!=_smallActivityVarsSet.end());
    bool isAssertCondVar=(_assertCondVarsSet.find(*i)!=_assertCondVarsSet.end());
    bool topifyVar=false;
    switch(_globalTopifyMode) {
    case GTM_IO:
      if(name!="input" && name!="output") {
        topifyVar=true;
      }
      break;
    case GTM_IOCF:
      if(name!="input" && name!="output" && name!="cf") {
        topifyVar=true;
      }
      break;
    case GTM_IOCFPTR:
      if(name!="input" && name!="output" && name!="cf" && !(*i).isPtr()) {
        topifyVar=true;
      }
      break;
    case GTM_COMPOUNDASSIGN:
      if(isCompoundIncVar) {
        topifyVar=true;
      }
      break;
    case GTM_FLAGS: {
      if(name=="input" || name=="output" || name=="cf") {
        topifyVar=false;
        break;
      }
      if(isCompoundIncVar) {
        topifyVar=true;
        break;
      }
      if(!isAssertCondVar) {
        topifyVar=true;
        break;
      }
      if(!isSmallActivityVar) {
        topifyVar=true;
        break;
      }
      topifyVar=false;
      break;
    }
    default:
      logger[ERROR]<<"unsupported topify mode selected. Bailing out."<<endl;
      exit(1);
    }

    if(topifyVar) {
      variableValueMonitor.setVariableMode(VariableValueMonitor::VARMODE_FORCED_TOP,*i);
      n++;
    }
    nt++;
  }

  if(_ctOpt.status) {
    cout << "switched to static analysis (approximating "<<n<<" of "<<nt<<" variables with top-conversion)."<<endl;
  }
  //switch to the counter for approximated loop iterations if currently in a mode that counts iterations
  if (getExplorationMode()==EXPL_LOOP_AWARE || getExplorationMode()==EXPL_LOOP_AWARE_SYNC) {
#pragma omp atomic
    _iterations--;
#pragma omp atomic
    _approximated_iterations++;
  }
}

void CodeThorn::CTAnalysis::topifyVariable(PState& pstate, ConstraintSet& cset, AbstractValue varId) {
  pstate.writeTopToMemoryLocation(varId);
}

// does not use a context
EState CodeThorn::CTAnalysis::createEStateInternal(Label label, PState pstate, ConstraintSet cset) {
  // here is the best location to adapt the analysis results to certain global restrictions
  if(isActiveGlobalTopify()) {
#if 1
    AbstractValueSet varSet=pstate.getVariableIds();
    for(AbstractValueSet::iterator i=varSet.begin();i!=varSet.end();++i) {
      if(variableValueMonitor.isHotVariable(this,*i)) {
        //ROSE_ASSERT(false); // this branch is live
        topifyVariable(pstate, cset, *i);
      }
    }
#else
    //pstate.topifyState();
#endif
    // set cset in general to empty cset, otherwise cset can grow again arbitrarily
    ConstraintSet cset0;
    cset=cset0;
  }
  const PState* newPStatePtr=processNewOrExisting(pstate);
  const ConstraintSet* newConstraintSetPtr=processNewOrExisting(cset);
  EState estate=EState(label,newPStatePtr,newConstraintSetPtr);
  estate.io.recordNone();
  return estate;
}

EState CodeThorn::CTAnalysis::createEState(Label label, CallString cs, PState pstate, ConstraintSet cset) {
  EState estate=createEStateInternal(label,pstate,cset);
  estate.callString=cs;
  estate.io.recordNone(); // create NONE not bot by default
  return estate;
}

EState CodeThorn::CTAnalysis::createEState(Label label, CallString cs, PState pstate, ConstraintSet cset, InputOutput io) {
  EState estate=createEStateInternal(label,pstate,cset);
  estate.callString=cs;
  estate.io=io;
  return estate;
}

/*
EState CodeThorn::CTAnalysis::createEState(Label label, PState pstate, ConstraintSet cset, InputOutput io) {
  EState estate=createEState(label,pstate,cset);
  estate.io=io;
  return estate;
}
*/

bool CodeThorn::CTAnalysis::isStartLabel(Label label) {
  return getTransitionGraph()->getStartLabel()==label;
}

// Avoid calling critical sections from critical sections:
// worklist functions do not use each other.
bool CodeThorn::CTAnalysis::isEmptyWorkList() {
  bool res;
#pragma omp critical(ESTATEWL)
  {
    res=estateWorkListCurrent->empty();
  }
  return res;
}
const EState* CodeThorn::CTAnalysis::topWorkList() {
  const EState* estate=0;
#pragma omp critical(ESTATEWL)
  {
    if(!estateWorkListCurrent->empty())
      estate=estateWorkListCurrent->front();
  }
  return estate;
}
const EState* CodeThorn::CTAnalysis::popWorkList() {
  const EState* estate=0;
#pragma omp critical(ESTATEWL)
  {
    if(!estateWorkListCurrent->empty())
      estate=estateWorkListCurrent->front();
    if(estate) {
      estateWorkListCurrent->pop_front();
      if(getExplorationMode()==EXPL_LOOP_AWARE && isLoopCondLabel(estate->label())) {
        if(_curr_iteration_cnt==0) {
          _curr_iteration_cnt= (_next_iteration_cnt - 1);
          _next_iteration_cnt=0;
          incIterations();
        } else {
          _curr_iteration_cnt--;
        }
      }
    }
  }
  return estate;
}

// this function has to be protected by a critical section
// currently called once inside a critical section
void CodeThorn::CTAnalysis::swapWorkLists() {
  EStateWorkList* tmp = estateWorkListCurrent;
  estateWorkListCurrent = estateWorkListNext;
  estateWorkListNext = tmp;
  incIterations();
}


// set the size of an element determined by this type
void CodeThorn::CTAnalysis::setElementSize(VariableId variableId, SgType* elementType) {
  unsigned int typeSize=getVariableIdMapping()->getTypeSize(elementType);
  if(getVariableIdMapping()->getElementSize(variableId)!=0
     && getVariableIdMapping()->getElementSize(variableId)!=typeSize) {
    SAWYER_MESG(logger[WARN])<<"Element type size mismatch: "
                <<"CTAnalysis::setElementSize: variableId name: "<<getVariableIdMapping()->variableName(variableId)
                <<"typesize(from VID):"<<getVariableIdMapping()->getElementSize(variableId)
                <<" typeSize(fromtype): "<<typeSize<<" of "<<elementType->unparseToString()
                <<endl;
    // keep existing size from variableIdMapping
    return;
  }
  getVariableIdMapping()->setElementSize(variableId,typeSize);
}

// for arrays: number of elements (nested arrays not implemented yet)
// for variable: 1
// for structs: not implemented yet
int CodeThorn::CTAnalysis::computeNumberOfElements(SgVariableDeclaration* decl) {
  SgNode* initName0=decl->get_traversalSuccessorByIndex(1);
  if(SgInitializedName* initName=isSgInitializedName(initName0)) {
    SgInitializer* initializer=initName->get_initializer();
    if(SgAggregateInitializer* aggregateInitializer=isSgAggregateInitializer(initializer)) {
      SgArrayType* arrayType=isSgArrayType(aggregateInitializer->get_type());
      ROSE_ASSERT(arrayType);
      //SgType* arrayElementType=arrayType->get_base_type();
      SgExprListExp* initListObjPtr=aggregateInitializer->get_initializers();
      SgExpressionPtrList& initList=initListObjPtr->get_expressions();
      // TODO: nested initializers, currently only outermost elements: {{1,2,3},{1,2,3}} evaluates to 2.
      SAWYER_MESG(logger[TRACE])<<"computeNumberOfElements returns "<<initList.size()<<": case : SgAggregateInitializer"<<aggregateInitializer->unparseToString()<<endl;
      return initList.size();
    } else if(isSgAssignInitializer(initializer)) {
      SAWYER_MESG(logger[TRACE])<<"computeNumberOfElements returns 0: case SgAssignInitializer: "<<initializer->unparseToString()<<endl;
      return 0; // MS 3/5/2019: changed from 1 to 0
    }
  }
  return 0;
}

// sets all elements in PState according to aggregate
// initializer. Also models default values of Integers (floats not
// supported yet). EState is only used for lookup (modified is only
// the PState object).
PState CodeThorn::CTAnalysis::analyzeSgAggregateInitializer(VariableId initDeclVarId, SgAggregateInitializer* aggregateInitializer,PState pstate, /* for evaluation only  */ EState currentEState) {
  //cout<<"DEBUG: AST:"<<AstTerm::astTermWithNullValuesToString(aggregateInitializer)<<endl;
  ROSE_ASSERT(aggregateInitializer);
  SAWYER_MESG(logger[TRACE])<<"analyzeSgAggregateInitializer::array-initializer:"<<aggregateInitializer->unparseToString()<<endl;
  Label label=currentEState.label();
  PState newPState=pstate;
  int elemIndex=0;
  SgExprListExp* initListObjPtr=aggregateInitializer->get_initializers();
  SgExpressionPtrList& initList=initListObjPtr->get_expressions();

  for(SgExpressionPtrList::iterator i=initList.begin();i!=initList.end();++i) {
    AbstractValue arrayElemAddr=AbstractValue::createAddressOfArrayElement(initDeclVarId,AbstractValue(elemIndex));
    SgExpression* exp=*i;
    SgAssignInitializer* assignInit=isSgAssignInitializer(exp);
    if(assignInit==nullptr) {
      SAWYER_MESG(logger[WARN])<<"expected assign initializer but found "<<exp->unparseToString();
      SAWYER_MESG(logger[WARN])<<"AST: "<<AstTerm::astTermWithNullValuesToString(exp)<<endl;
      AbstractValue newVal=AbstractValue::createTop();
      getExprAnalyzer()->initializeMemoryLocation(label,&newPState,arrayElemAddr,newVal);
    } else {
      // initialize element of array initializer in state
      SgExpression* assignInitExpr=assignInit->get_operand();
      // currentEState from above, newPState must be the same as in currentEState.
      AbstractValue newVal=singleValevaluateExpression(assignInitExpr,currentEState);
      getExprAnalyzer()->initializeMemoryLocation(label,&newPState,arrayElemAddr,newVal);
    }
    elemIndex++;
  }
  // initialize remaining elements (if there are any) with default value
  int aggregateSize=(int)getVariableIdMapping()->getNumberOfElements(initDeclVarId);
  // if array size is not 0 then it was determined from the type and remaining elements are initialized
  if(aggregateSize==0) {
    // update aggregate size if it was not set yet
    aggregateSize=initList.size();
    getVariableIdMapping()->setNumberOfElements(initDeclVarId,aggregateSize);
  }

  // otherwise the size is determined from the aggregate initializer itself (done above)
  if(aggregateSize!=0) {
    for(int i=elemIndex;i<aggregateSize;i++) {
      AbstractValue arrayElemAddr=AbstractValue::createAddressOfArrayElement(initDeclVarId,AbstractValue(i));
      SAWYER_MESG(logger[TRACE])<<"Init aggregate default value: "<<arrayElemAddr.toString()<<endl;
      // there must be a default value because an aggregate initializer exists (it is never undefined in this case)
      // note: int a[3]={}; also forces the array to be initialized with {0,0,0}, the list can be empty.
      // whereas with int a[3]; all 3 are undefined
      AbstractValue defaultValue=AbstractValue(0); // TODO: cases where default value is not 0.
      getExprAnalyzer()->initializeMemoryLocation(label,&newPState,arrayElemAddr,defaultValue);
    }
  } else {
    // if aggregate size is 0 there is nothing to do
  }
  return newPState;
}

EState CodeThorn::CTAnalysis::analyzeVariableDeclaration(SgVariableDeclaration* decl,EState currentEState, Label targetLabel) {

  /*
    1) declaration of variable or array
    - AggregateInitializer (e.g. T a[]={1,2,3};)
    - AggregateInitializer (e.g. T a[5]={1,2,3};)
    - AssignInitializer (e.g. T x=1+2;)
    2) if array, determine size of array (from VariableIdMapping)
    3) if no size is provided, determine it from the initializer list (and add this information to the variableIdMapping - or update the variableIdMapping).
   */

  SAWYER_MESG(logger[TRACE])<<"analyzeVariableDeclaration:"<<decl->unparseToString()<<" : "<<AstTerm::astTermWithNullValuesToString(decl)<<endl;
  CallString cs=currentEState.callString;
  Label label=currentEState.label();

  const SgInitializedNamePtrList& initNameList=decl->get_variables();
  SgNode* initName0;
  if(initNameList.size()>1) {
    SAWYER_MESG(logger[ERROR])<<"Error: variable declaration contains more than one variable. Normalization required."<<endl;
    SAWYER_MESG(logger[ERROR])<<"Error: "<<decl->unparseToString()<<endl;

    exit(1);
  } else {
    //SgNode* initName0=decl->get_traversalSuccessorByIndex(1); // get-InitializedName
    ROSE_ASSERT(initNameList.size()==1);
    initName0=*initNameList.begin();
  }
  if(initName0!=nullptr) {
    if(SgInitializedName* initName=isSgInitializedName(initName0)) {
      VariableId initDeclVarId=getVariableIdMapping()->variableId(initName);
      // not possible to support yet. getIntValue must succeed on declarations.
      /*
      if(false && variableValueMonitor.isHotVariable(this,initDeclVarId)) {
        // DEAD CODE
        PState newPState=*currentEState.pstate();
        newPState.reserveMemoryLocation(initDeclVarId);
        ConstraintSet cset=*currentEState.constraints();
        InputOutput io;
        io.recordNone();
        return createEState(targetLabel,cs,newPState,cset);
      }
      */
      // deactivated 05/20/2020
      //      if(getVariableIdMapping()->hasArrayType(initDeclVarId) && _ctOpt.explicitArrays==false) {
        // in case of a constant array the array (and its members) are not added to the state.
        // they are considered to be determined from the initializer without representing them
        // in the state
        // logger[DEBUG] <<"not adding array to PState."<<endl;
      //  PState newPState=*currentEState.pstate();
      //  ConstraintSet cset=*currentEState.constraints();
      //  return createEState(targetLabel,cs,newPState,cset);
      //}

      ConstraintSet cset=*currentEState.constraints();
      SgInitializer* initializer=initName->get_initializer();
      if(initializer) {
        //cout<<"DEBUG: decl-init: "<<decl->unparseToString()<<":AST:"<<AstTerm::astTermWithNullValuesToString(initializer)<<endl;
        // special case that initializer is an assignment (reusing transferAssignOp)
        if(SgAssignInitializer* assignInit=isSgAssignInitializer(initializer)) {
          SgExpression* assignInitOperand=assignInit->get_operand_i();
          ROSE_ASSERT(assignInitOperand);
          if(SgAssignOp* assignOp=isSgAssignOp(assignInitOperand)) {
            SAWYER_MESG(logger[TRACE])<<"assignment in initializer: "<<decl->unparseToString()<<endl;
            //cout<<"DEBUG: assignment in initializer: "<<decl->unparseToString()<<endl;
            Edge dummyEdge(targetLabel,EDGE_FORWARD,targetLabel); // only target label is used in transferAssignOp
            //std::list<EState> estateList=transferAssignOp(assignOp, dummyEdge, &currentEState);
            CodeThorn::CTAnalysis::MemoryUpdateList memUpdList=evalAssignOp(assignOp,dummyEdge,&currentEState);
            std::list<EState> estateList;
            ROSE_ASSERT(memUpdList.size()==1);
            auto memUpd=*memUpdList.begin();
            // code is normalized, lhs must be a variable : tmpVar= var=val;
            // store result of assignment in declaration variable
            EState estate=memUpd.first;
            PState newPState=*estate.pstate();
            AbstractValue initDeclVarAddr=AbstractValue::createAddressOfVariable(initDeclVarId);
            AbstractValue lhsAddr=memUpd.second.first;
            AbstractValue rhsValue=memUpd.second.second;
            getExprAnalyzer()->writeToMemoryLocation(label,&newPState,lhsAddr,rhsValue); // assignment in initializer
            getExprAnalyzer()->initializeMemoryLocation(label,&newPState,initDeclVarAddr,rhsValue); // initialization of declared var
            return createEState(targetLabel,cs,newPState,cset);
          } else if(SgFunctionRefExp* funRefExp=isSgFunctionRefExp(assignInitOperand)) {
            //cout<<"DEBUG: DETECTED isSgFunctionRefExp: evaluating expression ..."<<endl;
            list<SingleEvalResultConstInt> res=exprAnalyzer.evaluateExpression(funRefExp,currentEState);
            if(res.size()!=1) {
              if(res.size()>1) {
                SAWYER_MESG(logger[ERROR])<<"Error: multiple results in rhs evaluation."<<endl;
                SAWYER_MESG(logger[ERROR])<<"expr: "<<SgNodeHelper::sourceLineColumnToString(decl)<<": "<<decl->unparseToString()<<endl;
                exit(1);
              } else {
                ROSE_ASSERT(res.size()==0);
                SAWYER_MESG(logger[TRACE])<<"no results in rhs evaluation (returning top): "<<decl->unparseToString()<<endl;
              }
            } else {
              ROSE_ASSERT(res.size()==1);
              SingleEvalResultConstInt evalResult=*res.begin();
              SAWYER_MESG(logger[TRACE])<<"rhs eval result: "<<evalResult.result.toString()<<endl;
              
              EState estate=evalResult.estate;
              PState newPState=*estate.pstate();
              AbstractValue initDeclVarAddr=AbstractValue::createAddressOfVariable(initDeclVarId);
              getExprAnalyzer()->initializeMemoryLocation(label,&newPState,initDeclVarAddr,evalResult.value());
              ConstraintSet cset=*estate.constraints();
              return createEState(targetLabel,cs,newPState,cset);
            }
          }
        }
        if(getVariableIdMapping()->hasClassType(initDeclVarId)) {
          SAWYER_MESG(logger[WARN])<<"initialization of structs not supported yet (not added to state) "<<SgNodeHelper::sourceFilenameLineColumnToString(decl)<<endl;
          // TODO: for(offset(membervar) : membervars {initialize(address(initDeclVarId)+offset,eval(initializer+));}
          //AbstractValue pointerVal=AbstractValue::createAddressOfVariable(initDeclVarId);
          // TODO: STRUCT VARIABLE DECLARATION
          //getExprAnalyzer()->reserveMemoryLocation(label,&newPState,pointerVal);
          PState newPState=*currentEState.pstate();
          return createEState(targetLabel,cs,newPState,cset);
        }
        if(getVariableIdMapping()->hasReferenceType(initDeclVarId)) {
          // TODO: initialization of references not supported yet
          SAWYER_MESG(logger[INFO])<<"initialization of reference:"<<SgNodeHelper::sourceFilenameLineColumnToString(decl)<<endl;
          SgAssignInitializer* assignInit=isSgAssignInitializer(initializer);
          ROSE_ASSERT(assignInit);
          SgExpression* assignInitOperand=assignInit->get_operand_i();
          ROSE_ASSERT(assignInitOperand);
          //list<SingleEvalResultConstInt> res=exprAnalyzer.evaluateExpression(assignInitOperand,currentEState, CodeThorn::ExprAnalyzer::MODE_ADDRESS);
          list<SingleEvalResultConstInt> res=exprAnalyzer.evaluateLExpression(assignInitOperand,currentEState);

          SAWYER_MESG(logger[INFO])<<"initialization of reference:"<<AstTerm::astTermWithNullValuesToString(assignInitOperand)<<endl;
          if(res.size()!=1) {
            if(res.size()>1) {
              SAWYER_MESG(logger[ERROR])<<"Error: multiple results in rhs evaluation."<<endl;
              SAWYER_MESG(logger[ERROR])<<"expr: "<<SgNodeHelper::sourceLineColumnToString(decl)<<": "<<decl->unparseToString()<<endl;
              exit(1);
            } else {
              ROSE_ASSERT(res.size()==0);
              SAWYER_MESG(logger[TRACE])<<"no results in rhs evaluation (returning top): "<<decl->unparseToString()<<endl;
            }
          } else {
            ROSE_ASSERT(res.size()==1);
            SingleEvalResultConstInt evalResult=*res.begin();
            SAWYER_MESG(logger[INFO])<<"rhs (reference init) result: "<<evalResult.result.toString()<<endl;
            
            EState estate=evalResult.estate;
            PState newPState=*estate.pstate();
            AbstractValue initDeclVarAddr=AbstractValue::createAddressOfVariable(initDeclVarId);
            //initDeclVarAddr.setRefType(); // known to be ref from hasReferenceType above
            // creates a memory cell in state that contains the address of the referred memory cell
            getExprAnalyzer()->initializeMemoryLocation(label,&newPState,initDeclVarAddr,evalResult.value());
            ConstraintSet cset=*estate.constraints();
            return createEState(targetLabel,cs,newPState,cset);
          }
          ROSE_ASSERT(false); // not reachable
        }
        // has aggregate initializer
        if(SgAggregateInitializer* aggregateInitializer=isSgAggregateInitializer(initializer)) {
          if(SgArrayType* arrayType=isSgArrayType(aggregateInitializer->get_type())) {
            SgType* arrayElementType=arrayType->get_base_type();
            setElementSize(initDeclVarId,arrayElementType);
            // only set size from aggregate initializer if not known from type
            if(getVariableIdMapping()->getNumberOfElements(initDeclVarId)==0) {
               getVariableIdMapping()->setNumberOfElements(initDeclVarId, computeNumberOfElements(decl));
            }
            PState newPState=*currentEState.pstate();
            newPState=analyzeSgAggregateInitializer(initDeclVarId, aggregateInitializer,newPState, currentEState);
            return createEState(targetLabel,cs,newPState,cset);
          } else {
            // type not supported yet
            SAWYER_MESG(logger[WARN])<<"aggregate initializer: unsupported type at: "<<SgNodeHelper::sourceFilenameLineColumnToString(decl)<<" : "<<aggregateInitializer->get_type()->unparseToString()<<endl;
            // do not modify state. Value remains top.
            PState newPState=*currentEState.pstate();
            ConstraintSet cset=*currentEState.constraints();
            return createEState(targetLabel,cs,newPState,cset);
          }
        } else if(SgAssignInitializer* assignInitializer=isSgAssignInitializer(initializer)) {
          SgExpression* rhs=assignInitializer->get_operand_i();
          ROSE_ASSERT(rhs);
          SAWYER_MESG(logger[TRACE])<<"declaration with assign initializer:"<<" lhs:"<<initDeclVarId.toString(getVariableIdMapping())<<" rhs:"<<assignInitializer->unparseToString()<<" decl-term:"<<AstTerm::astTermWithNullValuesToString(initName)<<endl;

          // only create string in state with variable as pointer-address if it is an array (not for the case it is a char* pointer)
          // in the case of char* it is handled as a pointer initializer (and the string-pointer is already available in state)
          if(SgStringVal* stringValNode=isSgStringVal(assignInitializer->get_operand())) {
            if(isSgArrayType(initName->get_type())) {
              // handle special cases of: char a[]="abc"; char a[4]="abc";
              // TODO: a[5]="ab";
              SAWYER_MESG(logger[TRACE])<<"Initalizing (array) with string: "<<stringValNode->unparseToString()<<endl;
              //size_t stringLen=stringValNode->get_value().size();
              if(getVariableIdMapping()->getNumberOfElements(initDeclVarId)==0) {
                VariableId stringLiteralId=getVariableIdMapping()->getStringLiteralVariableId(stringValNode);
                size_t stringLiteralMemoryRegionSize=getVariableIdMapping()->getNumberOfElements(stringLiteralId);
                getVariableIdMapping()->setNumberOfElements(initDeclVarId,stringLiteralMemoryRegionSize);
                SAWYER_MESG(logger[TRACE])<<"Determined size of array from literal string memory region size: "<<stringLiteralMemoryRegionSize<<endl;
              } else {
                SAWYER_MESG(logger[TRACE])<<"Determined size of array from array variable (containing string memory region) size: "<<getVariableIdMapping()->getNumberOfElements(initDeclVarId)<<endl;
              }
              SgType* variableType=initializer->get_type(); // for char and wchar
              setElementSize(initDeclVarId,variableType); // this must be a pointer, if it's not an array
              PState newPState=*currentEState.pstate();
              initializeStringLiteralInState(newPState,stringValNode,initDeclVarId);
              ConstraintSet cset=*currentEState.constraints();
              return createEState(targetLabel,cs,newPState,cset);
            }
          }
          // set type info for initDeclVarId
          getVariableIdMapping()->setNumberOfElements(initDeclVarId,1); // single variable
          SgType* variableType=initializer->get_type();
          setElementSize(initDeclVarId,variableType);

          // build lhs-value dependent on type of declared variable
          //AbstractValue lhsAbstractAddress=AbstractValue(initDeclVarId); // creates a pointer to initDeclVar
          AbstractValue lhsAbstractAddress=AbstractValue::createAddressOfVariable(initDeclVarId); // creates a pointer to initDeclVar
          list<SingleEvalResultConstInt> res=exprAnalyzer.evaluateExpression(rhs,currentEState);
          if(res.size()!=1) {
            if(res.size()>1) {
              SAWYER_MESG(logger[ERROR])<<"Error: multiple results in rhs evaluation."<<endl;
              SAWYER_MESG(logger[ERROR])<<"expr: "<<SgNodeHelper::sourceLineColumnToString(decl)<<": "<<decl->unparseToString()<<endl;
              exit(1);
            } else {
              ROSE_ASSERT(res.size()==0);
              SAWYER_MESG(logger[TRACE])<<"no results in rhs evaluation (returning top): "<<rhs->unparseToString()<<endl;
              EState estate=currentEState;
              PState newPState=*estate.pstate();
              // getExprAnalyzer()->writeToMemoryLocation(label,&newPState,lhsAbstractAddress,CodeThorn::Top());
              getExprAnalyzer()->reserveMemoryLocation(label,&newPState,lhsAbstractAddress);
              ConstraintSet cset=*estate.constraints();
              return createEState(targetLabel,cs,newPState,cset);
            }
          }
          ROSE_ASSERT(res.size()==1);
          SingleEvalResultConstInt evalResult=*res.begin();
          SAWYER_MESG(logger[TRACE])<<"rhs eval result: "<<evalResult.result.toString()<<endl;

          EState estate=evalResult.estate;
          PState newPState=*estate.pstate();
          getExprAnalyzer()->initializeMemoryLocation(label,&newPState,lhsAbstractAddress,evalResult.value());
          ConstraintSet cset=*estate.constraints();
          return createEState(targetLabel,cs,newPState,cset);
        } else {
          SAWYER_MESG(logger[WARN]) << "unsupported initializer in declaration: "<<decl->unparseToString()<<" not adding to state (assuming arbitrary value)"<<endl;
          PState newPState=*currentEState.pstate();
          return createEState(targetLabel,cs,newPState,cset);
        }
      } else {
        // no initializer (model default cases)
        ROSE_ASSERT(initName!=nullptr);
        SgArrayType* arrayType=isSgArrayType(initName->get_type());
        if(arrayType) {
          SgType* arrayElementType=arrayType->get_base_type();
          setElementSize(initDeclVarId,arrayElementType);
          int numElements=getVariableIdMapping()->getArrayElementCount(arrayType);
          if(numElements==0) {
            SAWYER_MESG(logger[TRACE])<<"Number of elements in array is 0 (from variableIdMapping) - evaluating expression"<<endl;
            std::vector<SgExpression*> arrayDimExps=SageInterface::get_C_array_dimensions(*arrayType);
            if(arrayDimExps.size()>1) {
              if(getAbstractionMode()==3) {
                CodeThorn::Exception("multi-dimensional arrays not supported yet.");
              } else {
                SAWYER_MESG(logger[WARN])<<"multi-dimensional arrays not supported yet. Only linear arrays are supported. Not added to state (assuming arbitrary value)."<<endl;
              }
              // not adding it to state. Will be used as unknown.
              PState newPState=*currentEState.pstate();
              return createEState(targetLabel,cs,newPState,cset);
            }
            ROSE_ASSERT(arrayDimExps.size()==1);
            SgExpression* arrayDimExp=*arrayDimExps.begin();
            SAWYER_MESG(logger[TRACE])<<"Array dimension expression: "<<arrayDimExp->unparseToString()<<endl;
            list<SingleEvalResultConstInt> evalResultList=exprAnalyzer.evaluateExpression(arrayDimExp,currentEState);
            ROSE_ASSERT(evalResultList.size()==1);
            SingleEvalResultConstInt evalRes=*evalResultList.begin();
            AbstractValue arrayDimAVal=evalRes.result;
            SAWYER_MESG(logger[TRACE])<<"Computed array dimension: "<<arrayDimAVal.toString()<<endl;
            if(arrayDimAVal.isConstInt()) {
              numElements=arrayDimAVal.getIntValue();
              getVariableIdMapping()->setNumberOfElements(initDeclVarId,numElements);
            } else {
              if(getAbstractionMode()==3) {
                CodeThorn::Exception("Could not determine size of array (non-const size).");
              }
              // TODO: size of array remains 1?
            }
          } else {
            getVariableIdMapping()->setNumberOfElements(initDeclVarId,numElements);
          }
        } else {
          // set type info for initDeclVarId
          getVariableIdMapping()->setNumberOfElements(initDeclVarId,1); // single variable
          SgType* variableType=initName->get_type();
          setElementSize(initDeclVarId,variableType);
        }

        PState newPState=*currentEState.pstate();
        if(getVariableIdMapping()->hasArrayType(initDeclVarId)) {
          // add default array elements to PState
          size_t length=getVariableIdMapping()->getNumberOfElements(initDeclVarId);
          //cout<<"DEBUG: DECLARING ARRAY: size: "<<decl->unparseToString()<<length<<endl;
          for(size_t elemIndex=0;elemIndex<length;elemIndex++) {
            AbstractValue newArrayElementAddr=AbstractValue::createAddressOfArrayElement(initDeclVarId,AbstractValue(elemIndex));
            // set default init value
            getExprAnalyzer()->reserveMemoryLocation(label,&newPState,newArrayElementAddr);
          }

        } else if(getVariableIdMapping()->hasClassType(initDeclVarId)) {
          // create only address start address of struct (on the
          // stack) alternatively addresses for all member variables
          // can be created; however, a member var can only be
          // assigned by denoting an element relative to the start of
          // the struct, similar only a pointer can be created. the
          // value is actually uninitialized and therefore is
          // implicitly bot.
          AbstractValue pointerVal=AbstractValue::createAddressOfVariable(initDeclVarId);
          SAWYER_MESG(logger[TRACE])<<"declaration of struct: "<<getVariableIdMapping()->getVariableDeclaration(initDeclVarId)->unparseToString()<<" : "<<pointerVal.toString(getVariableIdMapping())<<endl;
          // TODO: STRUCT VARIABLE DECLARATION
          getExprAnalyzer()->reserveMemoryLocation(label,&newPState,pointerVal);
        } else if(getVariableIdMapping()->hasPointerType(initDeclVarId)) {
          // create pointer value and set it to top (=any value possible (uninitialized pointer variable declaration))
          AbstractValue pointerVal=AbstractValue::createAddressOfVariable(initDeclVarId);
          getExprAnalyzer()->writeUndefToMemoryLocation(&newPState,pointerVal);
        } else {
          // set it to top (=any value possible (uninitialized)) for
          // all remaining cases. It will become an error-path once
          // all cases are addressed explicitly above.
          SAWYER_MESG(logger[TRACE])<<"declaration of variable (other): "<<getVariableIdMapping()->getVariableDeclaration(initDeclVarId)->unparseToString()<<endl;
          getExprAnalyzer()->reserveMemoryLocation(label,&newPState,AbstractValue::createAddressOfVariable(initDeclVarId));
        }
        return createEState(targetLabel,cs,newPState,cset);
      }
    } else {
      logger[ERROR] << "in declaration (@initializedName) no variable found ... bailing out."<<endl;
      exit(1);
    }
  } else {
    logger[ERROR] << "in declaration: no variable found ... bailing out."<<endl;
    exit(1);
  }
  ROSE_ASSERT(false); // non-reachable
}

bool CodeThorn::CTAnalysis::isFailedAssertEState(const EState* estate) {
  if(estate->io.isFailedAssertIO())
    return true;
  if(_treatStdErrLikeFailedAssert) {
    return estate->io.isStdErrIO();
  }
  return false;
}

bool CodeThorn::CTAnalysis::isVerificationErrorEState(const EState* estate) {
  if(estate->io.isVerificationError())
    return true;
  return false;
}

EState CodeThorn::CTAnalysis::createFailedAssertEState(EState estate, Label target) {
  EState newEState=estate;
  newEState.io.recordFailedAssert();
  newEState.setLabel(target);
  return newEState;
}

// creates a state that represents that the verification error function was called
// the edge is the external call edge
EState CodeThorn::CTAnalysis::createVerificationErrorEState(EState estate, Label target) {
  EState newEState=estate;
  newEState.io.recordVerificationError();
  newEState.setLabel(target);
  return newEState;
}

void CodeThorn::CTAnalysis::initLabeledAssertNodes(SgProject* root) {
  _assertNodes=listOfLabeledAssertNodes(root);
  SAWYER_MESG(logger[INFO])<<"DEBUG: number of labeled assert nodes: "<<_assertNodes.size()<<endl;
}

list<pair<SgLabelStatement*,SgNode*> > CodeThorn::CTAnalysis::listOfLabeledAssertNodes(SgProject* root) {
  list<pair<SgLabelStatement*,SgNode*> > assertNodes;
  list<SgFunctionDefinition*> funDefs=SgNodeHelper::listOfFunctionDefinitions(root);
  for(list<SgFunctionDefinition*>::iterator i=funDefs.begin();
      i!=funDefs.end();
      ++i) {
    RoseAst ast(*i);
    RoseAst::iterator prev=ast.begin();
    for(RoseAst::iterator j=ast.begin();j!=ast.end();++j) {
      if(SgNodeHelper::Pattern::matchAssertExpr(*j)) {
        if(prev!=j && isSgLabelStatement(*prev)) {
          SgLabelStatement* labStmt=isSgLabelStatement(*prev);
          //string name=labStmt->get_label().getString();
          // TODO check prefix error_
          //logger[INFO] <<"Found label "<<assertNodes.size()<<": "<<name<<endl;
          assertNodes.push_back(make_pair(labStmt,*j));
        }
      }
      prev=j;
    }
  }
  return assertNodes;
}

const EState* CodeThorn::CTAnalysis::processCompleteNewOrExisting(const EState* es) {
  const PState* ps=es->pstate();
  const ConstraintSet* cset=es->constraints();
  const PState* ps2=pstateSet.processNewOrExisting(ps);
  // TODO: ps2 check as below
  const ConstraintSet* cset2=constraintSetMaintainer.processNewOrExisting(cset);
  // TODO: cset2 check as below
  const EState* es2=new EState(es->label(),ps2,cset2, es->io);
  const EState* es3=estateSet.processNewOrExisting(es2);
  // equivalent object (but with different address) already exists
  // discard superfluous new object and use existing object pointer.
  if(es2!=es3) {
    delete es2;
  }
  return es3;
}

const PState* CodeThorn::CTAnalysis::processNew(PState& s) {
  return pstateSet.processNew(s);
}
const PState* CodeThorn::CTAnalysis::processNewOrExisting(PState& s) {
  return pstateSet.processNewOrExisting(s);
}

const EState* CodeThorn::CTAnalysis::processNew(EState& s) {
  return estateSet.processNew(s);
}

const EState* CodeThorn::CTAnalysis::processNewOrExisting(EState& estate) {
  return estateSet.processNewOrExisting(estate);
}

const ConstraintSet* CodeThorn::CTAnalysis::processNewOrExisting(ConstraintSet& cset) {
  return constraintSetMaintainer.processNewOrExisting(cset);
}

EStateSet::ProcessingResult CodeThorn::CTAnalysis::process(EState& estate) {
  return estateSet.process(estate);
}

// wrapper function for reusing exprAnalyzer's function. This function
// is only relevant for external functions (when the implementation
// does not exist in input program and the semantics are available in
// the analyzer (e.g. malloc, strlen, etc.))
list<EState> CodeThorn::CTAnalysis::evaluateFunctionCallArguments(Edge edge, SgFunctionCallExp* funCall, EState currentEState, bool useConstraints) {
  CallString cs=currentEState.callString;
  SAWYER_MESG(logger[TRACE]) <<"evaluating arguments of function call:"<<funCall->unparseToString()<<endl;
  list<SingleEvalResultConstInt> evalResultList=exprAnalyzer.evalFunctionCallArguments(funCall, currentEState);
  ROSE_ASSERT(evalResultList.size()>0);
  list<SingleEvalResultConstInt>::iterator resultListIter=evalResultList.begin();
  SingleEvalResultConstInt evalResult=*resultListIter;
  if(evalResultList.size()>1) {
    SAWYER_MESG(logger[ERROR]) <<"multi-state generating operators in function call parameters not supported."<<endl;
    exit(1);
  }
  PState newPState=*evalResult.estate.pstate();
  ConstraintSet cset=*evalResult.estate.constraints();
  return elistify(createEState(edge.target(),cs,newPState,cset));
}

void CodeThorn::CTAnalysis::recordAnalyzedFunction(SgFunctionDefinition* funDef) {
#pragma omp critical(functionrecording)
  {
    analyzedFunctions.insert(funDef);
  }
}

std::string CodeThorn::CTAnalysis::analyzedFunctionsToString() {
  ostringstream ss;
  for (auto funDef : analyzedFunctions)  {
    ss<<SgNodeHelper::getFunctionName(funDef)
      <<","
      <<SgNodeHelper::sourceLineColumnToString(funDef)
      <<","
      <<SgNodeHelper::sourceFilenameToString(funDef)
      <<endl;
  }
  return ss.str();
}

std::string CodeThorn::CTAnalysis::analyzedFilesToString() {
  unordered_set<string> fileNameSet;
  for (auto funDef : analyzedFunctions)  {
    fileNameSet.insert(SgNodeHelper::sourceFilenameToString(funDef));
  }
  ostringstream ss;
  for (auto fn : fileNameSet)  {
    ss<<fn<<endl;
  }
  return ss.str();
}

std::string CodeThorn::CTAnalysis::externalFunctionsToString() {
  ostringstream ss;
  for (auto funCall : externalFunctions)  {
    ss<<SgNodeHelper::getFunctionName(funCall)<<endl;
  }
  return ss.str();
}

void CodeThorn::CTAnalysis::recordExternalFunctionCall(SgFunctionCallExp* funCall) {
#pragma omp critical(funcallrecording)
  {
    externalFunctions.insert(funCall);
  }
}

list<EState> CodeThorn::CTAnalysis::transferEdgeEState(Edge edge, const EState* estate) {
  ROSE_ASSERT(edge.source()==estate->label());
  //cout<<"ESTATE: "<<estate->toString(getVariableIdMapping())<<endl;
  EState currentEState=*estate;
  PState currentPState=*currentEState.pstate();
  ConstraintSet cset=*currentEState.constraints();
  // 1. we handle the edge as outgoing edge
  ROSE_ASSERT(getCFAnalyzer());
  SgNode* nextNodeToAnalyze1=getCFAnalyzer()->getNode(edge.source());
  ROSE_ASSERT(nextNodeToAnalyze1);
  if(edge.isType(EDGE_LOCAL)) {
    return transferFunctionCallLocalEdge(edge,estate);
  } else if(SgNodeHelper::Pattern::matchAssertExpr(nextNodeToAnalyze1)) {
    // handle assert(0)
    return elistify(createFailedAssertEState(currentEState,edge.target()));
  } else if(edge.isType(EDGE_CALL) && SgNodeHelper::Pattern::matchFunctionCall(nextNodeToAnalyze1)) {
    return transferFunctionCall(edge,estate);
  } else if(edge.isType(EDGE_EXTERNAL) && SgNodeHelper::Pattern::matchFunctionCall(nextNodeToAnalyze1)) {
    // \todo the && condition excludes constructor calls
    return transferFunctionCallExternal(edge,estate);
  } else if(isSgReturnStmt(nextNodeToAnalyze1) && !SgNodeHelper::Pattern::matchReturnStmtFunctionCallExp(nextNodeToAnalyze1)) {
    // "return x;": add $return=eval() [but not for "return f();"]
    return transferReturnStmt(edge,estate);
  } else if(isSgAsmStmt(nextNodeToAnalyze1)) {
    return transferAsmStmt(edge,estate);
  } else if(getLabeler()->isFunctionEntryLabel(edge.source())) {
    return transferFunctionEntry(edge,estate);
  } else if(getLabeler()->isFunctionExitLabel(edge.source())) {
    return transferFunctionExit(edge,estate);
  } else if(getLabeler()->isFunctionCallReturnLabel(edge.source())) {
    return transferFunctionCallReturn(edge,estate);
  } else if(SgCaseOptionStmt* caseStmt=isSgCaseOptionStmt(nextNodeToAnalyze1)) {
    return transferCaseOptionStmt(caseStmt,edge,estate);
  } else if(SgDefaultOptionStmt* caseStmt=isSgDefaultOptionStmt(nextNodeToAnalyze1)) {
    return transferDefaultOptionStmt(caseStmt,edge,estate);
  } else if(SgVariableDeclaration* decl=isSgVariableDeclaration(nextNodeToAnalyze1)) {
    return transferVariableDeclaration(decl,edge,estate);
  } else if(isSgExprStatement(nextNodeToAnalyze1) || SgNodeHelper::isForIncExpr(nextNodeToAnalyze1)) {
    return transferExprStmt(nextNodeToAnalyze1, edge, estate);
  } else if(isSgStatementExpression(nextNodeToAnalyze1)) {
    // GNU extension
    return transferGnuExtensionStmtExpr(nextNodeToAnalyze1, edge, estate);
  } else if(SgFunctionCallExp* funCall=SgNodeHelper::Pattern::matchFunctionCall(nextNodeToAnalyze1)) {
    // TODO: this case should be handled as part of transferExprStmt (or ExpressionRoot)
    //cout<<"DEBUG: function call"<<(isCondition?" (inside condition) ":"")<<nextNodeToAnalyze1->unparseToString()<<endl;
    // this case cannot happen for normalized code
    SAWYER_MESG(logger[ERROR])<<"Function call detected (not represented in ICFG). Normalization required:"<<SgNodeHelper::sourceLineColumnToString(funCall)<<":"<<funCall->unparseToString()<<endl;
    exit(1);
    //bool useConstraints=false
    //return evaluateFunctionCallArguments(edge,funCall,*estate,useConstraints);
  } else {
      ROSE_ASSERT(!edge.isType(EDGE_EXTERNAL));
      ROSE_ASSERT(!edge.isType(EDGE_CALLRETURN));
    // nothing to analyze, just create new estate (from same State) with target label of edge
    // can be same state if edge is a backedge to same cfg node
    EState newEState=currentEState;
    newEState.setLabel(edge.target());
    return elistify(newEState);
  }
}

void CodeThorn::CTAnalysis::initializeStringLiteralInState(PState& initialPState,SgStringVal* stringValNode, VariableId stringVarId) {
  //cout<<"DEBUG: TODO: initializeStringLiteralInState"<<endl;
  string theString=stringValNode->get_value();
  int pos;
  for(pos=0;pos<(int)theString.size();pos++) {
    AbstractValue character(theString[pos]);
    initialPState.writeToMemoryLocation(AbstractValue::createAddressOfArrayElement(stringVarId,pos),character);
  }
  // add terminating 0 to string in state
  initialPState.writeToMemoryLocation(AbstractValue::createAddressOfArrayElement(stringVarId,pos),AbstractValue(0));
}

void CodeThorn::CTAnalysis::initializeStringLiteralsInState(PState& initialPState) {
  ROSE_ASSERT(getVariableIdMapping());
  //cout<<"DEBUG: TODO: initializeStringLiteralsInState"<<endl;
  std::map<SgStringVal*,VariableId>* map=getVariableIdMapping()->getStringLiteralsToVariableIdMapping();
  for(auto iter=map->begin();iter!=map->end();++iter) {
    auto dataPair=*iter;
    SgStringVal* stringValNode=dataPair.first;
    VariableId stringVarId=dataPair.second;
    initializeStringLiteralInState(initialPState,stringValNode,stringVarId);
    /*
    string theString=stringValNode->get_value();
    for(int pos=0;pos<(int)theString.size();pos++) {
      AbstractValue character(theString[pos]);
      initialPState.writeToMemoryLocation(AbstractValue::createAddressOfArrayElement(stringVarId,pos),character);
    }
    */
  }
}

/*
void CodeThorn::CTAnalysis::initialize(SgProject* project) {
  SAWYER_MESG(logger[INFO])<<"initializeVariableIdMapping:start"<<endl;
  getVariableIdMapping()->computeVariableSymbolMapping(project);
  SAWYER_MESG(logger[INFO])<<"initializeVariableIdMapping:done"<<endl;
  functionCallMapping.computeFunctionCallMapping(project);
  exprAnalyzer.setVariableIdMapping(getVariableIdMapping());
  AbstractValue::setVariableIdMapping(getVariableIdMapping());
}
*/

void CodeThorn::CTAnalysis::initializeCommandLineArgumentsInState(PState& initialPState) {
  // TODO1: add formal paramters of solo-function
  // SgFunctionDefinition* startFunRoot: node of function
  // estate=analyzeVariableDeclaration(SgVariableDeclaration*,estate,estate.label());
  string functionName=SgNodeHelper::getFunctionName(_startFunRoot);
  if(_startFunRoot==0) {
    // no main function, therefore nothing to initialize
    return;
  }
  SgInitializedNamePtrList& initNamePtrList=SgNodeHelper::getFunctionDefinitionFormalParameterList(_startFunRoot);
  VariableId argcVarId;
  VariableId argvVarId;
  size_t mainFunArgNr=0;
  for(SgInitializedNamePtrList::iterator i=initNamePtrList.begin();i!=initNamePtrList.end();++i) {
    VariableId varId=getVariableIdMapping()->variableId(*i);
    if(functionName=="main" && initNamePtrList.size()==2) {
      //string varName=getVariableIdMapping()->variableName(varId)) {
      switch(mainFunArgNr) {
      case 0:
	argcVarId=varId;
	SAWYER_MESG(logger[TRACE])<<"INIT CLARGS: found argc in main function."<<endl;
	break;
      case 1:
	argvVarId=varId;
	SAWYER_MESG(logger[TRACE])<<"INIT CLARGS: found argv in main function."<<endl;
	break;
      default:
        throw CodeThorn::Exception("Error: main function has more than 2 parameters.");
      }
      mainFunArgNr++;
    }
    ROSE_ASSERT(varId.isValid());
    // initialize all formal parameters of function (of extremal label) with top
    //initialPState[varId]=AbstractValue(CodeThorn::Top());
    AbstractValue address=AbstractValue::createAddressOfVariable(varId);
    initialPState.writeTopToMemoryLocation(address);
  }
  // if function main exists and has 2 arguments then argcvarid and argvvarid have valid ids now.
  // otherwise the command line options are ignored (because this is the correct behaviour)
  if(argcVarId.isValid() && argvVarId.isValid()) {
    if(_commandLineOptions.size()>0) {
      // create command line option array argv and argc in initial pstate if argv and argc exist in the program
      int argc=0;
      VariableId argvArrayMemoryId=getVariableIdMapping()->createAndRegisterNewMemoryRegion("$argvmem",(int)_commandLineOptions.size());
      AbstractValue argvAddress=AbstractValue::createAddressOfArray(argvArrayMemoryId);
      initialPState.writeToMemoryLocation(argvVarId,argvAddress);
      for (auto argvElem:_commandLineOptions) {
	SAWYER_MESG(logger[TRACE])<<"INIT: Initial state: "
		     <<getVariableIdMapping()->variableName(argvVarId)<<"["<<argc+1<<"]: "
		     <<argvElem<<endl;
	int regionSize=(int)string(argvElem).size();
	SAWYER_MESG(logger[TRACE])<<"argv["<<argc+1<<"] size: "<<regionSize<<endl;

	stringstream memRegionName;
	memRegionName<<"$argv"<<argc<<"mem";
	VariableId argvElemArrayMemoryId=getVariableIdMapping()->createAndRegisterNewMemoryRegion(memRegionName.str(),regionSize);
	AbstractValue argvElemAddress=AbstractValue::createAddressOfArray(argvElemArrayMemoryId);
	initialPState.writeToMemoryLocation(AbstractValue::createAddressOfArrayElement(argvVarId,argc),argvElemAddress);

	// copy concrete command line argument strings char by char to State
	for(int j=0;_commandLineOptions[argc][j]!=0;j++) {
	  SAWYER_MESG(logger[TRACE])<<"INIT: Copying: @argc="<<argc<<" char: "<<_commandLineOptions[argc][j]<<endl;
	  AbstractValue argvElemAddressWithIndexOffset;
	  AbstractValue AbstractIndex=AbstractValue(j);
	  argvElemAddressWithIndexOffset=argvElemAddress+AbstractIndex;
	  initialPState.writeToMemoryLocation(argvElemAddressWithIndexOffset,AbstractValue(_commandLineOptions[argc][j]));
	}
	argc++;
      }
      // this also covers the case that no command line options were provided. In this case argc==0. argv is non initialized.
      SAWYER_MESG(logger[TRACE])<<"INIT: Initial state argc:"<<argc<<endl;
      AbstractValue abstractValueArgc(argc);
      initialPState.writeToMemoryLocation(argcVarId,abstractValueArgc);
    } else {
      // argc and argv present in program but no command line arguments provided
      SAWYER_MESG(logger[TRACE])<<"INIT: no command line arguments provided. Initializing argc=0."<<endl;
      AbstractValue abstractValueArgc(0);
      initialPState.writeToMemoryLocation(argcVarId,abstractValueArgc);
    }
  } else {
    // argv and argc not present in program. argv and argc are not added to initialPState.
    // in this case it is irrelevant whether command line arguments were provided (correct behaviour)
    // nothing to do.
  }
}

void CodeThorn::CTAnalysis::startAnalysisTimer() {
  if (!_timerRunning) {
    _analysisTimer.start();
    _timerRunning=true;
    SAWYER_MESG(logger[INFO])<<"INFO: solver timer started."<<endl;
  }
}

void CodeThorn::CTAnalysis::stopAnalysisTimer() {
  _timerRunning=false;
  _analysisTimer.stop();
  SAWYER_MESG(logger[INFO])<<"INFO: solver timer stopped."<<endl;
}

SgNode* CodeThorn::CTAnalysis::getStartFunRoot() {
  return _startFunRoot;
}

void CodeThorn::CTAnalysis::run(CodeThornOptions& ctOpt, SgProject* root, Labeler* labeler, VariableIdMappingExtended* vim, CFAnalysis* icfg) {
  // TODO
}

void CodeThorn::CTAnalysis::initializeSolver2(std::string functionToStartAt, SgProject* root) {
  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3 started."<<endl;
  startAnalysisTimer();
  ROSE_ASSERT(root);

  ProgramAbstractionLayer* programAbstractionLayer=new ProgramAbstractionLayer();
  programAbstractionLayer->setNormalizationLevel(0);
  if(_ctOpt.normalizeFCalls)
    programAbstractionLayer->setNormalizationLevel(1);
  if(_ctOpt.normalizeAll)
    programAbstractionLayer->setNormalizationLevel(2);
  programAbstractionLayer->initialize(_ctOpt,root);
  initialize(_ctOpt,root,programAbstractionLayer);
  _programAbstractionLayer=programAbstractionLayer;
  _programAbstractionLayerOwner=true;

  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3a."<<endl;
  resetInputSequenceIterator();
  RoseAst completeast(root);

  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3b."<<endl;
  exprAnalyzer.setVariableIdMapping(getVariableIdMapping());
  AbstractValue::setVariableIdMapping(getVariableIdMapping());
  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3c."<<endl;

  // START_INIT 2
  if(_ctOpt.getInterProceduralFlag()) {
    _startFunRoot=completeast.findFunctionByName(functionToStartAt);
    if(_startFunRoot==0) {
      SAWYER_MESG(logger[ERROR]) << "Function '"<<functionToStartAt<<"' not found.\n";
      exit(1);
    } else {
      SAWYER_MESG(logger[INFO])<< "starting at function '"<<functionToStartAt<<"'."<<endl;
      SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3d."<<endl;
    }
  } else {
    // temporary to remain compatible
    _startFunRoot=completeast.findFunctionByName(functionToStartAt);
  }
  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3e."<<endl;
    
  SAWYER_MESG(logger[TRACE])<< "Initializing AST node info."<<endl;
  initAstNodeInfo(root);

  getCFAnalyzer()->setInterProcedural(_ctOpt.getInterProceduralFlag());
  getLabeler()->setExternalNonDetIntFunctionName(_externalNonDetIntFunctionName);
  getLabeler()->setExternalNonDetLongFunctionName(_externalNonDetLongFunctionName);

  CallString::setMaxLength(_ctOpt.callStringLength);

  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3f."<<endl;
  initializeSolver();
  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3g."<<endl;

  initializeTransferFunctions();
  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3h."<<endl;
  
  if(_ctOpt.getInterProceduralFlag()) {
    Label slab2=getLabeler()->getLabel(_startFunRoot);
    ROSE_ASSERT(slab2.isValid());
    ROSE_ASSERT(getLabeler()->isFunctionEntryLabel(slab2));
    ROSE_ASSERT(getFlow());
    getFlow()->addStartLabel(slab2);
  } else {
    LabelSet entryLabels=getCFAnalyzer()->functionEntryLabels(*getFlow());
    if(entryLabels.size()==0) {
      cout<<"Exit: No functions in program, nothing to analyze."<<endl;
      exit(0);
    }
    ROSE_ASSERT(getFlow());
    getFlow()->setStartLabelSet(entryLabels);
  }
  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3i."<<endl;

  // Runs consistency checks on the fork / join and workshare / barrier nodes in the parallel CFG
  // If the --omp-ast flag is not selected by the user, the parallel nodes are not inserted into the CFG
  if (_ctOpt.ompAst) {
    getCFAnalyzer()->forkJoinConsistencyChecks(*getFlow());
  }

  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3j."<<endl;
  if(_ctOpt.reduceCfg) {
    int cnt=getCFAnalyzer()->optimizeFlow(*getFlow());
    SAWYER_MESG(logger[TRACE])<< "CFG reduction OK. (eliminated "<<cnt<<" nodes)"<<endl;
  }
  SAWYER_MESG(logger[TRACE])<< "Intra-Flow OK. (size: " << getFlow()->size() << " edges)"<<endl;
  ROSE_ASSERT(_programAbstractionLayer);
  ROSE_ASSERT(_programAbstractionLayer->getCFAnalyzer());

#if 0
  if(_ctOpt.reduceCfg) {
    int cnt=cfanalyzer->inlineTrivialFunctions(flow);
    cout << "CFG reduction OK. (inlined "<<cnt<<" functions; eliminated "<<cnt*4<<" nodes)"<<endl;
  }
#endif

  // create empty state
  PState initialPState;
  initializeCommandLineArgumentsInState(initialPState);
  if(optionStringLiteralsInState) {
    initializeStringLiteralsInState(initialPState);
    if(_ctOpt.status) {
      cout<<"STATUS: created "<<getVariableIdMapping()->numberOfRegisteredStringLiterals()<<" string literals in initial state."<<endl;
    }
  }

  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3k."<<endl;
  // START_INIT 5
  const PState* initialPStateStored=processNew(initialPState);
  ROSE_ASSERT(initialPStateStored);
  SAWYER_MESG(logger[TRACE])<< "INIT: initial pstate(stored): "<<initialPStateStored->toString(getVariableIdMapping())<<endl;
  //ROSE_ASSERT(cfanalyzer);
  ConstraintSet cset;
  const ConstraintSet* emptycsetstored=constraintSetMaintainer.processNewOrExisting(cset);

  Label slab=getFlow()->getStartLabel();
  ROSE_ASSERT(slab.isValid());
  transitionGraph.setStartLabel(slab);
  transitionGraph.setAnalyzer(this);

  EState estate(slab,initialPStateStored,emptycsetstored);
  if(SgProject* project=isSgProject(root)) {
    SAWYER_MESG(logger[INFO])<< "Number of global variables: ";
    list<SgVariableDeclaration*> globalVars=SgNodeHelper::listOfGlobalVars(project);
    SAWYER_MESG(logger[INFO])<< globalVars.size()<<endl;
    SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3h1."<<endl;

#if 1
    // do not use usedVariablesInsideFunctions(project,getVariableIdMapping()->; (on full C)
    // this will not filter any variables
    VariableIdSet setOfUsedVars;
#else
    VariableIdSet setOfUsedVars=AstUtility::usedVariablesInsideFunctions(project,getVariableIdMapping());
    SAWYER_MESG(logger[TRACE])<< "STATUS: Number of used variables: "<<setOfUsedVars.size()<<endl;
#endif
    SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3h2."<<endl;

    // START_INIT 6
    SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver: number of variableIds:"<<getVariableIdMapping()->getNumVarIds()<<endl;
    int filteredVars=0;
    for(list<SgVariableDeclaration*>::iterator i=globalVars.begin();i!=globalVars.end();++i) {
      SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3h3_i."<<endl;
      VariableId globalVarId=getVariableIdMapping()->variableId(*i);
      if(!globalVarId.isValid()) {
        cout<<"WARNING: invalid global varid of: "<<(*i)->unparseToString()<<endl;
        continue;
      }
      ROSE_ASSERT(globalVarId.isValid());
      // TODO: investigate why array variables get filtered (but should not)
      if(true || (setOfUsedVars.find(globalVarId)!=setOfUsedVars.end() && _variablesToIgnore.find(globalVarId)==_variablesToIgnore.end())) {
        globalVarName2VarIdMapping[getVariableIdMapping()->variableName(getVariableIdMapping()->variableId(*i))]=getVariableIdMapping()->variableId(*i);
        if(_ctOpt.getInterProceduralFlag()) {
          // only initialize global variable in inter-procedural mode
          estate=analyzeVariableDeclaration(*i,estate,estate.label());
        } else {
          // do not intialize global variable
          SAWYER_MESG(logger[TRACE])<<"NOT INITIALIZED GLOBAL VARIABLE:"<<(*i)->unparseToString()<<endl;
        }
      } else {
        filteredVars++;
      }
    }
    SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3h4."<<endl;
    SAWYER_MESG(logger[TRACE])<< "STATUS: Number of filtered variables for initial pstate: "<<filteredVars<<endl;
    if(_variablesToIgnore.size()>0)
      SAWYER_MESG(logger[TRACE])<< "STATUS: Number of ignored variables for initial pstate: "<<_variablesToIgnore.size()<<endl;
  } else {
    SAWYER_MESG(logger[TRACE])<< "INIT: no global scope.";
  }

  //initializeGlobalVariables(root);
  SAWYER_MESG(logger[INFO])<<"CTAnalysis::initializeSolver3l."<<endl;
  setWorkLists(_explorationMode);
  
  estate.io.recordNone(); // ensure that extremal value is different to bot
  if(_ctOpt.getInterProceduralFlag()) {
    const EState* initialEState=processNew(estate); // START_INIT 6
    ROSE_ASSERT(initialEState);
    variableValueMonitor.init(initialEState);
    addToWorkList(initialEState); // START_INIT 7: ADD TO WORKLIST HERE!!!
    SAWYER_MESG(logger[INFO]) << "INIT: start state inter-procedural (extremal value): "<<initialEState->toString(getVariableIdMapping())<<endl;
  } else {
    LabelSet startLabels=getFlow()->getStartLabelSet();
    cout<<"STATUS: intra-procedural analysis with "<<startLabels.size()<<" start functions."<<endl;
    for(auto slab : startLabels) {
      // initialize intra-procedural analysis with all function entry points
      estate.setLabel(slab);
      const EState* initialEState=processNew(estate);
      ROSE_ASSERT(initialEState);
      variableValueMonitor.init(initialEState);
      addToWorkList(initialEState);
      SAWYER_MESG(logger[INFO]) << "INIT: start state intra-procedural (extremal value): "<<initialEState->toString(getVariableIdMapping())<<endl;
    }
  }
  
  // initialize summary states map for abstract model checking mode
  initializeSummaryStates(initialPStateStored,emptycsetstored);

  if(_ctOpt.rers.rersBinary) {
    //initialize the global variable arrays in the linked binary version of the RERS problem
    SAWYER_MESG(logger[DEBUG])<< "init of globals with arrays for "<< _numberOfThreadsToUse << " threads. " << endl;
    RERS_Problem::rersGlobalVarsArrayInitFP(_numberOfThreadsToUse);
    RERS_Problem::createGlobalVarAddressMapsFP(this);
  }
  SAWYER_MESG(logger[INFO])<<"Initializing solver finished."<<endl;
}

void CodeThorn::CTAnalysis::initAstNodeInfo(SgNode* node) {
  RoseAst ast(node);
  for(RoseAst::iterator i=ast.begin();i!=ast.end();++i) {
    AstNodeInfo* attr=new AstNodeInfo();
    (*i)->addNewAttribute("info",attr);
  }
}

void CodeThorn::CTAnalysis::generateAstNodeInfo(SgNode* node) {
  ROSE_ASSERT(node);
  if(!getCFAnalyzer()) {
    SAWYER_MESG(logger[ERROR])<< "CodeThorn::CTAnalysis:: no cfanalyzer available."<<endl;
    exit(1);
  }
  RoseAst ast(node);
  for(RoseAst::iterator i=ast.begin().withoutNullValues();i!=ast.end();++i) {
    ROSE_ASSERT(*i);
    AstNodeInfo* attr=dynamic_cast<AstNodeInfo*>((*i)->getAttribute("info"));
    if(attr) {
      if(getCFAnalyzer()->getLabel(*i)!=Label()) {
        if(isSgFunctionCallExp(*i)) {
          SAWYER_MESG(logger[TRACE])<<"skipping SgFunctionCallExp (direct pointer, not pattern): "<<(*i)->unparseToString()<<endl;
          continue;
        }
        attr->setLabel(getCFAnalyzer()->getLabel(*i));
        attr->setInitialLabel(getCFAnalyzer()->initialLabel(*i));
        attr->setFinalLabels(getCFAnalyzer()->finalLabels(*i));
      } else {
        (*i)->removeAttribute("info");
      }
    }
#if 0
    if(attr) cout<<":"<<attr->toString();
    else cout<<": no attribute!"<<endl;
#endif
  }
}

// experimental functions
bool CodeThorn::CTAnalysis::checkTransitionGraph() {
  set<const EState*> ess=transitionGraph.estateSet();
  bool ok=isConsistentEStatePtrSet(ess);
  ok=ok && getTransitionGraph()->checkConsistency();
  return ok;
}

bool CodeThorn::CTAnalysis::checkEStateSet() {
  for(EStateSet::iterator i=estateSet.begin();i!=estateSet.end();++i) {
    if(estateSet.estateId(*i)==NO_ESTATE || (*i)->label()==Label()) {
      SAWYER_MESG(logger[ERROR])<< "estateSet inconsistent. "<<endl;
      SAWYER_MESG(logger[ERROR])<< "  label   :"<<(*i)->label()<<endl;
      SAWYER_MESG(logger[ERROR])<< "   estateId: "<<estateSet.estateId(*i)<<endl;
      return false;
    }
  }
  SAWYER_MESG(logger[TRACE])<< "INFO: estateSet of size "<<estateSet.size()<<" consistent."<<endl;
  return true;
}

bool CodeThorn::CTAnalysis::isConsistentEStatePtrSet(set<const EState*> estatePtrSet)  {
  for(set<const EState*>::iterator i=estatePtrSet.begin();i!=estatePtrSet.end();++i) {
    if(estateSet.estateId(*i)==NO_ESTATE || (*i)->label()==Label()) {
      SAWYER_MESG(logger[ERROR])<< "estatePtrSet inconsistent. "<<endl;
      SAWYER_MESG(logger[ERROR])<< "  label   :"<<(*i)->label()<<endl;
      SAWYER_MESG(logger[ERROR])<< "   estateId: "<<estateSet.estateId(*i)<<endl;
      return false;
    }
  }
  SAWYER_MESG(logger[TRACE])<< "INFO: estatePtrSet of size "<<estatePtrSet.size()<<" consistent."<<endl;
  return true;
}

CTIOLabeler* CodeThorn::CTAnalysis::getLabeler() const {
  ROSE_ASSERT(_programAbstractionLayer);
  CTIOLabeler* ioLabeler=dynamic_cast<CTIOLabeler*>(_programAbstractionLayer->getLabeler());
  ROSE_ASSERT(ioLabeler);
  return ioLabeler;
}

/*
Label CodeThorn::CTAnalysis::getFunctionEntryLabel(SgFunctionRefExp* funRefExp) {
  Label lab;
  return lab;
}
*/

/*!
 * \author Marc Jasper
 * \date 2017.
 */
// MS 05/31/2020: this function is not used anywhere
void CodeThorn::CTAnalysis::resetAnalysis() {
  // reset miscellaneous state variables
  _topifyModeActive = false;
  _iterations = 0;
  _approximated_iterations = 0;
  _curr_iteration_cnt = 0;
  _next_iteration_cnt = 0;
  // reset worklists
  estateWorkListCurrent->clear();
  estateWorkListNext->clear();
  // reset state sets, but re-add STG start state (TODO: also reset constraint set)
  EState startEState=*(transitionGraph.getStartEState());
  PState startPState=*(startEState.pstate());
  EStateSet newEStateSet;
  estateSet = newEStateSet;
  PStateSet newPStateSet;
  pstateSet = newPStateSet;
  estateSet.max_load_factor(0.7);
  pstateSet.max_load_factor(0.7);
  const PState* processedPState=processNew(startPState);
  ROSE_ASSERT(processedPState);
  startEState.setPState(processedPState);
  const EState* processedEState=processNew(startEState);
  ROSE_ASSERT(processedEState);
  // reset STG //TODO: implement "void TransitionGraph::clear()"
  TransitionGraph emptyStg;
  emptyStg.setModeLTLDriven(transitionGraph.getModeLTLDriven());
  if(transitionGraph.getModeLTLDriven()) {
    emptyStg.setStartEState(processedEState);
    emptyStg.setAnalyzer(this);
  }
  emptyStg.setStartLabel(processedEState->label());
  emptyStg.setIsPrecise(transitionGraph.isPrecise());
  emptyStg.setIsComplete(transitionGraph.isComplete());
  transitionGraph = emptyStg;
  // reset variableValueMonitor
  VariableValueMonitor newVariableValueMonitor;
  variableValueMonitor = newVariableValueMonitor;
  variableValueMonitor.init(processedEState);
  // re-init worklist with STG start state
  addToWorkList(processedEState);
  // check if the reset yields the expected sizes of corresponding data structures
  ROSE_ASSERT(estateSet.size() == 1);
  ROSE_ASSERT(pstateSet.size() == 1);
  ROSE_ASSERT(transitionGraph.size() == 0);
  ROSE_ASSERT(estateWorkListCurrent->size() == 1);
  ROSE_ASSERT(estateWorkListNext->size() == 0);
}

/*!
  * \author Marc Jasper
  * \date 2014, 2015.
 */
void CodeThorn::CTAnalysis::storeStgBackup() {
  backupTransitionGraph = transitionGraph;
}

/*!
  * \author Marc Jasper
  * \date 2014, 2015.
 */
void CodeThorn::CTAnalysis::swapStgWithBackup() {
  TransitionGraph tTemp = transitionGraph;
  transitionGraph = backupTransitionGraph;
  backupTransitionGraph = tTemp;
}


/*!
  * \author Markus Schordan
  * \date 2019.
 */

#define FAST_GRAPH_REDUCE
void CodeThorn::CTAnalysis::reduceStg(function<bool(const EState*)> predicate) {
#ifdef FAST_GRAPH_REDUCE
  // MS 3/17/2019: new faster implementation
  transitionGraph.reduceEStates3(predicate);
#else
  _stgReducer.reduceStgToStatesSatisfying(predicate);
#endif
}


/*!
 * \author Marc Jasper
 * \date 2017.
 */
void CodeThorn::CTAnalysis::reduceStgToInOutStates() {
  function<bool(const EState*)> predicate = [](const EState* s) {
    return s->io.isStdInIO() || s->io.isStdOutIO();
  };
  reduceStg(predicate);
}

/*!
 * \author Marc Jasper
 * \date 2017.
 */
void CodeThorn::CTAnalysis::reduceStgToInOutAssertStates() {
  function<bool(const EState*)> predicate = [](const EState* s) {
    return s->io.isStdInIO() || s->io.isStdOutIO() || s->io.isFailedAssertIO();
  };
  reduceStg(predicate);
}

/*!
 * \author Marc Jasper
 * \date 2017.
 */
void CodeThorn::CTAnalysis::reduceStgToInOutAssertErrStates() {
  function<bool(const EState*)> predicate = [](const EState* s) {
    return s->io.isStdInIO() || s->io.isStdOutIO()  || s->io.isFailedAssertIO() || s->io.isStdErrIO();
  };
  reduceStg(predicate);
}

/*!
 * \author Marc Jasper
 * \date 2017.
 */
void CodeThorn::CTAnalysis::reduceStgToInOutAssertWorklistStates() {
  // copy elements from worklist into hashset (faster access within the predicate)
  unordered_set<const EState*> worklistSet(estateWorkListCurrent->begin(), estateWorkListCurrent->end());
  function<bool(const EState*)> predicate = [&worklistSet](const EState* s) {
    return s->io.isStdInIO() || s->io.isStdOutIO()
    || s->io.isFailedAssertIO() || (worklistSet.find(s) != worklistSet.end());
  };
  reduceStg(predicate);
}

int CodeThorn::CTAnalysis::reachabilityAssertCode(const EState* currentEStatePtr) {
  if(_ctOpt.rers.rersBinary) {
    int outputVal = getExprAnalyzer()->readFromMemoryLocation(currentEStatePtr->label(),currentEStatePtr->pstate(),globalVarIdByName("output")).getIntValue();
    if (outputVal > -100) {  //either not a failing assertion or a stderr output treated as a failing assertion)
      return -1;
    }
    int assertCode = ((outputVal+100)*(-1));
    ROSE_ASSERT(assertCode>=0 && assertCode <=99);
    return assertCode;
  }
  string name=labelNameOfAssertLabel(currentEStatePtr->label());
  if(name.size()==0)
    return -1;
  if(name=="globalError")
    name="error_60";
  name=name.substr(6,name.size()-6);
  std::istringstream ss(name);
  int num;
  ss>>num;
  return num;
}

void CodeThorn::CTAnalysis::setSkipUnknownFunctionCalls(bool flag) {
  _skipSelectedFunctionCalls=flag; 
  exprAnalyzer.setSkipUnknownFunctionCalls(flag);
}

void CodeThorn::CTAnalysis::setSkipArrayAccesses(bool skip) {
  exprAnalyzer.setSkipArrayAccesses(skip);
}

bool CodeThorn::CTAnalysis::getSkipArrayAccesses() {
  return exprAnalyzer.getSkipArrayAccesses();
}

void CodeThorn::CTAnalysis::setIgnoreUndefinedDereference(bool skip) {
  exprAnalyzer.setIgnoreUndefinedDereference(skip);
}

bool CodeThorn::CTAnalysis::getIgnoreUndefinedDereference() {
  return exprAnalyzer.getIgnoreUndefinedDereference();
}

void CodeThorn::CTAnalysis::set_finished(std::vector<bool>& v, bool val) {
  ROSE_ASSERT(v.size()>0);
  for(vector<bool>::iterator i=v.begin();i!=v.end();++i) {
    *i=val;
  }
}

bool CodeThorn::CTAnalysis::all_false(std::vector<bool>& v) {
  ROSE_ASSERT(v.size()>0);
  bool res=false;
#pragma omp critical
  {
  for(vector<bool>::iterator i=v.begin();i!=v.end();++i) {
    res=res||(*i);
  }
  }
  return !res;
}

void CodeThorn::CTAnalysis::mapGlobalVarInsert(std::string name, int* addr) {
  mapGlobalVarAddress[name]=addr;
  mapAddressGlobalVar[addr]=name;
}

void CodeThorn::CTAnalysis::setCompoundIncVarsSet(set<AbstractValue> ciVars) {
  _compoundIncVarsSet=ciVars;
}

void CodeThorn::CTAnalysis::setSmallActivityVarsSet(set<AbstractValue> saVars) {
  _smallActivityVarsSet=saVars;
}

void CodeThorn::CTAnalysis::setAssertCondVarsSet(set<AbstractValue> acVars) {
  _assertCondVarsSet=acVars;
}


long CodeThorn::CTAnalysis::analysisRunTimeInSeconds() {
  long result;
#pragma omp critical(TIMER)
  {
    result = (long) (_analysisTimer.getTimeDurationAndKeepRunning().seconds());
  }
  return result;
}

//void CodeThorn::CTAnalysis::setCFAnalyzer(CFAnalysis* cf) { cfanalyzer=cf; }
//CodeThorn::CFAnalysis* CodeThorn::CTAnalysis::getCFAnalyzer() const { return cfanalyzer; }

//VariableIdMappingExtended* CodeThorn::CTAnalysis::getVariableIdMapping() {
//  return getVariableIdMapping(); }

CodeThorn::FunctionCallMapping* CodeThorn::CTAnalysis::getFunctionCallMapping() {
  ROSE_ASSERT(_programAbstractionLayer);
  return _programAbstractionLayer->getFunctionCallMapping();
}
CodeThorn::FunctionCallMapping2* CodeThorn::CTAnalysis::getFunctionCallMapping2() {
  ROSE_ASSERT(_programAbstractionLayer);
  return _programAbstractionLayer->getFunctionCallMapping2();
}

CodeThorn::InterFlow* CodeThorn::CTAnalysis::getInterFlow() {
  ROSE_ASSERT(_programAbstractionLayer);
  return _programAbstractionLayer->getInterFlow();
}
CodeThorn::EStateSet* CodeThorn::CTAnalysis::getEStateSet() { return &estateSet; }
CodeThorn::PStateSet* CodeThorn::CTAnalysis::getPStateSet() { return &pstateSet; }
TransitionGraph* CodeThorn::CTAnalysis::getTransitionGraph() { return &transitionGraph; }
ConstraintSetMaintainer* CodeThorn::CTAnalysis::getConstraintSetMaintainer() { return &constraintSetMaintainer; }
std::list<CodeThorn::FailedAssertion> CodeThorn::CTAnalysis::getFirstAssertionOccurences(){return _firstAssertionOccurences;}

void CodeThorn::CTAnalysis::setCommandLineOptions(vector<string> clOptions) {
  _commandLineOptions=clOptions;
}

bool CodeThorn::CTAnalysis::isLTLRelevantEState(const EState* estate) {
  ROSE_ASSERT(estate);
  return ((estate)->io.isStdInIO()
          || (estate)->io.isStdOutIO()
          || (estate)->io.isStdErrIO()
          || (estate)->io.isFailedAssertIO());
}

std::string CodeThorn::CTAnalysis::typeSizeMappingToString() {
  return getVariableIdMapping()->typeSizeMappingToString();
}

void CodeThorn::CTAnalysis::setOptions(CodeThornOptions options) {
  _ctOpt=options;
}

CodeThornOptions& CodeThorn::CTAnalysis::getOptionsRef() {
  return _ctOpt;
}

void CodeThorn::CTAnalysis::setLtlOptions(LTLOptions ltlOptions) {
  _ltlOpt=ltlOptions;
}

LTLOptions& CodeThorn::CTAnalysis::getLtlOptionsRef() {
  return _ltlOpt;
}

// value semantics for upates
CallString CodeThorn::CTAnalysis::transferFunctionCallContext(CallString cs, Label lab) {
  SAWYER_MESG(logger[TRACE])<<"FunctionCallTransfer: adding "<<lab.toString()<<" to cs: "<<cs.toString()<<endl;
  cs.addLabel(lab);
  return cs;
}
bool CodeThorn::CTAnalysis::isFeasiblePathContext(CallString& cs,Label lab) {
  return cs.getLength()==0||cs.isLastLabel(lab);
}

//
// utility functions
//

AbstractValue CodeThorn::CTAnalysis::singleValevaluateExpression(SgExpression* expr,EState currentEState) {
  list<SingleEvalResultConstInt> resultList=exprAnalyzer.evaluateExpression(expr,currentEState);
  ROSE_ASSERT(resultList.size()==1);
  SingleEvalResultConstInt valueResult=*resultList.begin();
  AbstractValue val=valueResult.result;
  return val;
}

CodeThorn::CTAnalysis::MemoryUpdateList
CodeThorn::CTAnalysis::evalAssignOp(SgAssignOp* nextNodeToAnalyze2, Edge edge, const EState* estatePtr) {
  MemoryUpdateList memoryUpdateList;
  CallString cs=estatePtr->callString;
  EState currentEState=*estatePtr;
  SgNode* lhs=SgNodeHelper::getLhs(nextNodeToAnalyze2);
  SgNode* rhs=SgNodeHelper::getRhs(nextNodeToAnalyze2);
  list<SingleEvalResultConstInt> res=exprAnalyzer.evaluateExpression(rhs,currentEState, CodeThorn::ExprAnalyzer::MODE_VALUE);
  for(list<SingleEvalResultConstInt>::iterator i=res.begin();i!=res.end();++i) {
    VariableId lhsVar;
    bool isLhsVar=exprAnalyzer.checkIfVariableAndDetermineVarId(lhs,lhsVar);
    if(isLhsVar) {
      EState estate=(*i).estate;
      if(getVariableIdMapping()->hasClassType(lhsVar)) {
        // assignments to struct variables are not supported yet (this test does not detect s1.s2 (where s2 is a struct, see below)).
        SAWYER_MESG(logger[WARN])<<"assignment of structs (copy constructor) is not supported yet. Target update ignored! (unsound)"<<endl;
      } else if(getVariableIdMapping()->hasCharType(lhsVar)) {
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsVar,(*i).result)));
      } else if(getVariableIdMapping()->hasIntegerType(lhsVar)) {
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsVar,(*i).result)));
      } else if(getVariableIdMapping()->hasEnumType(lhsVar)) /* PP */ {
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsVar,(*i).result)));
      } else if(getVariableIdMapping()->hasFloatingPointType(lhsVar)) {
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsVar,(*i).result)));
      } else if(getVariableIdMapping()->hasBoolType(lhsVar)) {
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsVar,(*i).result)));
      } else if(getVariableIdMapping()->hasPointerType(lhsVar)) {
        // assume here that only arrays (pointers to arrays) are assigned
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsVar,(*i).result)));
      } else if(SgTypeString* lhsTypeTypeString=isSgTypeString(getVariableIdMapping()->getType(lhsVar))) {
        // assume here that only arrays (pointers to arrays) are assigned
        SAWYER_MESG(logger[WARN])<<"DEBUG: LHS assignment: typestring band aid"<<endl;
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsVar,(*i).result)));
      } else if(getVariableIdMapping()->hasReferenceType(lhsVar)) {
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsVar,(*i).result)));
      } else {
        // other types (e.g. function pointer type)
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsVar,(*i).result)));
#if 0
        SAWYER_MESG(logger[ERROR])<<"Error at "<<SgNodeHelper::sourceFilenameLineColumnToString(nextNodeToAnalyze2)<<endl;
        SAWYER_MESG(logger[ERROR])<<"Unsupported type on LHS side of assignment: "
                                  <<"type lhs: '"<<getVariableIdMapping()->getType(lhsVar)->unparseToString()<<"'"
                                  <<", "
                                  <<"AST type node: "<<getVariableIdMapping()->getType(lhsVar)->class_name()
                                  <<", Expr:"<<nextNodeToAnalyze2->unparseToString()
                                  <<endl;
        exit(1);
#endif
      }
    } else if(isSgDotExp(lhs)) {
      SAWYER_MESG(logger[TRACE])<<"detected dot operator on lhs "<<lhs->unparseToString()<<"."<<endl;
      list<SingleEvalResultConstInt> lhsRes=exprAnalyzer.evaluateExpression(lhs,currentEState, CodeThorn::ExprAnalyzer::MODE_ADDRESS);
      for (auto lhsAddressResult : lhsRes) {
        EState estate=(*i).estate;
        AbstractValue lhsAddress=lhsAddressResult.result;
        SAWYER_MESG(logger[TRACE])<<"detected dot operator on lhs: writing to "<<lhsAddress.toString(getVariableIdMapping())<<"."<<endl;
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsAddress,(*i).result)));
      }
    } else if(isSgArrowExp(lhs)) {
      SAWYER_MESG(logger[TRACE])<<"detected arrow operator on lhs "<<lhs->unparseToString()<<"."<<endl;
      list<SingleEvalResultConstInt> lhsRes=exprAnalyzer.evaluateExpression(lhs,currentEState, CodeThorn::ExprAnalyzer::MODE_ADDRESS);
      for (auto lhsAddressResult : lhsRes) {
        EState estate=(*i).estate;
        AbstractValue lhsAddress=lhsAddressResult.result;
        SAWYER_MESG(logger[TRACE])<<"detected arrow operator on lhs: writing to "<<lhsAddress.toString(getVariableIdMapping())<<"."<<endl;
        memoryUpdateList.push_back(make_pair(estate,make_pair(lhsAddress,(*i).result)));
      }
    } else if(isSgPntrArrRefExp(lhs)) {
      EState estate=(*i).estate;
      PState oldPState=*estate.pstate();
      if(getSkipArrayAccesses()) {
        // estateList.push_back(createEState(edge.target(),cs,oldPState,oldcset));
        // nothing to do (no memory access to add to list)
      } else {
        SgExpression* arrExp=isSgExpression(SgNodeHelper::getLhs(lhs));
        SgExpression* indexExp=isSgExpression(SgNodeHelper::getRhs(lhs));
        if(SgVarRefExp* varRefExp=isSgVarRefExp(arrExp)) {
          PState pstate2=oldPState;
          VariableId arrayVarId=getVariableIdMapping()->variableId(varRefExp);
          AbstractValue arrayPtrValue;
          // two cases
          if(getVariableIdMapping()->hasArrayType(arrayVarId)) {
            // create array element 0 (in preparation to have index added, or, if not index is used, it is already the correct index (=0).
            arrayPtrValue=AbstractValue::createAddressOfArray(arrayVarId);
          } else if(getVariableIdMapping()->hasPointerType(arrayVarId)) {
            // in case it is a pointer retrieve pointer value
            AbstractValue ptr=AbstractValue::createAddressOfArray(arrayVarId);
            if(pstate2.varExists(ptr)) {
              arrayPtrValue=getExprAnalyzer()->readFromMemoryLocation(estate.label(),&pstate2,ptr);
              //cout<<"DEBUG: arrayPtrValue: "<<arrayPtrValue.toString(getVariableIdMapping())<<endl;
              // convert integer to VariableId
              if(arrayPtrValue.isTop()||arrayPtrValue.isBot()) {
                if(getOptionOutputWarnings())
                  cout<<"Warning: "<<nextNodeToAnalyze2->unparseToString()<<arrayPtrValue.toString(getVariableIdMapping())<<" array index is top or bot. Not supported yet."<<endl;
              }
              // logger[DEBUG]<<"defering pointer-to-array: ptr:"<<getVariableIdMapping()->variableName(arrayVarId);
            } else {
              if(getOptionOutputWarnings())
                cout<<"Warning: lhs array access: pointer variable does not exist in PState:"<<ptr.toString()<<endl;
              arrayPtrValue=AbstractValue::createTop();
            }
          } else {
            SAWYER_MESG(logger[ERROR]) <<"lhs array access: unknown type of array or pointer."<<endl;
            exit(1);
          }

          list<SingleEvalResultConstInt> res=exprAnalyzer.evaluateExpression(indexExp,currentEState);
          ROSE_ASSERT(res.size()==1); // this should always hold for normalized ASTs
          AbstractValue indexValue=(*(res.begin())).value();
          AbstractValue arrayPtrPlusIndexValue=AbstractValue::operatorAdd(arrayPtrValue,indexValue);
          AbstractValue arrayElementAddr=arrayPtrPlusIndexValue;
          //cout<<"DEBUG: arrayElementId: "<<arrayElementId.toString(getVariableIdMapping())<<endl;
          //SAWYER_MESG(logger[TRACE])<<"arrayElementVarId:"<<arrayElementId.toString()<<":"<<getVariableIdMapping()->variableName(arrayVarId)<<" Index:"<<index<<endl;
          if(arrayElementAddr.isBot()) {
            // inaccessible memory location, return empty estate list
            return memoryUpdateList;
          }
          // read value of variable var id (same as for VarRefExp - TODO: reuse)
          // TODO: check whether arrayElementId (or array) is a constant array (arrayVarId)
          //TODO: getExprAnalyzer()->writeToMemoryLocation(label,&pstate2,arrayElementId,(*i).value()); // *i is assignment-rhs evaluation result
          memoryUpdateList.push_back(make_pair(estate,make_pair(arrayElementAddr,(*i).result)));
        } else if(SgAddressOfOp* addressOfOp=isSgAddressOfOp(lhs)) {
          // address of op, need to compute an l-value and use as address
          
        } else {
          list<SingleEvalResultConstInt> arrExpRes=exprAnalyzer.evaluateExpression(arrExp,currentEState);
          ROSE_ASSERT(arrExpRes.size()==1); // this should always hold for normalized ASTs
          AbstractValue arrPtrValue=(*(arrExpRes.begin())).value();
          list<SingleEvalResultConstInt> indexExpRes=exprAnalyzer.evaluateExpression(indexExp,currentEState);
          ROSE_ASSERT(indexExpRes.size()==1); // this should always hold for normalized ASTs
          AbstractValue indexValue=(*(indexExpRes.begin())).value();
          AbstractValue arrayPtrPlusIndexValue=AbstractValue::operatorAdd(arrPtrValue,indexValue);
          AbstractValue arrayElementAddr=arrayPtrPlusIndexValue;
          if(arrayElementAddr.isBot()) {
            return memoryUpdateList; // inaccessible memory location, return empty estate list
          }
          memoryUpdateList.push_back(make_pair(estate,make_pair(arrayElementAddr,(*i).result)));
          //above evaluation covers all cases now
          //SAWYER_MESG(logger[ERROR]) <<"array-access uses expr for denoting the array. Normalization missing."<<endl;
          //SAWYER_MESG(logger[ERROR]) <<"lhs AST: "<<AstTerm::astTermWithNullValuesToString(lhs)<<endl;
          //SAWYER_MESG(logger[ERROR]) <<"expr: "<<lhs->unparseToString()<<endl;
          //SAWYER_MESG(logger[ERROR]) <<"arraySkip: "<<getSkipArrayAccesses()<<endl;
          //exit(1);
        }
      }
    } else if(SgPointerDerefExp* lhsDerefExp=isSgPointerDerefExp(lhs)) {
      SgExpression* lhsOperand=lhsDerefExp->get_operand();
      SAWYER_MESG(logger[TRACE])<<"lhsOperand: "<<lhsOperand->unparseToString()<<endl;
      list<SingleEvalResultConstInt> resLhs=exprAnalyzer.evaluateExpression(lhsOperand,currentEState);
      if(resLhs.size()>1) {
        throw CodeThorn::Exception("more than 1 execution path (probably due to abstraction) in operand's expression of pointer dereference operator on lhs of "+nextNodeToAnalyze2->unparseToString());
      }
      ROSE_ASSERT(resLhs.size()==1);
      AbstractValue lhsPointerValue=(*resLhs.begin()).result;
      SAWYER_MESG(logger[TRACE])<<"lhsPointerValue: "<<lhsPointerValue.toString(getVariableIdMapping())<<endl;
      if(lhsPointerValue.isNullPtr()) {
        getExprAnalyzer()->recordDefinitiveNullPointerDereferenceLocation(estatePtr->label());
        // no state can follow, return estateList (may be empty)
        // TODO: create error state here?
        //return estateList;
        return memoryUpdateList;
      } else if(lhsPointerValue.isTop()) {
        getExprAnalyzer()->recordPotentialNullPointerDereferenceLocation(estatePtr->label());
        // specific case a pointer expr evaluates to top. Dereference operation
        // potentially modifies any memory location in the state.
        AbstractValue lhsAddress=lhsPointerValue;
        memoryUpdateList.push_back(make_pair(*estatePtr,make_pair(lhsAddress,(*i).result))); // lhsAddress is TOP!!!
      } else if(!(lhsPointerValue.isPtr())) {
        // changed isUndefined to isTop (2/17/20)
        if(lhsPointerValue.isTop() && getIgnoreUndefinedDereference()) {
          //cout<<"DEBUG: lhsPointerValue:"<<lhsPointerValue.toString(getVariableIdMapping())<<endl;
          // skip write access, just create new state (no effect)
          // nothing to do, as it request to not update the state in this case
        } else {
          SAWYER_MESG(logger[WARN])<<"not a pointer value (or top) in dereference operator: lhs-value:"<<lhsPointerValue.toLhsString(getVariableIdMapping())<<" lhs: "<<lhs->unparseToString()<<" : assuming change of any memory location."<<endl;
          getExprAnalyzer()->recordPotentialNullPointerDereferenceLocation(estatePtr->label());
          // specific case a pointer expr evaluates to top. Dereference operation
          // potentially modifies any memory location in the state.
          // iterate over all elements of the state and merge with rhs value
          memoryUpdateList.push_back(make_pair(*estatePtr,make_pair(lhsPointerValue,(*i).result))); // lhsPointerValue is TOP!!!
        }
      } else {
        //cout<<"DEBUG: lhsPointerValue:"<<lhsPointerValue.toString(getVariableIdMapping())<<endl;
        memoryUpdateList.push_back(make_pair(*estatePtr,make_pair(lhsPointerValue,(*i).result)));
      }
    } else {
      //cout<<"DEBUG: else (no var, no ptr) ... "<<endl;
      if(getSkipArrayAccesses()&&isSgPointerDerefExp(lhs)) {
        SAWYER_MESG(logger[WARN])<<"skipping pointer dereference: "<<lhs->unparseToString()<<endl;
      } else {
        SAWYER_MESG(logger[ERROR]) << "transferfunction:SgAssignOp: unrecognized expression on lhs."<<endl;
        SAWYER_MESG(logger[ERROR]) << "expr: "<< lhs->unparseToString()<<endl;
        SAWYER_MESG(logger[ERROR]) << "type: "<<lhs->class_name()<<endl;
        //cerr << "performing no update of state!"<<endl;
        exit(1);
      }
    }
  }
  return memoryUpdateList;
}

//
// wrapper functions to follow
//

std::list<EState> CodeThorn::CTAnalysis::elistify() {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->elistify();
}

std::list<EState> CodeThorn::CTAnalysis::elistify(EState res) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->elistify(res);
}

std::list<EState> CodeThorn::CTAnalysis::transferFunctionCallLocalEdge(Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferFunctionCallLocalEdge(edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferFunctionCall(Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferFunctionCall(edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferReturnStmt(Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferReturnStmt(edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferAsmStmt(Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferAsmStmt(edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferFunctionCallReturn(Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferFunctionCallReturn(edge,estate);
}
std::list<EState> CodeThorn::CTAnalysis::transferFunctionEntry(Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferFunctionEntry(edge,estate);
}
std::list<EState> CodeThorn::CTAnalysis::transferFunctionExit(Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferFunctionExit(edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferFunctionCallExternal(Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferFunctionCallExternal(edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferDefaultOptionStmt(SgDefaultOptionStmt* defaultStmt,Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferDefaultOptionStmt(defaultStmt,edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferCaseOptionStmt(SgCaseOptionStmt* caseStmt,Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferCaseOptionStmt(caseStmt,edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferVariableDeclaration(SgVariableDeclaration* decl, Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferVariableDeclaration(decl,edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferExprStmt(SgNode* nextNodeToAnalyze1, Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferExprStmt(nextNodeToAnalyze1,edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferGnuExtensionStmtExpr(SgNode* nextNodeToAnalyze1, Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferGnuExtensionStmtExpr(nextNodeToAnalyze1,edge,estate);
}

list<EState> CodeThorn::CTAnalysis::transferIncDecOp(SgNode* nextNodeToAnalyze2, Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferIncDecOp(nextNodeToAnalyze2,edge,estate);
}

list<EState> CodeThorn::CTAnalysis::transferIdentity(Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferIdentity(edge,estate);
}

std::list<EState> CodeThorn::CTAnalysis::transferAssignOp(SgAssignOp* nextNodeToAnalyze2, Edge edge, const EState* estate) {
  ROSE_ASSERT(_estateTransferFunctions);
  return _estateTransferFunctions->transferAssignOp(nextNodeToAnalyze2,edge,estate);
}

list<EState> CodeThorn::CTAnalysis::transferTrueFalseEdge(SgNode* nextNodeToAnalyze2, Edge edge, const EState* estate) {
  EState currentEState=*estate;
  CallString cs=estate->callString;
  Label newLabel;
  PState newPState;
  ConstraintSet newCSet;
  // MS: the use of contraints is necessary here (for LTL verification). The evaluation of conditions is the only necessary case.
#ifndef CONSTR_ELIM_DEBUG
  list<SingleEvalResultConstInt> evalResultList=exprAnalyzer.evaluateExpression(nextNodeToAnalyze2,currentEState);
#else
  list<SingleEvalResultConstInt> evalResultListF=exprAnalyzer.evaluateExpression(nextNodeToAnalyze2,currentEState,false);
  list<SingleEvalResultConstInt> evalResultList=exprAnalyzer.evaluateExpression(nextNodeToAnalyze2,currentEState,true);
  //  if(evalResultListF.size()!=evalResultList.size()) {
  //cout<<"DEBUG: different evalresultList sizes (false vs true):"<<evalResultList.size()<<":"<<evalResultListF.size()<<endl;
    for(list<SingleEvalResultConstInt>::iterator i=evalResultList.begin();
        i!=evalResultList.end();
        ++i) {
      SingleEvalResultConstInt evalResult=*i;
      if(evalResult.isBot()) cout <<" bot";
      if(evalResult.isTop()) cout <<" top";
      if(evalResult.isTrue()) cout <<" true";
      if(evalResult.isFalse()) cout <<" false";
    }
    cout <<" vs ";
    for(list<SingleEvalResultConstInt>::iterator i=evalResultListF.begin();
        i!=evalResultListF.end();
        ++i) {
      SingleEvalResultConstInt evalResult=*i;
      if(evalResult.isBot()) cout <<" bot";
      if(evalResult.isTop()) cout <<" top";
      if(evalResult.isTrue()) cout <<" true";
      if(evalResult.isFalse()) cout <<" false";
    }
    cout<<" @ "<<nextNodeToAnalyze2->unparseToString();
    cout<<endl;
    //}
#endif
  list<EState> newEStateList;
  for(list<SingleEvalResultConstInt>::iterator i=evalResultList.begin();
      i!=evalResultList.end();
      ++i) {
    SingleEvalResultConstInt evalResult=*i;
    if(evalResult.isBot()) {
      SAWYER_MESG(logger[ERROR])<<"PSTATE: "<<estate->pstate()->toString(getVariableIdMapping())<<endl;
      SAWYER_MESG(logger[ERROR])<<"Error: CONDITION EVALUATES TO BOT : "<<nextNodeToAnalyze2->unparseToString()<<endl;
      exit(1);
    }
    if((evalResult.isTrue() && edge.isType(EDGE_TRUE)) || (evalResult.isFalse() && edge.isType(EDGE_FALSE)) || evalResult.isTop()) {
      // pass on EState
      newLabel=edge.target();
      newPState=*evalResult.estate.pstate();
#if 0
      // merge with collected constraints of expr (exprConstraints)
      if(edge.isType(EDGE_TRUE)) {
        newCSet=*evalResult.estate.constraints()+evalResult.exprConstraints;
      } else if(edge.isType(EDGE_FALSE)) {
        ConstraintSet s1=*evalResult.estate.constraints();
        ConstraintSet s2=evalResult.exprConstraints;
        newCSet=s1+s2;
      } else {
        SAWYER_MESG(logger[ERROR])<<"Expected true/false edge. Found edge:"<<edge.toString()<<endl;
        exit(1);
      }
#endif
#if 0
      // make check-ltl-rers-topify (topify => constraints are collected)
      if(newCSet.size()>0) {
        cout<<"DEBUG: cset: "<<newCSet.toString()<<endl;
        cout<<"DEBUG: pstate: "<<estate->pstate()->toString(getVariableIdMapping())<<endl;
      }
#endif
      // use new empty cset instead of computed cset
      ROSE_ASSERT(newCSet.size()==0);
      EState newEstate=createEState(newLabel,cs,newPState,newCSet);
      newEStateList.push_back(newEstate);
    } else {
      // we determined not to be on an execution path, therefore do nothing (do not add any result to resultlist)
      //cout<<"DEBUG: not on feasable execution path. skipping."<<endl;
    }
  }
  return newEStateList;
}

void CodeThorn::CTAnalysis::setFunctionResolutionModeInCFAnalysis(CodeThornOptions& ctOpt) {
  switch(int argVal=ctOpt.functionResolutionMode) {
  case 1: CFAnalysis::functionResolutionMode=CFAnalysis::FRM_TRANSLATION_UNIT;break;
  case 2: CFAnalysis::functionResolutionMode=CFAnalysis::FRM_WHOLE_AST_LOOKUP;break;
  case 4: CFAnalysis::functionResolutionMode=CFAnalysis::FRM_FUNCTION_CALL_MAPPING;break;
  default: 
    cerr<<"Error: unsupported argument value of "<<argVal<<" for function-resolution-mode.";
    exit(1);
  }
}
