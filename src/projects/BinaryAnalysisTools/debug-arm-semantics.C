#include <rose.h>

#include <Disassembler.h>
#include <MemoryMap.h>
#include <Partitioner2/Engine.h>
#include <rose_strtoull.h>
#include <TraceSemantics2.h>

using namespace Rose;
using namespace Rose::BinaryAnalysis;
namespace P2 = Rose::BinaryAnalysis::Partitioner2;
namespace S2 = Rose::BinaryAnalysis::InstructionSemantics2;

static const rose_addr_t startingVa = 0;

static MemoryMap::Ptr
parseBytes(int argc, char *argv[]) {
    std::vector<uint8_t> bytes;
    for (int i = 1; i < argc; ++i) {
        uint8_t byte = rose_strtoull(argv[i], NULL, 16);
        bytes.push_back(byte);
    }
    std::reverse(bytes.begin(), bytes.end());

    auto map = MemoryMap::instance();
    map->insert(AddressInterval::baseSize(startingVa, bytes.size()),
                MemoryMap::Segment(MemoryMap::AllocatingBuffer::instance(bytes.size()),
                                   0, MemoryMap::READ_EXECUTE, "data"));
    map->at(startingVa).write(bytes);
    return map;
}

int
main(int argc, char *argv[]) {
    ROSE_INITIALIZE;
    MemoryMap::Ptr memory = parseBytes(argc, argv);
    P2::Engine engine;
    engine.settings().disassembler.isaName = "a64";
    engine.memoryMap(memory);
    P2::Partitioner p = engine.createTunedPartitioner();
    auto symOps = S2::SymbolicSemantics::RiscOperators::promote(p.newOperators());
    symOps->trimThreshold(UNLIMITED);
    std::cout <<"expr size limit = " <<symOps->trimThreshold() <<"\n";
    auto ops = S2::TraceSemantics::RiscOperators::instance(symOps);
    S2::BaseSemantics::Dispatcher::Ptr cpu = p.newDispatcher(ops);

    size_t va = memory->hull().least();
    while (SgAsmInstruction *insn = p.instructionProvider()[va]) {
        std::cerr <<p.unparse(insn) <<"\n";
        cpu->processInstruction(insn);
        std::cerr <<*ops->currentState();
        va += insn->get_size();
    }
}
