
// We need this header file so that we can use the mechanisms within ROSE to build a preprocessor
#include "rose.h"

// Temp code placed here while we debug it

#if 0
SgStatementPtrListPtr
SgNode::generateAST (
   SgProject & project,
   const char* sourceCodeString,
   const char* localDeclaration,
   const char* globalDeclaration,
   bool isADeclaration )
   {
  // This function generates an AST fragment from a string.  Since the string can't encode if it is
  // a declaration or not we have to use an extra parameter to specify declarations from other
  // executable statements (which could not appear in a list of declarations).  The different is in
  // how the source code string is used to build the intermediate AST.  If it is entirely
  // declarations, then the string can appear in the global scope of the intermediate program which
  // we build and pass to the C++ front-end.  If the source code string does not represent (only)
  // declarations then it must be edited into the body of a function to form the intermediate
  // problem and then passed to the C++ front-end.

#if 1
      printf ("This code in implemented in the AST_Rewrite::ASTFragmentContainer::ASTFragmentContainer() function \n");
      printf ("That code needs to be moved to be a part of the SgNode class (exiting ... ). \n");
      ROSE_ABORT();
      return NULL;
#else
  // Nondeclaration statements (for loops, expression statements, etc.) can't appear in the global scope
     char* staticNonDeclarationStringSourceCodeTemplate = "\
// ################################################################\n\
// THIS IS AN AUTOMATICALLY GENERATED FILE (DO NOT EDIT THIS FILE!)\n\
// ################################################################\n\n\
$USER_DEFINED_GLOBAL_DECLARATIONS\n\n\
int\n\
transformationContainerFunction() \n\
   {\n\
$USER_DEFINED_TRANSFORMATION_SOURCE \n\
     return 0;\n\
   }\n\n";

  // Temporary code
     char* staticDeclarationStringSourceCodeTemplate = staticNonDeclarationStringSourceCodeTemplate;

#if 1
     printf ("In generateAST(): globalDeclaration = \n%s\n",globalDeclaration);
     printf ("In generateAST(): localDeclaration  = \n%s\n",localDeclaration);
     printf ("In generateAST(): sourceCodeString  = \n%s\n",sourceCodeString);
#endif

  // We need to have a string built from dynamically allocated memory using
  // the C++ new operator since it will be deleted in the copyEdit() function
  // This avoids a purify error (so we have to call stringDuplicate())
     char* sourceCodeTemplate = NULL;
     if (isADeclaration == true)
          sourceCodeTemplate = stringDuplicate(staticDeclarationStringSourceCodeTemplate);
       else
          sourceCodeTemplate = stringDuplicate(staticNonDeclarationStringSourceCodeTemplate);

  // We have to make a copy of the sourceCodeTemplate input string to the copyEdit function
     char* declarations = StringUtility::stringConcatinate(globalDeclaration,localDeclaration);

     char* finalSourceCodeString =
          copyEdit ( sourceCodeTemplate, "$USER_DEFINED_GLOBAL_DECLARATIONS" , declarations );

     finalSourceCodeString =
          copyEdit ( finalSourceCodeString, "$USER_DEFINED_TRANSFORMATION_SOURCE" , sourceCodeString );

  // printf ("Transformation (sourceCodeForTransformation) = \n %s \n\n",sourceCodeForTransformation);
  // printf ("Transformation (finalSourceCodeString)       = \n %s \n\n",finalSourceCodeString);

  // For now - write the string representing the transformation out to a file
  // Later we can try to avoid the intermediate file generation (but for now 
  // this helps us debug the whole transformation specification mechanism).
     writeFile(
          /* transformation string */ finalSourceCodeString ,
          /* filename */ "rose_transformation.C" ,
          /* directory */ "./" );

  // Now generate the AST representing the transformation (for substitution)
  // The problem with sending each transformation through the compiler
  // infrastructure is that it could be slow.  Short specialized header files
  // might be helpful in reducing the compile time associated with this approach.
  // We might want to just use a SgFile instead of a SgProject!
     int errorCode = 0;

#if 0
     printf ("Exiting within TransformationSpecificationType::buildAST_Fragment() \n");
     ROSE_ABORT();
#endif

  // Now we want to get the command line out of the project object (instead of a static variable)
  // This allows there to be more than on project in the same executable.
     int transformation_argc    = project.get_defaultNumberOfCommandLineArguments();
     ROSE_ASSERT (transformation_argc > 1);
     char** project_argv        = project.get_defaultCommandLineArgumentList();
     ROSE_ASSERT (project_argv != NULL);

     char** transformation_argv = buildCommandLineToSubstituteTransformationFile (transformation_argc,project_argv);
     ROSE_ASSERT (transformation_argv != NULL);

  // printf ("Calling SgProject constructor (with the wrong inputs) \n");

  // printf ("Exiting after buildCommandLineToSubstituteTransformationFile \n");
  // ROSE_ABORT();

  // SgProject transformationAST (sourceCodeForTransformation,argc,argv,errorCode);
  // SgProject transformationAST (argc,modifiedCommandLine_argv,errorCode);

  // We need the lifetime to be extended beyond that of this function (to avoid purify error)
  // SgFile transformationAST (transformation_argc,transformation_argv,errorCode);
     SgFile* transformationASTPointer = new SgFile (transformation_argc,transformation_argv,errorCode);
     ROSE_ASSERT (transformationASTPointer != NULL);
     ROSE_ASSERT (errorCode <= 2);

  // printf ("DONE: Calling SgProject constructor (with the wrong inputs) \n");

  // At this point the transformation has been placed into the global scope and
  // we have to extract it into a form more useful to use (ready to substitute)
  // Ultimately we require more generality than this. The stripAwayWrapping() 
  // function is a member function of the base class (TransformationSpecificationType).
  // printf ("Get the AST fragement representing the transformation out of the global AST! \n");
  // SgNode* returnNode = stripAwayWrapping(*transformationASTPointer);
     SgStatementPtrList* returnStatementListPtr = stripAwayWrapping(*transformationASTPointer,isADeclaration);
     ROSE_ASSERT (returnStatementListPtr != NULL);

     ROSE_ASSERT (returnStatementListPtr->size() > 0);

  // printf ("DONE: Get the AST fragement representing the transformation out of the global AST (of the transformation)! \n");

  // ROSE_ASSERT (returnNode != NULL);
  // return returnNode;
     return returnStatementListPtr;

#if 0
  // We don't need to unparse the transformation (but for debugging it is sometimes useful)

     printf ("START: Unparsing transformationAST! \n");

  // debugging code (make sure that the transformation's AST can be unparsed)
     transformationAST.set_verbose(true);
  // transformationAST.set_skip_unparse(false);
     transformationAST.unparse();

     printf ("DONE: Unparsing transformationAST! Exiting ... \n");
     ROSE_ABORT();
#endif

// endif that comments out most of this body of code
#endif
   }
#endif






